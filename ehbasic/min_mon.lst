ca65 V2.19 - Git 2c4d4d331
Main file   : min_mon.asm
Current file: min_mon.asm

000000r 1               ; minimal monitor for EhBASIC and 6502 simulator V1.05
000000r 1               ; tabs converted to space, tabwidth=6
000000r 1               
000000r 1               ; To run EhBASIC on the simulator load and assemble [F7] this file, start the simulator
000000r 1               ; running [F6] then start the code with the RESET [CTRL][SHIFT]R. Just selecting RUN
000000r 1               ; will do nothing, you'll still have to do a reset to run the code.
000000r 1               
000000r 1                     .include "basic.asm"
000000r 2               
000000r 2               ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22p5
000000r 2               
000000r 2               ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
000000r 2               
000000r 2               ; 2.00      new revision numbers start here
000000r 2               ; 2.01      fixed LCASE$() and UCASE$()
000000r 2               ; 2.02      new get value routine done
000000r 2               ; 2.03      changed RND() to galoise method
000000r 2               ; 2.04      fixed SPC()
000000r 2               ; 2.05      new get value routine fixed
000000r 2               ; 2.06      changed USR() code
000000r 2               ; 2.07      fixed STR$()
000000r 2               ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
000000r 2               ; 2.09      fixed RND()
000000r 2               ; 2.10      integrated missed changes from an earlier version
000000r 2               ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 2               ; 2.21      fixed IF .. THEN RETURN to not cause error
000000r 2               ; 2.22      fixed RND() breaking the get byte routine
000000r 2               ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
000000r 2               ;              (bugsnquirks.txt notes 2, 4 and 5)
000000r 2               ;              tabs converted to spaces, tabwidth=6
000000r 2               ; 2.22p2    fixed can't continue error on 1st statement after direct mode
000000r 2               ;              changed INPUT to throw "break in line ##" on empty line input
000000r 2               ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
000000r 2               ;              fix provided by github user mgcaret
000000r 2               ; 2.22p4    fixed string compare of equal strings in direct mode returns FALSE
000000r 2               ;              fixed FALSE stored to a variable after a string compare
000000r 2               ;                 is > 0 and < 1E-16
000000r 2               ;              added additional stack floor protection for background interrupts
000000r 2               ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
000000r 2               ; 2.22p5    fixes issues reported by users Ruud and dclxvi on the 6502.org forum
000000r 2               ;      5.0     http://forum.6502.org/viewtopic.php?f=5&t=5500
000000r 2               ;              sanity check for RAM top allows values below RAM base
000000r 2               ;      5.1-7   http://forum.6502.org/viewtopic.php?f=5&t=5606
000000r 2               ;              1-7 coresponds to the bug# in the thread
000000r 2               ;      5.1     TO expression with a subtract may evaluate with the sign bit flipped
000000r 2               ;      5.3     call to LAB_1B5B may return to an address -$100 (page not incremented)
000000r 2               ;      5.4     string concatenate followed by MINUS or NOT() crashes EhBASIC
000000r 2               ;      5.5     garbage collection may cause an overlap with temporary strings
000000r 2               ;      5.6     floating point multiply rounding bug
000000r 2               ;      5.7     VAL() may cause string variables to be trashed
000000r 2               
000000r 2               ; zero page use ..
000000r 2               
000000r 2               ; the following locations are bulk initialized from StrTab at LAB_GMEM
000000r 2               LAB_WARM          = $00       ; BASIC warm start entry point
000000r 2               Wrmjpl            = LAB_WARM+1; BASIC warm start vector jump low byte
000000r 2               Wrmjph            = LAB_WARM+2; BASIC warm start vector jump high byte
000000r 2               
000000r 2               Usrjmp            = $0A       ; USR function JMP address
000000r 2               Usrjpl            = Usrjmp+1  ; USR function JMP vector low byte
000000r 2               Usrjph            = Usrjmp+2  ; USR function JMP vector high byte
000000r 2               Nullct            = $0D       ; nulls output after each line
000000r 2               TPos              = $0E       ; BASIC terminal position byte
000000r 2               TWidth            = $0F       ; BASIC terminal width byte
000000r 2               Iclim             = $10       ; input column limit
000000r 2               Itempl            = $11       ; temporary integer low byte
000000r 2               Itemph            = Itempl+1  ; temporary integer high byte
000000r 2               ; end bulk initialize from StrTab at LAB_GMEM
000000r 2               
000000r 2               nums_1            = Itempl    ; number to bin/hex string convert MSB
000000r 2               nums_2            = nums_1+1  ; number to bin/hex string convert
000000r 2               nums_3            = nums_1+2  ; number to bin/hex string convert LSB
000000r 2               
000000r 2               Srchc             = $5B       ; search character
000000r 2               Temp3             = Srchc     ; temp byte used in number routines
000000r 2               Scnquo            = $5C       ; scan-between-quotes flag
000000r 2               Asrch             = Scnquo    ; alt search character
000000r 2               
000000r 2               XOAw_l            = Srchc     ; eXclusive OR, OR and AND word low byte
000000r 2               XOAw_h            = Scnquo    ; eXclusive OR, OR and AND word high byte
000000r 2               
000000r 2               Ibptr             = $5D       ; input buffer pointer
000000r 2               Dimcnt            = Ibptr     ; # of dimensions
000000r 2               Tindx             = Ibptr     ; token index
000000r 2               
000000r 2               Defdim            = $5E       ; default DIM flag
000000r 2               Dtypef            = $5F       ; data type flag, $FF=string, $00=numeric
000000r 2               Oquote            = $60       ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
000000r 2               Gclctd            = $60       ; garbage collected flag
000000r 2               Sufnxf            = $61       ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000000r 2               Imode             = $62       ; input mode flag, $00=INPUT, $80=READ
000000r 2               
000000r 2               Cflag             = $63       ; comparison evaluation flag
000000r 2               
000000r 2               TabSiz            = $64       ; TAB step size (was input flag)
000000r 2               
000000r 2               next_s            = $65       ; next descriptor stack address
000000r 2               
000000r 2                                             ; these two bytes form a word pointer to the item
000000r 2                                             ; currently on top of the descriptor stack
000000r 2               last_sl           = $66       ; last descriptor stack address low byte
000000r 2               last_sh           = $67       ; last descriptor stack address high byte (always $00)
000000r 2               
000000r 2               des_sk            = $68       ; descriptor stack start address (temp strings)
000000r 2               
000000r 2               ;                 = $70       ; End of descriptor stack
000000r 2               
000000r 2               ut1_pl            = $71       ; utility pointer 1 low byte
000000r 2               ut1_ph            = ut1_pl+1  ; utility pointer 1 high byte
000000r 2               ut2_pl            = $73       ; utility pointer 2 low byte
000000r 2               ut2_ph            = ut2_pl+1  ; utility pointer 2 high byte
000000r 2               
000000r 2               Temp_2            = ut1_pl    ; temp byte for block move
000000r 2               
000000r 2               FACt_1            = $75       ; FAC temp mantissa1
000000r 2               FACt_2            = FACt_1+1  ; FAC temp mantissa2
000000r 2               FACt_3            = FACt_2+1  ; FAC temp mantissa3
000000r 2               
000000r 2               dims_l            = FACt_2    ; array dimension size low byte
000000r 2               dims_h            = FACt_3    ; array dimension size high byte
000000r 2               
000000r 2               TempB             = $78       ; temp page 0 byte
000000r 2               
000000r 2               Smeml             = $79       ; start of mem low byte       (Start-of-Basic)
000000r 2               Smemh             = Smeml+1   ; start of mem high byte      (Start-of-Basic)
000000r 2               Svarl             = $7B       ; start of vars low byte      (Start-of-Variables)
000000r 2               Svarh             = Svarl+1   ; start of vars high byte     (Start-of-Variables)
000000r 2               Sarryl            = $7D       ; var mem end low byte        (Start-of-Arrays)
000000r 2               Sarryh            = Sarryl+1  ; var mem end high byte       (Start-of-Arrays)
000000r 2               Earryl            = $7F       ; array mem end low byte      (End-of-Arrays)
000000r 2               Earryh            = Earryl+1  ; array mem end high byte     (End-of-Arrays)
000000r 2               Sstorl            = $81       ; string storage low byte     (String storage (moving down))
000000r 2               Sstorh            = Sstorl+1  ; string storage high byte    (String storage (moving down))
000000r 2               Sutill            = $83       ; string utility ptr low byte
000000r 2               Sutilh            = Sutill+1  ; string utility ptr high byte
000000r 2               Ememl             = $85       ; end of mem low byte         (Limit-of-memory)
000000r 2               Ememh             = Ememl+1   ; end of mem high byte        (Limit-of-memory)
000000r 2               Clinel            = $87       ; current line low byte       (Basic line number)
000000r 2               Clineh            = Clinel+1  ; current line high byte      (Basic line number)
000000r 2               Blinel            = $89       ; break line low byte         (Previous Basic line number)
000000r 2               Blineh            = Blinel+1  ; break line high byte        (Previous Basic line number)
000000r 2               
000000r 2               Cpntrl            = $8B       ; continue pointer low byte
000000r 2               Cpntrh            = Cpntrl+1  ; continue pointer high byte
000000r 2               
000000r 2               Dlinel            = $8D       ; current DATA line low byte
000000r 2               Dlineh            = Dlinel+1  ; current DATA line high byte
000000r 2               
000000r 2               Dptrl             = $8F       ; DATA pointer low byte
000000r 2               Dptrh             = Dptrl+1   ; DATA pointer high byte
000000r 2               
000000r 2               Rdptrl            = $91       ; read pointer low byte
000000r 2               Rdptrh            = Rdptrl+1  ; read pointer high byte
000000r 2               
000000r 2               Varnm1            = $93       ; current var name 1st byte
000000r 2               Varnm2            = Varnm1+1  ; current var name 2nd byte
000000r 2               
000000r 2               Cvaral            = $95       ; current var address low byte
000000r 2               Cvarah            = Cvaral+1  ; current var address high byte
000000r 2               
000000r 2               Frnxtl            = $97       ; var pointer for FOR/NEXT low byte
000000r 2               Frnxth            = Frnxtl+1  ; var pointer for FOR/NEXT high byte
000000r 2               
000000r 2               Tidx1             = Frnxtl    ; temp line index
000000r 2               
000000r 2               Lvarpl            = Frnxtl    ; let var pointer low byte
000000r 2               Lvarph            = Frnxth    ; let var pointer high byte
000000r 2               
000000r 2               prstk             = $99       ; precedence stacked flag
000000r 2               
000000r 2               comp_f            = $9B       ; compare function flag, bits 0,1 and 2 used
000000r 2                                             ; bit 2 set if >
000000r 2                                             ; bit 1 set if =
000000r 2                                             ; bit 0 set if <
000000r 2               
000000r 2               func_l            = $9C       ; function pointer low byte
000000r 2               func_h            = func_l+1  ; function pointer high byte
000000r 2               
000000r 2               garb_l            = func_l    ; garbage collection working pointer low byte
000000r 2               garb_h            = func_h    ; garbage collection working pointer high byte
000000r 2               
000000r 2               des_2l            = $9E       ; string descriptor_2 pointer low byte
000000r 2               des_2h            = des_2l+1  ; string descriptor_2 pointer high byte
000000r 2               
000000r 2               g_step            = $A0       ; garbage collect step size
000000r 2               
000000r 2               Fnxjmp            = $A1       ; jump vector for functions
000000r 2               Fnxjpl            = Fnxjmp+1  ; functions jump vector low byte
000000r 2               Fnxjph            = Fnxjmp+2  ; functions jump vector high byte
000000r 2               
000000r 2               g_indx            = Fnxjpl    ; garbage collect temp index
000000r 2               
000000r 2               FAC2_r            = $A3       ; FAC2 rounding byte
000000r 2               
000000r 2               Adatal            = $A4       ; array data pointer low byte
000000r 2               Adatah            = Adatal+1  ; array data pointer high  byte
000000r 2               
000000r 2               Nbendl            = Adatal    ; new block end pointer low byte
000000r 2               Nbendh            = Adatah    ; new block end pointer high  byte
000000r 2               
000000r 2               Obendl            = $A6       ; old block end pointer low byte
000000r 2               Obendh            = Obendl+1  ; old block end pointer high  byte
000000r 2               
000000r 2               numexp            = $A8       ; string to float number exponent count
000000r 2               expcnt            = $A9       ; string to float exponent count
000000r 2               
000000r 2               numbit            = numexp    ; bit count for array element calculations
000000r 2               
000000r 2               numdpf            = $AA       ; string to float decimal point flag
000000r 2               expneg            = $AB       ; string to float eval exponent -ve flag
000000r 2               
000000r 2               Astrtl            = numdpf    ; array start pointer low byte
000000r 2               Astrth            = expneg    ; array start pointer high  byte
000000r 2               
000000r 2               Histrl            = numdpf    ; highest string low byte
000000r 2               Histrh            = expneg    ; highest string high  byte
000000r 2               
000000r 2               Baslnl            = numdpf    ; BASIC search line pointer low byte
000000r 2               Baslnh            = expneg    ; BASIC search line pointer high  byte
000000r 2               
000000r 2               Fvar_l            = numdpf    ; find/found variable pointer low byte
000000r 2               Fvar_h            = expneg    ; find/found variable pointer high  byte
000000r 2               
000000r 2               Ostrtl            = numdpf    ; old block start pointer low byte
000000r 2               Ostrth            = expneg    ; old block start pointer high  byte
000000r 2               
000000r 2               Vrschl            = numdpf    ; variable search pointer low byte
000000r 2               Vrschh            = expneg    ; variable search pointer high  byte
000000r 2               
000000r 2               FAC1_e            = $AC       ; FAC1 exponent
000000r 2               FAC1_1            = FAC1_e+1  ; FAC1 mantissa1
000000r 2               FAC1_2            = FAC1_e+2  ; FAC1 mantissa2
000000r 2               FAC1_3            = FAC1_e+3  ; FAC1 mantissa3
000000r 2               FAC1_s            = FAC1_e+4  ; FAC1 sign (b7)
000000r 2               
000000r 2               str_ln            = FAC1_e    ; string length
000000r 2               str_pl            = FAC1_1    ; string pointer low byte
000000r 2               str_ph            = FAC1_2    ; string pointer high byte
000000r 2               
000000r 2               des_pl            = FAC1_2    ; string descriptor pointer low byte
000000r 2               des_ph            = FAC1_3    ; string descriptor pointer high byte
000000r 2               
000000r 2               mids_l            = FAC1_3    ; MID$ string temp length byte
000000r 2               
000000r 2               negnum            = $B1       ; string to float eval -ve flag
000000r 2               numcon            = $B1       ; series evaluation constant count
000000r 2               
000000r 2               FAC1_o            = $B2       ; FAC1 overflow byte
000000r 2               
000000r 2               FAC2_e            = $B3       ; FAC2 exponent
000000r 2               FAC2_1            = FAC2_e+1  ; FAC2 mantissa1
000000r 2               FAC2_2            = FAC2_e+2  ; FAC2 mantissa2
000000r 2               FAC2_3            = FAC2_e+3  ; FAC2 mantissa3
000000r 2               FAC2_s            = FAC2_e+4  ; FAC2 sign (b7)
000000r 2               
000000r 2               FAC_sc            = $B8       ; FAC sign comparison, Acc#1 vs #2
000000r 2               FAC1_r            = $B9       ; FAC1 rounding byte
000000r 2               
000000r 2               ssptr_l           = FAC_sc    ; string start pointer low byte
000000r 2               ssptr_h           = FAC1_r    ; string start pointer high byte
000000r 2               
000000r 2               sdescr            = FAC_sc    ; string descriptor pointer
000000r 2               
000000r 2               csidx             = $BA       ; line crunch save index
000000r 2               Asptl             = csidx     ; array size/pointer low byte
000000r 2               Aspth             = $BB       ; array size/pointer high byte
000000r 2               
000000r 2               Btmpl             = Asptl     ; BASIC pointer temp low byte
000000r 2               Btmph             = Aspth     ; BASIC pointer temp low byte
000000r 2               
000000r 2               Cptrl             = Asptl     ; BASIC pointer temp low byte
000000r 2               Cptrh             = Aspth     ; BASIC pointer temp low byte
000000r 2               
000000r 2               Sendl             = Asptl     ; BASIC pointer temp low byte
000000r 2               Sendh             = Aspth     ; BASIC pointer temp low byte
000000r 2               
000000r 2               ; the following locations are bulk initialized from LAB_2CEE at LAB_2D4E
000000r 2               LAB_IGBY          = $BC       ; get next BASIC byte subroutine
000000r 2               
000000r 2               LAB_GBYT          = $C2       ; get current BASIC byte subroutine
000000r 2               Bpntrl            = $C3       ; BASIC execute (get byte) pointer low byte
000000r 2               Bpntrh            = Bpntrl+1  ; BASIC execute (get byte) pointer high byte
000000r 2               
000000r 2               ;                 = $D7       ; end of get BASIC char subroutine
000000r 2               ; end bulk initialize from LAB_2CEE at LAB_2D4E
000000r 2               
000000r 2               Rbyte4            = $D8       ; extra PRNG byte
000000r 2               Rbyte1            = Rbyte4+1  ; most significant PRNG byte
000000r 2               Rbyte2            = Rbyte4+2  ; middle PRNG byte
000000r 2               Rbyte3            = Rbyte4+3  ; least significant PRNG byte
000000r 2               
000000r 2               NmiBase           = $DC       ; NMI handler enabled/setup/triggered flags
000000r 2                                             ; bit function
000000r 2                                             ; === ========
000000r 2                                             ; 7   interrupt enabled
000000r 2                                             ; 6   interrupt setup
000000r 2                                             ; 5   interrupt happened
000000r 2               ;                 = $DD       ; NMI handler addr low byte
000000r 2               ;                 = $DE       ; NMI handler addr high byte
000000r 2               IrqBase           = $DF       ; IRQ handler enabled/setup/triggered flags
000000r 2               ;                 = $E0       ; IRQ handler addr low byte
000000r 2               ;                 = $E1       ; IRQ handler addr high byte
000000r 2               
000000r 2               ; *** removed unused comments for $DE-$E1
000000r 2               
000000r 2               ;                 = $E2       ; unused
000000r 2               ;                 = $E3       ; unused
000000r 2               ;                 = $E4       ; unused
000000r 2               ;                 = $E5       ; unused
000000r 2               ;                 = $E6       ; unused
000000r 2               ;                 = $E7       ; unused
000000r 2               ;                 = $E8       ; unused
000000r 2               ;                 = $E9       ; unused
000000r 2               ;                 = $EA       ; unused
000000r 2               ;                 = $EB       ; unused
000000r 2               ;                 = $EC       ; unused
000000r 2               ;                 = $ED       ; unused
000000r 2               ;                 = $EE       ; unused
000000r 2               
000000r 2               Decss             = $EF       ; number to decimal string start
000000r 2               Decssp1           = Decss+1   ; number to decimal string start
000000r 2               
000000r 2               ;                 = $FF       ; decimal string end
000000r 2               
000000r 2               ; token values needed for BASIC
000000r 2               
000000r 2               ; primary command tokens (can start a statement)
000000r 2               
000000r 2               TK_END            = $80             ; END token
000000r 2               TK_FOR            = TK_END+1        ; FOR token
000000r 2               TK_NEXT           = TK_FOR+1        ; NEXT token
000000r 2               TK_DATA           = TK_NEXT+1       ; DATA token
000000r 2               TK_INPUT          = TK_DATA+1       ; INPUT token
000000r 2               TK_DIM            = TK_INPUT+1      ; DIM token
000000r 2               TK_READ           = TK_DIM+1        ; READ token
000000r 2               TK_LET            = TK_READ+1       ; LET token
000000r 2               TK_DEC            = TK_LET+1        ; DEC token
000000r 2               TK_GOTO           = TK_DEC+1        ; GOTO token
000000r 2               TK_RUN            = TK_GOTO+1       ; RUN token
000000r 2               TK_IF             = TK_RUN+1        ; IF token
000000r 2               TK_RESTORE        = TK_IF+1         ; RESTORE token
000000r 2               TK_GOSUB          = TK_RESTORE+1    ; GOSUB token
000000r 2               TK_RETIRQ         = TK_GOSUB+1      ; RETIRQ token
000000r 2               TK_RETNMI         = TK_RETIRQ+1     ; RETNMI token
000000r 2               TK_RETURN         = TK_RETNMI+1     ; RETURN token
000000r 2               TK_REM            = TK_RETURN+1     ; REM token
000000r 2               TK_STOP           = TK_REM+1        ; STOP token
000000r 2               TK_ON             = TK_STOP+1       ; ON token
000000r 2               TK_NULL           = TK_ON+1         ; NULL token
000000r 2               TK_INC            = TK_NULL+1       ; INC token
000000r 2               TK_WAIT           = TK_INC+1        ; WAIT token
000000r 2               TK_LOAD           = TK_WAIT+1       ; LOAD token
000000r 2               TK_SAVE           = TK_LOAD+1       ; SAVE token
000000r 2               TK_DEF            = TK_SAVE+1       ; DEF token
000000r 2               TK_POKE           = TK_DEF+1        ; POKE token
000000r 2               TK_DOKE           = TK_POKE+1       ; DOKE token
000000r 2               TK_CALL           = TK_DOKE+1       ; CALL token
000000r 2               TK_DO             = TK_CALL+1       ; DO token
000000r 2               TK_LOOP           = TK_DO+1         ; LOOP token
000000r 2               TK_PRINT          = TK_LOOP+1       ; PRINT token
000000r 2               TK_CONT           = TK_PRINT+1      ; CONT token
000000r 2               TK_LIST           = TK_CONT+1       ; LIST token
000000r 2               TK_CLEAR          = TK_LIST+1       ; CLEAR token
000000r 2               TK_NEW            = TK_CLEAR+1      ; NEW token
000000r 2               TK_WIDTH          = TK_NEW+1        ; WIDTH token
000000r 2               TK_GET            = TK_WIDTH+1      ; GET token
000000r 2               TK_SWAP           = TK_GET+1        ; SWAP token
000000r 2               TK_BITSET         = TK_SWAP+1       ; BITSET token
000000r 2               TK_BITCLR         = TK_BITSET+1     ; BITCLR token
000000r 2               TK_IRQ            = TK_BITCLR+1     ; IRQ token
000000r 2               TK_NMI            = TK_IRQ+1        ; NMI token
000000r 2               
000000r 2               ; --- VGC Graphics Commands ---
000000r 2               TK_CLS            = TK_NMI+1        ; CLS
000000r 2               TK_COLOR          = TK_CLS+1        ; COLOR
000000r 2               TK_LOCATE         = TK_COLOR+1      ; LOCATE
000000r 2               TK_PLOT           = TK_LOCATE+1     ; PLOT
000000r 2               TK_UNPLOT         = TK_PLOT+1       ; UNPLOT
000000r 2               TK_LINE           = TK_UNPLOT+1     ; LINE
000000r 2               TK_CIRCLE         = TK_LINE+1       ; CIRCLE
000000r 2               TK_RECT           = TK_CIRCLE+1     ; RECT
000000r 2               TK_FILLRECT       = TK_RECT+1       ; FILL
000000r 2               TK_PAINT          = TK_FILLRECT+1   ; PAINT
000000r 2               TK_GMODE          = TK_PAINT+1      ; MODE
000000r 2               TK_GCLS           = TK_GMODE+1      ; GCLS
000000r 2               TK_GCOLOR         = TK_GCLS+1       ; GCOLOR
000000r 2               TK_SPRCMD         = TK_GCOLOR+1     ; SPRITE
000000r 2               TK_SPRSHAPE       = TK_SPRCMD+1     ; SPRITESHAPE
000000r 2               TK_SPRCOLOR       = TK_SPRSHAPE+1   ; SPRITESET
000000r 2               TK_SPRDATA        = TK_SPRCOLOR+1   ; SPRITEDATA
000000r 2               TK_SOUND          = TK_SPRDATA+1    ; SOUND
000000r 2               TK_VOLUME         = TK_SOUND+1      ; VOLUME
000000r 2               TK_ENVELOPE       = TK_VOLUME+1     ; ENVELOPE
000000r 2               TK_WAVE           = TK_ENVELOPE+1   ; WAVE
000000r 2               TK_VSYNC          = TK_WAVE+1       ; VSYNC
000000r 2               
000000r 2               ; secondary command tokens, can't start a statement
000000r 2               
000000r 2               TK_TAB            = TK_VSYNC+1      ; TAB token
000000r 2               TK_ELSE           = TK_TAB+1        ; ELSE token
000000r 2               TK_TO             = TK_ELSE+1       ; TO token
000000r 2               TK_FN             = TK_TO+1         ; FN token
000000r 2               TK_SPC            = TK_FN+1         ; SPC token
000000r 2               TK_THEN           = TK_SPC+1        ; THEN token
000000r 2               TK_NOT            = TK_THEN+1       ; NOT token
000000r 2               TK_STEP           = TK_NOT+1        ; STEP token
000000r 2               TK_UNTIL          = TK_STEP+1       ; UNTIL token
000000r 2               TK_WHILE          = TK_UNTIL+1      ; WHILE token
000000r 2               TK_OFF            = TK_WHILE+1      ; OFF token
000000r 2               
000000r 2               ; opperator tokens
000000r 2               
000000r 2               TK_PLUS           = TK_OFF+1        ; + token
000000r 2               TK_MINUS          = TK_PLUS+1       ; - token
000000r 2               TK_MUL            = TK_MINUS+1      ; * token
000000r 2               TK_DIV            = TK_MUL+1        ; / token
000000r 2               TK_POWER          = TK_DIV+1        ; ^ token
000000r 2               TK_AND            = TK_POWER+1      ; AND token
000000r 2               TK_EOR            = TK_AND+1        ; EOR token
000000r 2               TK_OR             = TK_EOR+1        ; OR token
000000r 2               TK_RSHIFT         = TK_OR+1         ; RSHIFT token
000000r 2               TK_LSHIFT         = TK_RSHIFT+1     ; LSHIFT token
000000r 2               TK_GT             = TK_LSHIFT+1     ; > token
000000r 2               TK_EQUAL          = TK_GT+1         ; = token
000000r 2               TK_LT             = TK_EQUAL+1      ; < token
000000r 2               
000000r 2               ; functions tokens
000000r 2               
000000r 2               TK_SGN            = TK_LT+1         ; SGN token
000000r 2               TK_INT            = TK_SGN+1        ; INT token
000000r 2               TK_ABS            = TK_INT+1        ; ABS token
000000r 2               TK_USR            = TK_ABS+1        ; USR token
000000r 2               TK_FRE            = TK_USR+1        ; FRE token
000000r 2               TK_POS            = TK_FRE+1        ; POS token
000000r 2               TK_SQR            = TK_POS+1        ; SQR token
000000r 2               TK_RND            = TK_SQR+1        ; RND token
000000r 2               TK_LOG            = TK_RND+1        ; LOG token
000000r 2               TK_EXP            = TK_LOG+1        ; EXP token
000000r 2               TK_COS            = TK_EXP+1        ; COS token
000000r 2               TK_SIN            = TK_COS+1        ; SIN token
000000r 2               TK_TAN            = TK_SIN+1        ; TAN token
000000r 2               TK_ATN            = TK_TAN+1        ; ATN token
000000r 2               TK_PEEK           = TK_ATN+1        ; PEEK token
000000r 2               TK_DEEK           = TK_PEEK+1       ; DEEK token
000000r 2               TK_SADD           = TK_DEEK+1       ; SADD token
000000r 2               TK_LEN            = TK_SADD+1       ; LEN token
000000r 2               TK_STRS           = TK_LEN+1        ; STR$ token
000000r 2               TK_VAL            = TK_STRS+1       ; VAL token
000000r 2               TK_ASC            = TK_VAL+1        ; ASC token
000000r 2               TK_UCASES         = TK_ASC+1        ; UCASE$ token
000000r 2               TK_LCASES         = TK_UCASES+1     ; LCASE$ token
000000r 2               TK_CHRS           = TK_LCASES+1     ; CHR$ token
000000r 2               TK_HEXS           = TK_CHRS+1       ; HEX$ token
000000r 2               TK_BINS           = TK_HEXS+1       ; BIN$ token
000000r 2               TK_BITTST         = TK_BINS+1       ; BITTST token
000000r 2               TK_MAX            = TK_BITTST+1     ; MAX token
000000r 2               TK_MIN            = TK_MAX+1        ; MIN token
000000r 2               TK_PI             = TK_MIN+1        ; PI token
000000r 2               TK_TWOPI          = TK_PI+1         ; TWOPI token
000000r 2               TK_VPTR           = TK_TWOPI+1      ; VARPTR token
000000r 2               TK_LEFTS          = TK_VPTR+1       ; LEFT$ token
000000r 2               TK_RIGHTS         = TK_LEFTS+1      ; RIGHT$ token
000000r 2               TK_MIDS           = TK_RIGHTS+1     ; MID$ token
000000r 2               
000000r 2               ; --- VGC Function Tokens ---
000000r 2               TK_SPRITEX        = TK_MIDS+1       ; SPRITEX(
000000r 2               TK_SPRITEY        = TK_SPRITEX+1    ; SPRITEY(
000000r 2               TK_COLLISION      = TK_SPRITEY+1    ; COLLISION(
000000r 2               TK_BUMPED         = TK_COLLISION+1   ; BUMPED(
000000r 2               
000000r 2               ; --- Extended 2-byte tokens ---
000000r 2               ; First byte is a prefix marker in tokenized BASIC text, second byte is ext id.
000000r 2               
000000r 2               TKX_PREFIX        = $01              ; extended token prefix byte
000000r 2               XTK_DIR           = $01              ; extended token id: DIR
000000r 2               XTK_DEL           = $02              ; extended token id: DEL
000000r 2               XTK_XMEM          = $03              ; extended token id: XMEM
000000r 2               XTK_XBANK         = $04              ; extended token id: XBANK
000000r 2               XTK_XPOKE         = $05              ; extended token id: XPOKE
000000r 2               XTK_XPEEK         = $06              ; extended token id: XPEEK(
000000r 2               XTK_STASH         = $07              ; extended token id: STASH
000000r 2               XTK_FETCH         = $08              ; extended token id: FETCH
000000r 2               XTK_XFREE         = $09              ; extended token id: XFREE
000000r 2               XTK_XRESET        = $0A              ; extended token id: XRESET
000000r 2               XTK_XALLOC        = $0B              ; extended token id: XALLOC
000000r 2               XTK_XDIR          = $0C              ; extended token id: XDIR
000000r 2               XTK_XDEL          = $0D              ; extended token id: XDEL
000000r 2               XTK_XMAP          = $0E              ; extended token id: XMAP
000000r 2               XTK_XUNMAP        = $0F              ; extended token id: XUNMAP
000000r 2               XTK_GSAVE         = $10              ; extended token id: GSAVE
000000r 2               XTK_GLOAD         = $11              ; extended token id: GLOAD
000000r 2               XTK_SIDPLAY       = $12              ; extended token id: SIDPLAY
000000r 2               XTK_SIDSTOP       = $13              ; extended token id: SIDSTOP
000000r 2               XTK_MUSIC         = $14              ; extended token id: MUSIC
000000r 2               XTK_PLAYING       = $15              ; extended token id: PLAYING (function)
000000r 2               XTK_MNOTE         = $16              ; extended token id: MNOTE( (function)
000000r 2               XTK_COPPER        = $17              ; extended token id: COPPER
000000r 2               XTK_RESET         = $18              ; extended token id: RESET
000000r 2               XTK_NOPEN         = $19              ; NOPEN slot,"host",port
000000r 2               XTK_NCLOSE        = $1A              ; NCLOSE slot
000000r 2               XTK_NLISTEN       = $1B              ; NLISTEN slot,port
000000r 2               XTK_NACCEPT       = $1C              ; NACCEPT slot
000000r 2               XTK_NSEND         = $1D              ; NSEND slot,A$
000000r 2               XTK_NRECV         = $1E              ; NRECV$(slot) — string function
000000r 2               XTK_NSTATUS       = $1F              ; NSTATUS(slot) — numeric function
000000r 2                                                     ; $20 reserved — collides with ASCII space
000000r 2                                                     ; (LAB_IGBY skips $20 during scan)
000000r 2               XTK_NREADY        = $21              ; NREADY(slot) — numeric function
000000r 2               XTK_NLEN          = $22              ; NLEN — numeric function (no args)
000000r 2               XTK_DMACOPY       = $23              ; DMACOPY srcSpace,srcAddr,dstSpace,dstAddr,len
000000r 2               XTK_DMAFILL       = $24              ; DMAFILL dstSpace,dstAddr,len,value
000000r 2               XTK_DMASTATUS     = $25              ; DMASTATUS — numeric function (no args)
000000r 2                                                     ; $26 reserved — maps to AND token in scanner
000000r 2               XTK_DMAERR        = $27              ; DMAERR — numeric function (no args)
000000r 2               XTK_DMACOUNT      = $28              ; DMACOUNT — numeric function (no args)
000000r 2                                                     ; $29-$3F reserved
000000r 2               XTK_BLITCOPY      = $40              ; BLITCOPY srcSpace,srcAddr,srcStride,dstSpace,dstAddr,dstStride,width,height
000000r 2               XTK_BLITFILL      = $41              ; BLITFILL dstSpace,dstAddr,dstStride,width,height,value
000000r 2               XTK_BLITSTATUS    = $42              ; BLITSTATUS — numeric function (no args)
000000r 2               XTK_BLITERR       = $43              ; BLITERR — numeric function (no args)
000000r 2               XTK_BLITCOUNT     = $44              ; BLITCOUNT — numeric function (no args)
000000r 2               XTK_BITTGL        = $45              ; BITTGL addr,mask — toggle bits
000000r 2               XTK_HELP           = $46              ; HELP [keyword] — open help panel
000000r 2               
000000r 2               ; offsets from a base of X or Y
000000r 2               
000000r 2               PLUS_0            = $00       ; X or Y plus 0
000000r 2               PLUS_1            = $01       ; X or Y plus 1
000000r 2               PLUS_2            = $02       ; X or Y plus 2
000000r 2               PLUS_3            = $03       ; X or Y plus 3
000000r 2               
000000r 2               LAB_STAK          = $0100     ; stack bottom, no offset
000000r 2               
000000r 2               LAB_SKFE          = LAB_STAK+$FE
000000r 2                                             ; flushed stack address
000000r 2               LAB_SKFF          = LAB_STAK+$FF
000000r 2                                             ; flushed stack address
000000r 2               
000000r 2               ; the following locations are bulk initialized from PG2_TABS at LAB_COLD
000000r 2               ccflag            = $0200     ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
000000r 2               ccbyte            = ccflag+1  ; BASIC CTRL-C byte
000000r 2               ccnull            = ccbyte+1  ; BASIC CTRL-C byte timeout
000000r 2               
000000r 2               VEC_CC            = ccnull+1  ; ctrl c check vector
000000r 2               ; end bulk initialize from PG2_TABS at LAB_COLD
000000r 2               
000000r 2               ; the following locations are bulk initialized by min_mon.asm from LAB_vec at LAB_stlp
000000r 2               VEC_IN            = VEC_CC+2  ; input vector
000000r 2               VEC_OUT           = VEC_IN+2  ; output vector
000000r 2               VEC_LD            = VEC_OUT+2 ; load vector
000000r 2               VEC_SV            = VEC_LD+2  ; save vector
000000r 2               ; end bulk initialize by min_mon.asm from LAB_vec at LAB_stlp
000000r 2               
000000r 2               ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
000000r 2               ; the input buffer must not cross a page boundary and must not overlap with
000000r 2               ; program RAM pages!
000000r 2               
000000r 2               ;Ibuffs            = IRQ_vec+$14
000000r 2               Ibuffs            = VEC_SV+$16
000000r 2                                             ; start of input buffer after IRQ/NMI code
000000r 2               Ibuffe            = Ibuffs+$DE; end of input buffer (222 bytes, fills to $02FF)
000000r 2               
000000r 2               Ram_base          = $0300     ; start of user RAM (set as needed, should be page aligned)
000000r 2               Ram_top           = $A000     ; end of contiguous BASIC RAM+1 (before MMIO window)
000000r 2               
000000r 2               Stack_floor       = 16        ; bytes left free on stack for background interrupts
000000r 2               
000000r 2               ; This start can be changed to suit your system
000000r 2               
000000r 2                     .segment "CODE"
000000r 2                     .org    $C000
00C000  2               
00C000  2               ; BASIC cold start entry point
00C000  2               
00C000  2               ; new page 2 initialisation, copy block to ccflag on
00C000  2               
00C000  2               LAB_COLD
00C000  2  A0 04              LDY   #PG2_TABE-PG2_TABS-1
00C002  2                                             ; byte count-1
00C002  2               LAB_2D13
00C002  2  B9 BF E6           LDA   PG2_TABS,Y        ; get byte
00C005  2  99 00 02           STA   ccflag,Y          ; store in page 2
00C008  2  88                 DEY                     ; decrement count
00C009  2  10 F7              BPL   LAB_2D13          ; loop if not done
00C00B  2               
00C00B  2  A2 FF              LDX   #$FF              ; set byte
00C00D  2  86 88              STX   Clineh            ; set current line high byte (set immediate mode)
00C00F  2  9A                 TXS                     ; reset stack pointer
00C010  2               
00C010  2  A9 4C              LDA   #$4C              ; code for JMP
00C012  2  85 A1              STA   Fnxjmp            ; save for jump vector for functions
00C014  2               
00C014  2               ; copy block from LAB_2CEE to $00BC - $00D7
00C014  2               
00C014  2  A2 1C              LDX   #StrTab-LAB_2CEE  ; set byte count
00C016  2               LAB_2D4E
00C016  2  BD 75 F6           LDA   LAB_2CEE-1,X      ; get byte from table
00C019  2  95 BB              STA   LAB_IGBY-1,X      ; save byte in page zero
00C01B  2  CA                 DEX                     ; decrement count
00C01C  2  D0 F8              BNE   LAB_2D4E          ; loop if not all done
00C01E  2               
00C01E  2               ; copy block from StrTab to $0000 - $0012
00C01E  2               
00C01E  2               LAB_GMEM
00C01E  2  A2 12              LDX   #EndTab-StrTab-1  ; set byte count-1
00C020  2               TabLoop
00C020  2  BD 92 F6           LDA   StrTab,X          ; get byte from table
00C023  2  95 00              STA   PLUS_0,X          ; save byte in page zero
00C025  2  CA                 DEX                     ; decrement count
00C026  2  10 F8              BPL   TabLoop           ; loop if not all done
00C028  2               
00C028  2               ; set-up start values
00C028  2               
00C028  2  A9 00              LDA   #$00              ; clear A
00C02A  2  85 DC              STA   NmiBase           ; clear NMI handler enabled flag
00C02C  2  85 DF              STA   IrqBase           ; clear IRQ handler enabled flag
00C02E  2  85 B2              STA   FAC1_o            ; clear FAC1 overflow byte
00C030  2  85 67              STA   last_sh           ; clear descriptor stack top item pointer high byte
00C032  2               
00C032  2  A9 0E              LDA   #$0E              ; set default tab size
00C034  2  85 64              STA   TabSiz            ; save it
00C036  2  A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
00C038  2  85 A0              STA   g_step            ; save it
00C03A  2  A2 68              LDX   #des_sk           ; descriptor stack start
00C03C  2  86 65              STX   next_s            ; set descriptor stack pointer
00C03E  2  20 E9 C9           JSR   LAB_CRLF          ; print CR/LF
00C041  2  A0 00              LDY   #$00              ; clear Y for indirect indexed writes
00C043  2  A9 00              LDA   #<Ram_base        ; always start from configured RAM base
00C045  2  85 11              STA   Itempl
00C047  2  A9 03              LDA   #>Ram_base
00C049  2  85 12              STA   Itemph
00C04B  2                                             ; detect RAM limit by probing for writeable memory
00C04B  2               LAB_2D93
00C04B  2  E6 11              INC   Itempl            ; increment temporary integer low byte
00C04D  2  D0 08              BNE   LAB_2D99          ; branch if no overflow
00C04F  2               
00C04F  2  E6 12              INC   Itemph            ; increment temporary integer high byte
00C051  2  A5 12              LDA   Itemph            ; get high byte
00C053  2  C9 A0              CMP   #>Ram_top         ; compare with top of RAM+1
00C055  2  F0 11              BEQ   LAB_2DB6          ; branch if match (end of user RAM)
00C057  2               
00C057  2               LAB_2D99
00C057  2  A9 55              LDA   #$55              ; set test byte
00C059  2  91 11              STA   (Itempl),Y        ; save via temporary integer
00C05B  2  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00C05D  2  D0 09              BNE   LAB_2DB6          ; branch if fail
00C05F  2               
00C05F  2  0A                 ASL                     ; shift test byte left (now $AA)
00C060  2  91 11              STA   (Itempl),Y        ; save via temporary integer
00C062  2  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00C064  2  F0 E5              BEQ   LAB_2D93          ; if ok go do next byte
00C066  2               
00C066  2  D0 00              BNE   LAB_2DB6          ; branch if fail
00C068  2               
00C068  2               LAB_2DB6
00C068  2  A5 11              LDA   Itempl            ; get temporary integer low byte
00C06A  2  A4 12              LDY   Itemph            ; get temporary integer high byte
00C06C  2               ; uncomment these lines if you want to check on the high limit of memory.
00C06C  2               ; default is to trust the configured probe range.
00C06C  2               
00C06C  2               ;     CPY   #>Ram_top         ; compare with top of RAM high byte
00C06C  2               ;     BCC   MEM_OK            ; branch if < RAM top
00C06C  2               
00C06C  2               ;     BNE   LAB_GMEM          ; if too large go try again
00C06C  2                                             ; else was = so compare low bytes
00C06C  2               ;     CMP   #<Ram_top         ; compare with top of RAM low byte
00C06C  2               ;     BEQ   MEM_OK            ; branch if = RAM top
00C06C  2               
00C06C  2               ;     BCS   LAB_GMEM          ; if too large go try again
00C06C  2               
00C06C  2               ;MEM_OK
00C06C  2  85 85              STA   Ememl             ; set end of mem low byte
00C06E  2  84 86              STY   Ememh             ; set end of mem high byte
00C070  2  85 81              STA   Sstorl            ; set bottom of string space low byte
00C072  2  84 82              STY   Sstorh            ; set bottom of string space high byte
00C074  2               
00C074  2  A0 00              LDY   #<Ram_base        ; set start addr low byte
00C076  2  A2 03              LDX   #>Ram_base        ; set start addr high byte
00C078  2  84 79              STY   Smeml             ; save start of mem low byte
00C07A  2  86 7A              STX   Smemh             ; save start of mem high byte
00C07C  2               
00C07C  2               ; this line is only needed if Ram_base is not $xx00
00C07C  2                     .IF   Ram_base&$FF>0
00C07C  2                     LDY   #$00              ; clear Y
00C07C  2                     .ENDIF
00C07C  2               
00C07C  2  98                 TYA                     ; clear A
00C07D  2  91 79              STA   (Smeml),Y         ; clear first byte
00C07F  2  E6 79              INC   Smeml             ; increment start of mem low byte
00C081  2               
00C081  2               ; these two lines are only needed if Ram_base is $xxFF
00C081  2                     .IF   Ram_base&$FF=$FF
00C081  2                     BNE   LAB_2E05          ; branch if no rollover
00C081  2                     INC   Smemh             ; increment start of mem high byte
00C081  2               LAB_2E05
00C081  2                     .ENDIF
00C081  2               
00C081  2  20 B6 C3           JSR   LAB_1463          ; do "NEW" and "CLEAR"
00C084  2  20 C4 E6           JSR   LAB_SPLASH        ; draw centered text startup splash
00C087  2  A5 85              LDA   Ememl             ; get end of mem low byte
00C089  2  38                 SEC                     ; set carry for subtract
00C08A  2  E5 79              SBC   Smeml             ; subtract start of mem low byte
00C08C  2  AA                 TAX                     ; copy to X
00C08D  2  A5 86              LDA   Ememh             ; get end of mem high byte
00C08F  2  E5 7A              SBC   Smemh             ; subtract start of mem high byte
00C091  2  20 8C DD           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
00C094  2  A9 A5              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
00C096  2  A0 F6              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
00C098  2  20 2A CA           JSR   LAB_18C3          ; print " BASIC bytes free  "
00C09B  2               
00C09B  2                     ; -- print expansion memory size if XMC present --
00C09B  2  AD 0D BA           LDA   XMC_BANKS         ; read bank count register
00C09E  2  F0 19              BEQ   @no_xmc           ; skip if no expansion memory
00C0A0  2               
00C0A0  2                     ; banks * 64 = KB — shift left 6 bits to get A(hi):X(lo)
00C0A0  2  AA                 TAX                     ; save bank count in X
00C0A1  2  4A                 LSR   A
00C0A2  2  4A                 LSR   A                 ; A = banks >> 2 = high byte of KB
00C0A3  2  48                 PHA                     ; save high byte on stack
00C0A4  2  8A                 TXA                     ; A = bank count again
00C0A5  2  29 03              AND   #$03              ; keep only low 2 bits
00C0A7  2  0A                 ASL   A
00C0A8  2  0A                 ASL   A
00C0A9  2  0A                 ASL   A
00C0AA  2  0A                 ASL   A
00C0AB  2  0A                 ASL   A
00C0AC  2  0A                 ASL   A                 ; (low 2 bits) << 6 = low byte of KB
00C0AD  2  AA                 TAX                     ; X = low byte of KB
00C0AE  2  68                 PLA                     ; A = high byte of KB
00C0AF  2  20 8C DD           JSR   LAB_295E          ; print KB as unsigned integer
00C0B2  2  A9 B9              LDA   #<LAB_XMSG
00C0B4  2  A0 F6              LDY   #>LAB_XMSG
00C0B6  2  20 2A CA           JSR   LAB_18C3          ; print "K expansion memory"
00C0B9  2               @no_xmc
00C0B9  2  A9 CC              LDA   #<LAB_NLNL
00C0BB  2  A0 F6              LDY   #>LAB_NLNL
00C0BD  2  20 2A CA           JSR   LAB_18C3          ; print CR/LF CR/LF
00C0C0  2               
00C0C0  2  A9 67              LDA   #<LAB_1274        ; warm start vector low byte
00C0C2  2  A0 C1              LDY   #>LAB_1274        ; warm start vector high byte
00C0C4  2  85 01              STA   Wrmjpl            ; save warm start vector low byte
00C0C6  2  84 02              STY   Wrmjph            ; save warm start vector high byte
00C0C8  2  6C 01 00           JMP   (Wrmjpl)          ; go do warm start
00C0CB  2               
00C0CB  2               ; open up space in memory
00C0CB  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00C0CB  2               
00C0CB  2               ; Nbendl,Nbendh - new block end address (A/Y)
00C0CB  2               ; Obendl,Obendh - old block end address
00C0CB  2               ; Ostrtl,Ostrth - old block start address
00C0CB  2               
00C0CB  2               ; returns with ..
00C0CB  2               
00C0CB  2               ; Nbendl,Nbendh - new block start address (high byte - $100)
00C0CB  2               ; Obendl,Obendh - old block start address (high byte - $100)
00C0CB  2               ; Ostrtl,Ostrth - old block start address (unchanged)
00C0CB  2               
00C0CB  2               LAB_11CF
00C0CB  2  20 18 C1           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
00C0CE  2                                             ; addr to check is in AY (low/high)
00C0CE  2  85 7F              STA   Earryl            ; save new array mem end low byte
00C0D0  2  84 80              STY   Earryh            ; save new array mem end high byte
00C0D2  2               
00C0D2  2               ; open up space in memory
00C0D2  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00C0D2  2               ; don't set array end
00C0D2  2               
00C0D2  2               LAB_11D6
00C0D2  2  38                 SEC                     ; set carry for subtract
00C0D3  2  A5 A6              LDA   Obendl            ; get block end low byte
00C0D5  2  E5 AA              SBC   Ostrtl            ; subtract block start low byte
00C0D7  2  A8                 TAY                     ; copy MOD(block length/$100) byte to Y
00C0D8  2  A5 A7              LDA   Obendh            ; get block end high byte
00C0DA  2  E5 AB              SBC   Ostrth            ; subtract block start high byte
00C0DC  2  AA                 TAX                     ; copy block length high byte to X
00C0DD  2  E8                 INX                     ; +1 to allow for count=0 exit
00C0DE  2  98                 TYA                     ; copy block length low byte to A
00C0DF  2  F0 24              BEQ   LAB_120A          ; branch if length low byte=0
00C0E1  2               
00C0E1  2                                             ; block is (X-1)*256+Y bytes, do the Y bytes first
00C0E1  2               
00C0E1  2  38                 SEC                     ; set carry for add + 1, two's complement
00C0E2  2  49 FF              EOR   #$FF              ; invert low byte for subtract
00C0E4  2  65 A6              ADC   Obendl            ; add block end low byte
00C0E6  2               
00C0E6  2  85 A6              STA   Obendl            ; save corrected old block end low byte
00C0E8  2  B0 03              BCS   LAB_11F3          ; branch if no underflow
00C0EA  2               
00C0EA  2  C6 A7              DEC   Obendh            ; else decrement block end high byte
00C0EC  2  38                 SEC                     ; set carry for add + 1, two's complement
00C0ED  2               LAB_11F3
00C0ED  2  98                 TYA                     ; get MOD(block length/$100) byte
00C0EE  2  49 FF              EOR   #$FF              ; invert low byte for subtract
00C0F0  2  65 A4              ADC   Nbendl            ; add destination end low byte
00C0F2  2  85 A4              STA   Nbendl            ; save modified new block end low byte
00C0F4  2  B0 08              BCS   LAB_1203          ; branch if no underflow
00C0F6  2               
00C0F6  2  C6 A5              DEC   Nbendh            ; else decrement block end high byte
00C0F8  2  90 04              BCC   LAB_1203          ; branch always
00C0FA  2               
00C0FA  2               LAB_11FF
00C0FA  2  B1 A6              LDA   (Obendl),Y        ; get byte from source
00C0FC  2  91 A4              STA   (Nbendl),Y        ; copy byte to destination
00C0FE  2               LAB_1203
00C0FE  2  88                 DEY                     ; decrement index
00C0FF  2  D0 F9              BNE   LAB_11FF          ; loop until Y=0
00C101  2               
00C101  2                                             ; now do Y=0 indexed byte
00C101  2  B1 A6              LDA   (Obendl),Y        ; get byte from source
00C103  2  91 A4              STA   (Nbendl),Y        ; save byte to destination
00C105  2               LAB_120A
00C105  2  C6 A7              DEC   Obendh            ; decrement source pointer high byte
00C107  2  C6 A5              DEC   Nbendh            ; decrement destination pointer high byte
00C109  2  CA                 DEX                     ; decrement block count
00C10A  2  D0 F2              BNE   LAB_1203          ; loop until count = $0
00C10C  2               
00C10C  2  60                 RTS
00C10D  2               
00C10D  2               ; check room on stack for A bytes
00C10D  2               ; stack too deep? do OM error
00C10D  2               
00C10D  2               LAB_1212
00C10D  2               ; *** patch - additional stack floor protection for background interrupts
00C10D  2               ; *** add
00C10D  2                     .IF   Stack_floor
00C10D  2  18                 CLC                     ; prep ADC
00C10E  2  69 10              ADC   #Stack_floor      ; stack pointer lower limit before interrupts
00C110  2                     .ENDIF
00C110  2               ; *** end patch
00C110  2  85 78              STA   TempB             ; save result in temp byte
00C112  2  BA                 TSX                     ; copy stack
00C113  2  E4 78              CPX   TempB             ; compare new "limit" with stack
00C115  2  90 30              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
00C117  2               
00C117  2  60                 RTS
00C118  2               
00C118  2               ; check available memory, "Out of memory" error if no room
00C118  2               ; addr to check is in AY (low/high)
00C118  2               
00C118  2               LAB_121F
00C118  2  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00C11A  2  90 2A              BCC   LAB_124B          ; if less then exit (is ok)
00C11C  2               
00C11C  2  D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
00C11E  2               
00C11E  2                                             ; high byte was =, now do low byte
00C11E  2  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00C120  2  90 24              BCC   LAB_124B          ; if less then exit (is ok)
00C122  2               
00C122  2                                             ; addr is > string storage ptr (oops!)
00C122  2               LAB_1229
00C122  2  48                 PHA                     ; push addr low byte
00C123  2  A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
00C125  2  98                 TYA                     ; copy addr high byte (to push on stack)
00C126  2               
00C126  2                                             ; save misc numeric work area
00C126  2               LAB_122D
00C126  2  48                 PHA                     ; push byte
00C127  2  B5 A3              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
00C129  2  CA                 DEX                     ; decrement index
00C12A  2  10 FA              BPL   LAB_122D          ; loop until all done
00C12C  2               
00C12C  2  20 CC D4           JSR   LAB_GARB          ; garbage collection routine
00C12F  2               
00C12F  2                                             ; restore misc numeric work area
00C12F  2  A2 00              LDX   #$00              ; clear the index to restore bytes
00C131  2               LAB_1238
00C131  2  68                 PLA                     ; pop byte
00C132  2  95 A4              STA   Adatal,X          ; save byte to Adatal to expneg
00C134  2  E8                 INX                     ; increment index
00C135  2  E0 08              CPX   #$08              ; compare with end + 1
00C137  2  30 F8              BMI   LAB_1238          ; loop if more to do
00C139  2               
00C139  2  68                 PLA                     ; pop addr high byte
00C13A  2  A8                 TAY                     ; copy back to Y
00C13B  2  68                 PLA                     ; pop addr low byte
00C13C  2  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00C13E  2  90 06              BCC   LAB_124B          ; if less then exit (is ok)
00C140  2               
00C140  2  D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
00C142  2               
00C142  2                                             ; high byte was =, now do low byte
00C142  2  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00C144  2  B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
00C146  2               
00C146  2                                             ; ok exit, carry clear
00C146  2               LAB_124B
00C146  2  60                 RTS
00C147  2               
00C147  2               ; do "Out of memory" error then warm start
00C147  2               
00C147  2               LAB_OMER
00C147  2  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
00C149  2               
00C149  2               ; do error #X, then warm start
00C149  2               
00C149  2               LAB_XERR
00C149  2  20 E9 C9           JSR   LAB_CRLF          ; print CR/LF
00C14C  2               
00C14C  2  BD 62 FD           LDA   LAB_BAER,X        ; get error message pointer low byte
00C14F  2  BC 63 FD           LDY   LAB_BAER+1,X      ; get error message pointer high byte
00C152  2  20 2A CA           JSR   LAB_18C3          ; print null terminated string from memory
00C155  2               
00C155  2  20 EF C3           JSR   LAB_1491          ; flush stack and clear continue flag
00C158  2  A9 9F              LDA   #<LAB_EMSG        ; point to " Error" low addr
00C15A  2  A0 FE              LDY   #>LAB_EMSG        ; point to " Error" high addr
00C15C  2               LAB_1269
00C15C  2  20 2A CA           JSR   LAB_18C3          ; print null terminated string from memory
00C15F  2  A4 88              LDY   Clineh            ; get current line high byte
00C161  2  C8                 INY                     ; increment it
00C162  2  F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
00C164  2               
00C164  2                                             ; else print line number
00C164  2  20 81 DD           JSR   LAB_2953          ; print " in line [LINE #]"
00C167  2               
00C167  2               ; BASIC warm start entry point
00C167  2               ; wait for Basic command
00C167  2               
00C167  2               LAB_1274
00C167  2                                             ; clear ON IRQ/NMI bytes
00C167  2  A9 00              LDA   #$00              ; clear A
00C169  2  85 DF              STA   IrqBase           ; clear enabled byte
00C16B  2  85 DC              STA   NmiBase           ; clear enabled byte
00C16D  2  A9 B0              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
00C16F  2  A0 FE              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
00C171  2               
00C171  2  20 2A CA           JSR   LAB_18C3          ; go do print string
00C174  2               
00C174  2               ; wait for Basic command (no "Ready")
00C174  2               
00C174  2               LAB_127D
00C174  2  20 5C C2           JSR   LAB_1357          ; call for BASIC input
00C177  2               LAB_1280
00C177  2  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00C179  2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00C17B  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C17E  2  F0 F4              BEQ   LAB_127D          ; loop while null
00C180  2               
00C180  2               ; got to interpret input line now ..
00C180  2               
00C180  2  A2 FF              LDX   #$FF              ; current line to null value
00C182  2  86 88              STX   Clineh            ; set current line high byte
00C184  2  90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
00C186  2               
00C186  2                                             ; no line number .. immediate mode
00C186  2  20 90 C2           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00C189  2  4C 98 C5           JMP   LAB_15F6          ; go scan and interpret code
00C18C  2               
00C18C  2               ; handle new BASIC line
00C18C  2               
00C18C  2               LAB_1295
00C18C  2  20 AC C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00C18F  2  20 90 C2           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00C192  2  84 5D              STY   Ibptr             ; save index pointer to end of crunched line
00C194  2  20 8A C3           JSR   LAB_SSLN          ; search BASIC for temp integer line number
00C197  2  90 44              BCC   LAB_12E6          ; branch if not found
00C199  2               
00C199  2                                             ; aroooogah! line # already exists! delete it
00C199  2  A0 01              LDY   #$01              ; set index to next line pointer high byte
00C19B  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00C19D  2  85 72              STA   ut1_ph            ; save it
00C19F  2  A5 7B              LDA   Svarl             ; get start of vars low byte
00C1A1  2  85 71              STA   ut1_pl            ; save it
00C1A3  2  A5 AB              LDA   Baslnh            ; get found line pointer high byte
00C1A5  2  85 74              STA   ut2_ph            ; save it
00C1A7  2  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00C1A9  2  88                 DEY                     ; decrement index
00C1AA  2  F1 AA              SBC   (Baslnl),Y        ; subtract next line pointer low byte
00C1AC  2  18                 CLC                     ; clear carry for add
00C1AD  2  65 7B              ADC   Svarl             ; add start of vars low byte
00C1AF  2  85 7B              STA   Svarl             ; save new start of vars low byte
00C1B1  2  85 73              STA   ut2_pl            ; save destination pointer low byte
00C1B3  2  A5 7C              LDA   Svarh             ; get start of vars high byte
00C1B5  2  69 FF              ADC   #$FF              ; -1 + carry
00C1B7  2  85 7C              STA   Svarh             ; save start of vars high byte
00C1B9  2  E5 AB              SBC   Baslnh            ; subtract found line pointer high byte
00C1BB  2  AA                 TAX                     ; copy to block count
00C1BC  2  38                 SEC                     ; set carry for subtract
00C1BD  2  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00C1BF  2  E5 7B              SBC   Svarl             ; subtract start of vars low byte
00C1C1  2  A8                 TAY                     ; copy to bytes in first block count
00C1C2  2  B0 03              BCS   LAB_12D0          ; branch if overflow
00C1C4  2               
00C1C4  2  E8                 INX                     ; increment block count (correct for =0 loop exit)
00C1C5  2  C6 74              DEC   ut2_ph            ; decrement destination high byte
00C1C7  2               LAB_12D0
00C1C7  2  18                 CLC                     ; clear carry for add
00C1C8  2  65 71              ADC   ut1_pl            ; add source pointer low byte
00C1CA  2  90 03              BCC   LAB_12D8          ; branch if no overflow
00C1CC  2               
00C1CC  2  C6 72              DEC   ut1_ph            ; else decrement source pointer high byte
00C1CE  2  18                 CLC                     ; clear carry
00C1CF  2               
00C1CF  2                                             ; close up memory to delete old line
00C1CF  2               LAB_12D8
00C1CF  2  B1 71              LDA   (ut1_pl),Y        ; get byte from source
00C1D1  2  91 73              STA   (ut2_pl),Y        ; copy to destination
00C1D3  2  C8                 INY                     ; increment index
00C1D4  2  D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
00C1D6  2               
00C1D6  2  E6 72              INC   ut1_ph            ; increment source pointer high byte
00C1D8  2  E6 74              INC   ut2_ph            ; increment destination pointer high byte
00C1DA  2  CA                 DEX                     ; decrement block count
00C1DB  2  D0 F2              BNE   LAB_12D8          ; loop until all done
00C1DD  2               
00C1DD  2                                             ; got new line in buffer and no existing same #
00C1DD  2               LAB_12E6
00C1DD  2  AD 21 02           LDA   Ibuffs            ; get byte from start of input buffer
00C1E0  2  F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
00C1E2  2               
00C1E2  2                                             ; got new line and it isn't empty line
00C1E2  2  A5 85              LDA   Ememl             ; get end of mem low byte
00C1E4  2  A4 86              LDY   Ememh             ; get end of mem high byte
00C1E6  2  85 81              STA   Sstorl            ; set bottom of string space low byte
00C1E8  2  84 82              STY   Sstorh            ; set bottom of string space high byte
00C1EA  2  A5 7B              LDA   Svarl             ; get start of vars low byte  (end of BASIC)
00C1EC  2  85 A6              STA   Obendl            ; save old block end low byte
00C1EE  2  A4 7C              LDY   Svarh             ; get start of vars high byte (end of BASIC)
00C1F0  2  84 A7              STY   Obendh            ; save old block end high byte
00C1F2  2  65 5D              ADC   Ibptr             ; add input buffer pointer    (also buffer length)
00C1F4  2  90 01              BCC   LAB_1301          ; branch if no overflow from add
00C1F6  2               
00C1F6  2  C8                 INY                     ; else increment high byte
00C1F7  2               LAB_1301
00C1F7  2  85 A4              STA   Nbendl            ; save new block end low byte (move to, low byte)
00C1F9  2  84 A5              STY   Nbendh            ; save new block end high byte
00C1FB  2  20 CB C0           JSR   LAB_11CF          ; open up space in memory
00C1FE  2                                             ; old start pointer Ostrtl,Ostrth set by the find line call
00C1FE  2  A5 7F              LDA   Earryl            ; get array mem end low byte
00C200  2  A4 80              LDY   Earryh            ; get array mem end high byte
00C202  2  85 7B              STA   Svarl             ; save start of vars low byte
00C204  2  84 7C              STY   Svarh             ; save start of vars high byte
00C206  2  A4 5D              LDY   Ibptr             ; get input buffer pointer    (also buffer length)
00C208  2  88                 DEY                     ; adjust for loop type
00C209  2               LAB_1311
00C209  2  B9 1D 02           LDA   Ibuffs-4,Y        ; get byte from crunched line
00C20C  2  91 AA              STA   (Baslnl),Y        ; save it to program memory
00C20E  2  88                 DEY                     ; decrement count
00C20F  2  C0 03              CPY   #$03              ; compare with first byte-1
00C211  2  D0 F6              BNE   LAB_1311          ; continue while count <> 3
00C213  2               
00C213  2  A5 12              LDA   Itemph            ; get line # high byte
00C215  2  91 AA              STA   (Baslnl),Y        ; save it to program memory
00C217  2  88                 DEY                     ; decrement count
00C218  2  A5 11              LDA   Itempl            ; get line # low byte
00C21A  2  91 AA              STA   (Baslnl),Y        ; save it to program memory
00C21C  2  88                 DEY                     ; decrement count
00C21D  2  A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
00C21F  2                                             ; byte then a zero already here would stop the chain rebuild
00C21F  2                                             ; as it would think it was the [EOT] marker.
00C21F  2  91 AA              STA   (Baslnl),Y        ; save it to program memory
00C221  2               
00C221  2               LAB_1319
00C221  2  20 CB C3           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
00C224  2  A6 79              LDX   Smeml             ; get start of mem low byte
00C226  2  A5 7A              LDA   Smemh             ; get start of mem high byte
00C228  2  A0 01              LDY   #$01              ; index to high byte of next line pointer
00C22A  2               LAB_1325
00C22A  2  86 71              STX   ut1_pl            ; set line start pointer low byte
00C22C  2  85 72              STA   ut1_ph            ; set line start pointer high byte
00C22E  2  B1 71              LDA   (ut1_pl),Y        ; get it
00C230  2  F0 18              BEQ   LAB_133E          ; exit if end of program
00C232  2               
00C232  2               ; rebuild chaining of Basic lines
00C232  2               
00C232  2  A0 04              LDY   #$04              ; point to first code byte of line
00C234  2                                             ; there is always 1 byte + [EOL] as null entries are deleted
00C234  2               LAB_1330
00C234  2  C8                 INY                     ; next code byte
00C235  2  B1 71              LDA   (ut1_pl),Y        ; get byte
00C237  2  D0 FB              BNE   LAB_1330          ; loop if not [EOL]
00C239  2               
00C239  2  38                 SEC                     ; set carry for add + 1
00C23A  2  98                 TYA                     ; copy end index
00C23B  2  65 71              ADC   ut1_pl            ; add to line start pointer low byte
00C23D  2  AA                 TAX                     ; copy to X
00C23E  2  A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
00C240  2  91 71              STA   (ut1_pl),Y        ; set next line pointer low byte
00C242  2  98                 TYA                     ; clear A
00C243  2  65 72              ADC   ut1_ph            ; add line start pointer high byte + carry
00C245  2  C8                 INY                     ; increment index to high byte
00C246  2  91 71              STA   (ut1_pl),Y        ; save next line pointer low byte
00C248  2  90 E0              BCC   LAB_1325          ; go do next line, branch always, carry clear
00C24A  2               
00C24A  2               
00C24A  2               LAB_133E
00C24A  2  4C 74 C1           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
00C24D  2               
00C24D  2               ; print "? " and get BASIC input
00C24D  2               
00C24D  2               LAB_INLN
00C24D  2  20 42 CA           JSR   LAB_18E3          ; print "?" character
00C250  2  20 3F CA           JSR   LAB_18E0          ; print " "
00C253  2  D0 07              BNE   LAB_1357          ; call for BASIC input and return
00C255  2               
00C255  2               ; receive line from keyboard
00C255  2               
00C255  2                                             ; $08 as delete key (BACKSPACE on standard keyboard)
00C255  2               LAB_134B
00C255  2  20 44 CA           JSR   LAB_PRNA          ; go print the character
00C258  2  CA                 DEX                     ; decrement the buffer counter (delete)
00C259  2  4C 61 C2           JMP   LAB_1359          ; loop for next input character
00C25C  2               
00C25C  2               ; call for BASIC input (main entry point)
00C25C  2               
00C25C  2               LAB_1357
00C25C  2  20 85 D8           JSR   LAB_CURS_ON       ; show cursor while waiting for input
00C25F  2  A2 00              LDX   #$00              ; clear BASIC line buffer pointer
00C261  2               LAB_1359
00C261  2  20 B3 E6           JSR   V_INPT            ; call scan input device
00C264  2  90 FB              BCC   LAB_1359          ; loop if no byte
00C266  2               
00C266  2  F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
00C268  2               
00C268  2  C9 07              CMP   #$07              ; compare with [BELL]
00C26A  2  F0 10              BEQ   LAB_1378          ; branch if [BELL]
00C26C  2               
00C26C  2  C9 0D              CMP   #$0D              ; compare with [CR]
00C26E  2  F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
00C270  2               
00C270  2  E0 00              CPX   #$00              ; compare pointer with $00
00C272  2  D0 04              BNE   LAB_1374          ; branch if not empty
00C274  2               
00C274  2               ; next two lines ignore any non print character and [SPACE] if input buffer empty
00C274  2               
00C274  2  C9 21              CMP   #$21              ; compare with [SP]+1
00C276  2  90 E9              BCC   LAB_1359          ; if < ignore character
00C278  2               
00C278  2               LAB_1374
00C278  2  C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
00C27A  2  F0 D9              BEQ   LAB_134B          ; go delete last character
00C27C  2               
00C27C  2               LAB_1378
00C27C  2  E0 DE              CPX   #Ibuffe-Ibuffs    ; compare character count with max
00C27E  2  B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
00C280  2               
00C280  2  9D 21 02           STA   Ibuffs,X          ; else store in buffer
00C283  2  E8                 INX                     ; increment pointer
00C284  2               LAB_137F
00C284  2  20 44 CA           JSR   LAB_PRNA          ; go print the character
00C287  2  D0 D8              BNE   LAB_1359          ; always loop for next character
00C289  2               
00C289  2               LAB_1384
00C289  2  4C 8B D8           JMP   LAB_CURS_OFF_CR   ; cursor off, then CR/LF exit to BASIC
00C28C  2               
00C28C  2               ; announce buffer full
00C28C  2               
00C28C  2               LAB_138E
00C28C  2  A9 07              LDA   #$07              ; [BELL] character into A
00C28E  2  D0 F4              BNE   LAB_137F          ; go print the [BELL] but ignore input character
00C290  2                                             ; branch always
00C290  2               
00C290  2               ; crunch keywords into Basic tokens
00C290  2               ; position independent buffer version ..
00C290  2               ; faster, dictionary search version ....
00C290  2               
00C290  2               LAB_13A6
00C290  2  A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
00C292  2               
00C292  2  38                 SEC                     ; set carry for subtract
00C293  2  A5 C3              LDA   Bpntrl            ; get basic execute pointer low byte
00C295  2  E9 21              SBC   #<Ibuffs          ; subtract input buffer start pointer
00C297  2  AA                 TAX                     ; copy result to X (index past line # if any)
00C298  2               
00C298  2  86 60              STX   Oquote            ; clear open quote/DATA flag
00C29A  2               LAB_13AC
00C29A  2  BD 21 02           LDA   Ibuffs,X          ; get byte from input buffer
00C29D  2  F0 56              BEQ   LAB_13EC          ; if null save byte then exit
00C29F  2               
00C29F  2  C9 5F              CMP   #'_'              ; compare with "_"
00C2A1  2  B0 52              BCS   LAB_13EC          ; if >= go save byte then continue crunching
00C2A3  2               
00C2A3  2  C9 3C              CMP   #'<'              ; compare with "<"
00C2A5  2  B0 0E              BCS   LAB_13CC          ; if >= go crunch now
00C2A7  2               
00C2A7  2  C9 30              CMP   #'0'              ; compare with "0"
00C2A9  2  B0 4A              BCS   LAB_13EC          ; if >= go save byte then continue crunching
00C2AB  2               
00C2AB  2  85 5C              STA   Scnquo            ; save buffer byte as search character
00C2AD  2  C9 22              CMP   #$22              ; is it quote character?
00C2AF  2  F0 69              BEQ   LAB_1410          ; branch if so (copy quoted string)
00C2B1  2               
00C2B1  2  C9 2A              CMP   #'*'              ; compare with "*"
00C2B3  2  90 40              BCC   LAB_13EC          ; if < go save byte then continue crunching
00C2B5  2               
00C2B5  2                                             ; else crunch now
00C2B5  2               LAB_13CC
00C2B5  2  24 60              BIT   Oquote            ; get open quote/DATA token flag
00C2B7  2  70 3C              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
00C2B9  2                                             ; go save byte then continue crunching
00C2B9  2               
00C2B9  2  20 33 C3           JSR   LAB_XCRNCHD       ; check DIR/DEL extended two-byte tokens
00C2BC  2  B0 DC              BCS   LAB_13AC          ; matched and emitted, continue with next byte
00C2BE  2               
00C2BE  2  86 78              STX   TempB             ; save buffer read index
00C2C0  2  84 BA              STY   csidx             ; copy buffer save index
00C2C2  2  A0 C1              LDY   #<TAB_1STC        ; get keyword first character table low address
00C2C4  2  84 73              STY   ut2_pl            ; save pointer low byte
00C2C6  2  A0 F8              LDY   #>TAB_1STC        ; get keyword first character table high address
00C2C8  2  84 74              STY   ut2_ph            ; save pointer high byte
00C2CA  2  A0 00              LDY   #$00              ; clear table pointer
00C2CC  2               
00C2CC  2               LAB_13D0
00C2CC  2  D1 73              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
00C2CE  2  F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
00C2D0  2               
00C2D0  2  90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
00C2D2  2                                             ; Y and save to crunched
00C2D2  2               
00C2D2  2  C8                 INY                     ; else increment pointer
00C2D3  2  D0 F7              BNE   LAB_13D0          ; and loop (branch always)
00C2D5  2               
00C2D5  2               ; have matched first character of some keyword
00C2D5  2               
00C2D5  2               LAB_13D1
00C2D5  2  98                 TYA                     ; copy matching index
00C2D6  2  0A                 ASL                     ; *2 (bytes per pointer)
00C2D7  2  AA                 TAX                     ; copy to new index
00C2D8  2  BD DF F8           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
00C2DB  2  85 73              STA   ut2_pl            ; save pointer low byte
00C2DD  2  BD E0 F8           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
00C2E0  2  85 74              STA   ut2_ph            ; save pointer high byte
00C2E2  2               
00C2E2  2  A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
00C2E4  2               
00C2E4  2  A6 78              LDX   TempB             ; restore buffer read index
00C2E6  2               
00C2E6  2               LAB_13D6
00C2E6  2  C8                 INY                     ; next table byte
00C2E7  2  B1 73              LDA   (ut2_pl),Y        ; get byte from table
00C2E9  2               LAB_13D8
00C2E9  2  30 08              BMI   LAB_13EA          ; all bytes matched so go save token
00C2EB  2               
00C2EB  2  E8                 INX                     ; next buffer byte
00C2EC  2  DD 21 02           CMP   Ibuffs,X          ; compare with byte from input buffer
00C2EF  2  F0 F5              BEQ   LAB_13D6          ; go compare next if match
00C2F1  2               
00C2F1  2  D0 2E              BNE   LAB_1417          ; branch if >< (not found keyword)
00C2F3  2               
00C2F3  2               LAB_13EA
00C2F3  2  A4 BA              LDY   csidx             ; restore save index
00C2F5  2               
00C2F5  2                                             ; save crunched to output
00C2F5  2               LAB_13EC
00C2F5  2  E8                 INX                     ; increment buffer index (to next input byte)
00C2F6  2  C8                 INY                     ; increment save index (to next output byte)
00C2F7  2  99 21 02           STA   Ibuffs,Y          ; save byte to output
00C2FA  2  C9 00              CMP   #$00              ; set the flags, set carry
00C2FC  2  D0 03              BNE   @xcr_store_cont
00C2FE  2  4C 7F C3           JMP   LAB_142A          ; do exit if was null [EOL]
00C301  2               @xcr_store_cont
00C301  2               
00C301  2                                             ; A holds token or byte here
00C301  2  E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
00C303  2  F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
00C305  2               
00C305  2                                             ; A now holds token-$3A
00C305  2  C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
00C307  2  D0 02              BNE   LAB_1401          ; branch if not DATA
00C309  2               
00C309  2                                             ; token was : or DATA
00C309  2               LAB_13FF
00C309  2  85 60              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
00C30B  2               LAB_1401
00C30B  2  49 57              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
00C30D  2  D0 8B              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
00C30F  2               
00C30F  2  85 5C              STA   Asrch             ; else was REM so set search for [EOL]
00C311  2               
00C311  2                                             ; loop for REM, "..." etc.
00C311  2               LAB_1408
00C311  2  BD 21 02           LDA   Ibuffs,X          ; get byte from input buffer
00C314  2  F0 DF              BEQ   LAB_13EC          ; branch if null [EOL]
00C316  2               
00C316  2  C5 5C              CMP   Asrch             ; compare with stored character
00C318  2  F0 DB              BEQ   LAB_13EC          ; branch if match (end quote)
00C31A  2               
00C31A  2                                             ; entry for copy string in quotes, don't crunch
00C31A  2               LAB_1410
00C31A  2  C8                 INY                     ; increment buffer save index
00C31B  2  99 21 02           STA   Ibuffs,Y          ; save byte to output
00C31E  2  E8                 INX                     ; increment buffer read index
00C31F  2  D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
00C321  2               
00C321  2                                             ; not found keyword this go
00C321  2               LAB_1417
00C321  2  A6 78              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
00C323  2               
00C323  2                                             ; now find the end of this word in the table
00C323  2               LAB_141B
00C323  2  B1 73              LDA   (ut2_pl),Y        ; get table byte
00C325  2  08                 PHP                     ; save status
00C326  2  C8                 INY                     ; increment table index
00C327  2  28                 PLP                     ; restore byte status
00C328  2  10 F9              BPL   LAB_141B          ; if not end of keyword go do next
00C32A  2               
00C32A  2  B1 73              LDA   (ut2_pl),Y        ; get byte from keyword table
00C32C  2  D0 BB              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
00C32E  2               
00C32E  2                                             ; reached end of table with no match
00C32E  2  BD 21 02           LDA   Ibuffs,X          ; restore byte from input buffer
00C331  2  10 C0              BPL   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
00C333  2                                             ; go save byte in output and continue crunching
00C333  2               
00C333  2               ; check and emit extended two-byte command/function tokens
00C333  2               ; in:  A=current input char, X=read index, Y=save index
00C333  2               ; out: carry set if matched and emitted (X/Y advanced), clear otherwise
00C333  2               ;      A restored to current input char on no match
00C333  2               
00C333  2               LAB_XCRNCHD
00C333  2  84 BA              STY   csidx             ; save save index
00C335  2  86 78              STX   TempB             ; save buffer start position
00C337  2  A9 00              LDA   #$00
00C339  2  85 5D              STA   Tindx             ; token index (0-based)
00C33B  2               
00C33B  2               @next_token
00C33B  2  A6 78              LDX   TempB             ; restore buffer position
00C33D  2  A5 5D              LDA   Tindx
00C33F  2  C9 46              CMP   #XTK_COUNT
00C341  2  B0 33              BCS   @no_match
00C343  2  0A                 ASL                     ; *2 for word pointer
00C344  2  A8                 TAY
00C345  2  B9 E7 E4           LDA   TAB_XTKSTR,Y
00C348  2  85 73              STA   ut2_pl
00C34A  2  B9 E8 E4           LDA   TAB_XTKSTR+1,Y
00C34D  2  85 74              STA   ut2_ph
00C34F  2  A0 00              LDY   #$00
00C351  2               
00C351  2               @cmp_loop
00C351  2  B1 73              LDA   (ut2_pl),Y       ; table char
00C353  2  F0 09              BEQ   @matched          ; null terminator = full match
00C355  2  DD 21 02           CMP   Ibuffs,X
00C358  2  D0 17              BNE   @try_next
00C35A  2  C8                 INY
00C35B  2  E8                 INX
00C35C  2  D0 F3              BNE   @cmp_loop
00C35E  2               
00C35E  2               @matched
00C35E  2  A4 BA              LDY   csidx
00C360  2  C8                 INY
00C361  2  A9 01              LDA   #TKX_PREFIX
00C363  2  99 21 02           STA   Ibuffs,Y
00C366  2  C8                 INY
00C367  2  A5 5D              LDA   Tindx
00C369  2  18                 CLC
00C36A  2  69 01              ADC   #$01              ; token IDs are 1-based
00C36C  2  99 21 02           STA   Ibuffs,Y
00C36F  2  38                 SEC
00C370  2  60                 RTS
00C371  2               
00C371  2               @try_next
00C371  2  E6 5D              INC   Tindx
00C373  2  4C 3B C3           JMP   @next_token
00C376  2               
00C376  2               @no_match
00C376  2  A4 BA              LDY   csidx
00C378  2  A6 78              LDX   TempB
00C37A  2  BD 21 02           LDA   Ibuffs,X
00C37D  2  18                 CLC
00C37E  2  60                 RTS
00C37F  2               
00C37F  2                                             ; reached [EOL]
00C37F  2               LAB_142A
00C37F  2  C8                 INY                     ; increment pointer
00C380  2  C8                 INY                     ; increment pointer (makes it next line pointer high byte)
00C381  2  99 21 02           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
00C384  2  C8                 INY                     ; adjust for line copy
00C385  2  C8                 INY                     ; adjust for line copy
00C386  2  C8                 INY                     ; adjust for line copy
00C387  2               ; *** begin patch for when Ibuffs is $xx00 - Daryl Rictor ***
00C387  2               ; *** insert
00C387  2                     .IF   Ibuffs&$FF=0
00C387  2                     LDA   Bpntrl            ; test for $00
00C387  2                     BNE   LAB_142P          ; not $00
00C387  2                     DEC   Bpntrh            ; allow for increment when $xx00
00C387  2               LAB_142P
00C387  2                     .ENDIF
00C387  2               ; *** end   patch for when Ibuffs is $xx00 - Daryl Rictor ***
00C387  2               ; end of patch
00C387  2  C6 C3              DEC   Bpntrl            ; allow for increment
00C389  2  60                 RTS
00C38A  2               
00C38A  2               ; search Basic for temp integer line number from start of mem
00C38A  2               
00C38A  2               LAB_SSLN
00C38A  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C38C  2  A6 7A              LDX   Smemh             ; get start of mem high byte
00C38E  2               
00C38E  2               ; search Basic for temp integer line number from AX
00C38E  2               ; returns carry set if found
00C38E  2               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
00C38E  2               
00C38E  2               ; old 541 new 507
00C38E  2               
00C38E  2               LAB_SHLN
00C38E  2  A0 01              LDY   #$01              ; set index
00C390  2  85 AA              STA   Baslnl            ; save low byte as current
00C392  2  86 AB              STX   Baslnh            ; save high byte as current
00C394  2  B1 AA              LDA   (Baslnl),Y        ; get pointer high byte from addr
00C396  2  F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
00C398  2               
00C398  2  A0 03              LDY   #$03              ; set index to line # high byte
00C39A  2  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
00C39C  2  88                 DEY                     ; decrement index (point to low byte)
00C39D  2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
00C39F  2  D0 04              BNE   LAB_1455          ; if <> skip low byte check
00C3A1  2               
00C3A1  2  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
00C3A3  2  C5 11              CMP   Itempl            ; compare with temporary integer low byte
00C3A5  2               LAB_1455
00C3A5  2  B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
00C3A7  2               
00C3A7  2               LAB_1456
00C3A7  2  88                 DEY                     ; decrement index to next line ptr high byte
00C3A8  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00C3AA  2  AA                 TAX                     ; copy to X
00C3AB  2  88                 DEY                     ; decrement index to next line ptr low byte
00C3AC  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
00C3AE  2  90 DE              BCC   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
00C3B0  2                                             ; (carry always clear)
00C3B0  2               
00C3B0  2               LAB_145E
00C3B0  2  F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
00C3B2  2               
00C3B2  2               LAB_145F
00C3B2  2  18                 CLC                     ; clear found flag
00C3B3  2               LAB_1460
00C3B3  2  60                 RTS
00C3B4  2               
00C3B4  2               ; perform NEW
00C3B4  2               
00C3B4  2               LAB_NEW
00C3B4  2  D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
00C3B6  2               
00C3B6  2               LAB_1463
00C3B6  2  A9 00              LDA   #$00              ; clear A
00C3B8  2  A8                 TAY                     ; clear Y
00C3B9  2  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
00C3BB  2  C8                 INY                     ; increment index
00C3BC  2  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
00C3BE  2  18                 CLC                     ; clear carry
00C3BF  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C3C1  2  69 02              ADC   #$02              ; calculate end of BASIC low byte
00C3C3  2  85 7B              STA   Svarl             ; save start of vars low byte
00C3C5  2  A5 7A              LDA   Smemh             ; get start of mem high byte
00C3C7  2  69 00              ADC   #$00              ; add any carry
00C3C9  2  85 7C              STA   Svarh             ; save start of vars high byte
00C3CB  2               
00C3CB  2               ; reset execution to start, clear vars and flush stack
00C3CB  2               
00C3CB  2               LAB_1477
00C3CB  2  18                 CLC                     ; clear carry
00C3CC  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C3CE  2  69 FF              ADC   #$FF              ; -1
00C3D0  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C3D2  2  A5 7A              LDA   Smemh             ; get start of mem high byte
00C3D4  2  69 FF              ADC   #$FF              ; -1+carry
00C3D6  2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00C3D8  2               
00C3D8  2               ; "CLEAR" command gets here
00C3D8  2               
00C3D8  2               LAB_147A
00C3D8  2  A5 85              LDA   Ememl             ; get end of mem low byte
00C3DA  2  A4 86              LDY   Ememh             ; get end of mem high byte
00C3DC  2  85 81              STA   Sstorl            ; set bottom of string space low byte
00C3DE  2  84 82              STY   Sstorh            ; set bottom of string space high byte
00C3E0  2  A5 7B              LDA   Svarl             ; get start of vars low byte
00C3E2  2  A4 7C              LDY   Svarh             ; get start of vars high byte
00C3E4  2  85 7D              STA   Sarryl            ; save var mem end low byte
00C3E6  2  84 7E              STY   Sarryh            ; save var mem end high byte
00C3E8  2  85 7F              STA   Earryl            ; save array mem end low byte
00C3EA  2  84 80              STY   Earryh            ; save array mem end high byte
00C3EC  2  20 98 C6           JSR   LAB_161A          ; perform RESTORE command
00C3EF  2               
00C3EF  2               ; flush stack and clear continue flag
00C3EF  2               
00C3EF  2               LAB_1491
00C3EF  2  A2 68              LDX   #des_sk           ; set descriptor stack pointer
00C3F1  2  86 65              STX   next_s            ; save descriptor stack pointer
00C3F3  2  68                 PLA                     ; pull return address low byte
00C3F4  2  AA                 TAX                     ; copy return address low byte
00C3F5  2  68                 PLA                     ; pull return address high byte
00C3F6  2  8E FE 01           STX   LAB_SKFE          ; save to cleared stack
00C3F9  2  8D FF 01           STA   LAB_SKFF          ; save to cleared stack
00C3FC  2  A2 FD              LDX   #$FD              ; new stack pointer
00C3FE  2  9A                 TXS                     ; reset stack
00C3FF  2  A9 00              LDA   #$00              ; clear byte
00C401  2               ;*** fix p2: no longer necessary as the continue pointer is saved anyway
00C401  2               ;      STA   Cpntrh            ; clear continue pointer high byte
00C401  2  85 61              STA   Sufnxf            ; clear subscript/FNX flag
00C403  2               LAB_14A6
00C403  2  60                 RTS
00C404  2               
00C404  2               ; perform CLEAR
00C404  2               
00C404  2               LAB_CLEAR
00C404  2  F0 D2              BEQ   LAB_147A          ; if no following token go do "CLEAR"
00C406  2               
00C406  2                                             ; else there was a following token (go do syntax error)
00C406  2  60                 RTS
00C407  2               
00C407  2               ; perform LIST [n][-m]
00C407  2               ; bigger, faster version (a _lot_ faster)
00C407  2               
00C407  2               LAB_LIST
00C407  2  90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
00C409  2               
00C409  2  F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
00C40B  2               
00C40B  2  C9 CD              CMP   #TK_MINUS         ; compare with token for -
00C40D  2  D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
00C40F  2               
00C40F  2                                             ; LIST [[n][-m]]
00C40F  2                                             ; this bit sets the n , if present, as the start and end
00C40F  2               LAB_14BD
00C40F  2  20 AC C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00C412  2  20 8A C3           JSR   LAB_SSLN          ; search BASIC for temp integer line number
00C415  2                                             ; (pointer in Baslnl/Baslnh)
00C415  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C418  2  F0 0C              BEQ   LAB_14D4          ; branch if no more characters
00C41A  2               
00C41A  2                                             ; this bit checks the - is present
00C41A  2  C9 CD              CMP   #TK_MINUS         ; compare with token for -
00C41C  2  D0 95              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
00C41E  2               
00C41E  2                                             ; LIST [n]-m
00C41E  2                                             ; the - was there so set m as the end value
00C41E  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C421  2  20 AC C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00C424  2  D0 8D              BNE   LAB_1460          ; exit if not ok
00C426  2               
00C426  2               LAB_14D4
00C426  2  A5 11              LDA   Itempl            ; get temporary integer low byte
00C428  2  05 12              ORA   Itemph            ; OR temporary integer high byte
00C42A  2  D0 06              BNE   LAB_14E2          ; branch if start set
00C42C  2               
00C42C  2  A9 FF              LDA   #$FF              ; set for -1
00C42E  2  85 11              STA   Itempl            ; set temporary integer low byte
00C430  2  85 12              STA   Itemph            ; set temporary integer high byte
00C432  2               LAB_14E2
00C432  2  A0 01              LDY   #$01              ; set index for line
00C434  2  84 60              STY   Oquote            ; clear open quote flag
00C436  2  20 E9 C9           JSR   LAB_CRLF          ; print CR/LF
00C439  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00C43B  2                                             ; pointer initially set by search at LAB_14BD
00C43B  2  F0 3E              BEQ   LAB_152B          ; if null all done so exit
00C43D  2  20 6E C6           JSR   LAB_1629          ; do CRTL-C check vector
00C440  2               
00C440  2  C8                 INY                     ; increment index for line
00C441  2  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
00C443  2  AA                 TAX                     ; copy to X
00C444  2  C8                 INY                     ; increment index
00C445  2  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
00C447  2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
00C449  2  D0 04              BNE   LAB_14FF          ; branch if no high byte match
00C44B  2               
00C44B  2  E4 11              CPX   Itempl            ; compare with temporary integer low byte
00C44D  2  F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
00C44F  2               
00C44F  2               LAB_14FF                      ; else ..
00C44F  2  B0 2A              BCS   LAB_152B          ; if greater all done so exit
00C451  2               
00C451  2               LAB_1501
00C451  2  84 97              STY   Tidx1             ; save index for line
00C453  2  20 8C DD           JSR   LAB_295E          ; print XA as unsigned integer
00C456  2  A9 20              LDA   #$20              ; space is the next character
00C458  2               LAB_1508
00C458  2  A4 97              LDY   Tidx1             ; get index for line
00C45A  2  29 7F              AND   #$7F              ; mask top out bit of character
00C45C  2               LAB_150C
00C45C  2  20 44 CA           JSR   LAB_PRNA          ; go print the character
00C45F  2  C9 22              CMP   #$22              ; was it " character
00C461  2  D0 06              BNE   LAB_1519          ; branch if not
00C463  2               
00C463  2                                             ; we are either entering or leaving a pair of quotes
00C463  2  A5 60              LDA   Oquote            ; get open quote flag
00C465  2  49 FF              EOR   #$FF              ; toggle it
00C467  2  85 60              STA   Oquote            ; save it back
00C469  2               LAB_1519
00C469  2  C8                 INY                     ; increment index
00C46A  2  B1 AA              LDA   (Baslnl),Y        ; get next byte
00C46C  2  D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
00C46E  2  A8                 TAY                     ; else clear index
00C46F  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
00C471  2  AA                 TAX                     ; copy to X
00C472  2  C8                 INY                     ; increment index
00C473  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00C475  2  86 AA              STX   Baslnl            ; set pointer to line low byte
00C477  2  85 AB              STA   Baslnh            ; set pointer to line high byte
00C479  2  D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
00C47B  2                                             ; else ..
00C47B  2               LAB_152B
00C47B  2  60                 RTS
00C47C  2               
00C47C  2               LAB_152E
00C47C  2  C9 01              CMP   #TKX_PREFIX       ; extended two-byte token prefix?
00C47E  2  F0 42              BEQ   LAB_152E_X
00C480  2  C9 80              CMP   #$80              ; token byte? (bit 7 set)
00C482  2  90 D8              BCC   LAB_150C          ; < $80 is plain character, go print it
00C484  2               
00C484  2                                             ; else was token byte so uncrunch it (maybe)
00C484  2  24 60              BIT   Oquote            ; test the open quote flag
00C486  2  30 D4              BMI   LAB_150C          ; just go print character if open quote set
00C488  2               
00C488  2  A2 FB              LDX   #>LAB_KEYT        ; get table address high byte
00C48A  2  0A                 ASL                     ; *2
00C48B  2  0A                 ASL                     ; *4
00C48C  2  90 02              BCC   LAB_152F          ; branch if no carry
00C48E  2               
00C48E  2  E8                 INX                     ; else increment high byte
00C48F  2  18                 CLC                     ; clear carry for add
00C490  2               LAB_152F
00C490  2  69 62              ADC   #<LAB_KEYT        ; add low byte
00C492  2  90 01              BCC   LAB_1530          ; branch if no carry
00C494  2               
00C494  2  E8                 INX                     ; else increment high byte
00C495  2               LAB_1530
00C495  2  85 73              STA   ut2_pl            ; save table pointer low byte
00C497  2  86 74              STX   ut2_ph            ; save table pointer high byte
00C499  2  84 97              STY   Tidx1             ; save index for line
00C49B  2  A0 00              LDY   #$00              ; clear index
00C49D  2  B1 73              LDA   (ut2_pl),Y        ; get length
00C49F  2  AA                 TAX                     ; copy length
00C4A0  2  C8                 INY                     ; increment index
00C4A1  2  B1 73              LDA   (ut2_pl),Y        ; get 1st character
00C4A3  2  CA                 DEX                     ; decrement length
00C4A4  2  F0 B2              BEQ   LAB_1508          ; if no more characters exit and print
00C4A6  2               
00C4A6  2  20 44 CA           JSR   LAB_PRNA          ; go print the character
00C4A9  2  C8                 INY                     ; increment index
00C4AA  2  B1 73              LDA   (ut2_pl),Y        ; get keyword address low byte
00C4AC  2  48                 PHA                     ; save it for now
00C4AD  2  C8                 INY                     ; increment index
00C4AE  2  B1 73              LDA   (ut2_pl),Y        ; get keyword address high byte
00C4B0  2  A0 00              LDY   #$00
00C4B2  2  85 74              STA   ut2_ph            ; save keyword pointer high byte
00C4B4  2  68                 PLA                     ; pull low byte
00C4B5  2  85 73              STA   ut2_pl            ; save keyword pointer low byte
00C4B7  2               LAB_1540
00C4B7  2  B1 73              LDA   (ut2_pl),Y        ; get character
00C4B9  2  CA                 DEX                     ; decrement character count
00C4BA  2  F0 9C              BEQ   LAB_1508          ; if last character exit and print
00C4BC  2               
00C4BC  2  20 44 CA           JSR   LAB_PRNA          ; go print the character
00C4BF  2  C8                 INY                     ; increment index
00C4C0  2  D0 F5              BNE   LAB_1540          ; loop for next character
00C4C2  2               
00C4C2  2               ; decode extended two-byte tokens during LIST output
00C4C2  2               
00C4C2  2               LAB_152E_X
00C4C2  2  24 60              BIT   Oquote            ; test the open quote flag
00C4C4  2  30 96              BMI   LAB_150C          ; in quotes, treat as plain character
00C4C6  2  84 97              STY   Tidx1             ; save index of extension prefix
00C4C8  2  C8                 INY                     ; move to extension id byte
00C4C9  2  B1 AA              LDA   (Baslnl),Y       ; get extension id
00C4CB  2  C9 47              CMP   #XTK_COUNT+1
00C4CD  2  B0 25              BCS   @unknown
00C4CF  2  C9 01              CMP   #$01
00C4D1  2  90 21              BCC   @unknown
00C4D3  2  38                 SEC
00C4D4  2  E9 01              SBC   #$01              ; 0-based index
00C4D6  2  0A                 ASL                     ; *2 for word pointer
00C4D7  2  AA                 TAX
00C4D8  2  BD E7 E4           LDA   TAB_XTKSTR,X
00C4DB  2  85 73              STA   ut2_pl
00C4DD  2  BD E8 E4           LDA   TAB_XTKSTR+1,X
00C4E0  2  85 74              STA   ut2_ph
00C4E2  2  A0 00              LDY   #$00
00C4E4  2               @print_loop
00C4E4  2  B1 73              LDA   (ut2_pl),Y
00C4E6  2  F0 06              BEQ   @done
00C4E8  2  20 44 CA           JSR   LAB_PRNA
00C4EB  2  C8                 INY
00C4EC  2  D0 F6              BNE   @print_loop
00C4EE  2               @done
00C4EE  2  A4 97              LDY   Tidx1
00C4F0  2  C8                 INY                     ; set index to extension id byte
00C4F1  2  4C 69 C4           JMP   LAB_1519          ; continue at byte after extended token
00C4F4  2               @unknown
00C4F4  2  A4 97              LDY   Tidx1             ; unknown extension id: print prefix as-is
00C4F6  2  4C 5C C4           JMP   LAB_150C
00C4F9  2               
00C4F9  2               ; perform FOR
00C4F9  2               
00C4F9  2               LAB_FOR
00C4F9  2  A9 80              LDA   #$80              ; set FNX
00C4FB  2  85 61              STA   Sufnxf            ; set subscript/FNX flag
00C4FD  2  20 0B C9           JSR   LAB_LET           ; go do LET
00C500  2  68                 PLA                     ; pull return address
00C501  2  68                 PLA                     ; pull return address
00C502  2  A9 10              LDA   #$10              ; we need 16d bytes !
00C504  2  20 0D C1           JSR   LAB_1212          ; check room on stack for A bytes
00C507  2  20 F1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
00C50A  2  18                 CLC                     ; clear carry for add
00C50B  2  98                 TYA                     ; copy index to A
00C50C  2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00C50E  2  48                 PHA                     ; push onto stack
00C50F  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00C511  2  69 00              ADC   #$00              ; add carry
00C513  2  48                 PHA                     ; push onto stack
00C514  2  A5 88              LDA   Clineh            ; get current line high byte
00C516  2  48                 PHA                     ; push onto stack
00C517  2  A5 87              LDA   Clinel            ; get current line low byte
00C519  2  48                 PHA                     ; push onto stack
00C51A  2  A9 C3              LDA   #TK_TO            ; get "TO" token
00C51C  2  20 40 CD           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
00C51F  2  20 18 CC           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00C522  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00C525  2                                             ; else do type mismatch
00C525  2               ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
00C525  2               ; *** add
00C525  2  20 E3 DB           JSR   LAB_27BA          ; round FAC1
00C528  2               ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
00C528  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00C52A  2  09 7F              ORA   #$7F              ; set all non sign bits
00C52C  2  25 AD              AND   FAC1_1            ; and FAC1 mantissa1
00C52E  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00C530  2  A9 3B              LDA   #<LAB_159F        ; set return address low byte
00C532  2  A0 C5              LDY   #>LAB_159F        ; set return address high byte
00C534  2  85 71              STA   ut1_pl            ; save return address low byte
00C536  2  84 72              STY   ut1_ph            ; save return address high byte
00C538  2  4C CF CC           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
00C53B  2               
00C53B  2               LAB_159F
00C53B  2  A9 55              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
00C53D  2  A0 F7              LDY   #>LAB_259C        ; set 1 pointer high addr
00C53F  2  20 87 DB           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00C542  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C545  2  C9 C8              CMP   #TK_STEP          ; compare with STEP token
00C547  2  D0 06              BNE   LAB_15B3          ; jump if not "STEP"
00C549  2               
00C549  2                                             ;.was step so ..
00C549  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C54C  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00C54F  2                                             ; else do type mismatch
00C54F  2               LAB_15B3
00C54F  2  20 F3 DB           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
00C552  2  85 B0              STA   FAC1_s            ; set FAC1 sign (b7)
00C554  2                                             ; this is +1 for +ve step and -1 for -ve step, in NEXT we
00C554  2                                             ; compare the FOR value and the TO value and return +1 if
00C554  2                                             ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
00C554  2                                             ; here (+/-1) is then compared to that result and if they
00C554  2                                             ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
00C554  2                                             ; the loop is done
00C554  2               
00C554  2               ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00C554  2               ; *** add
00C554  2                  .IF (* & $FF)=$FD
00C554  2                     NOP                     ; return address of JSR +1 (on  next page)
00C554  2                  .ENDIF
00C554  2               ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00C554  2  20 C1 CC           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
00C557  2  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
00C559  2  48                 PHA                     ; push on stack
00C55A  2  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
00C55C  2  48                 PHA                     ; push on stack
00C55D  2  A9 81              LDA   #TK_FOR           ; get FOR token
00C55F  2  48                 PHA                     ; push on stack
00C560  2               
00C560  2               ; interpreter inner loop
00C560  2               
00C560  2               LAB_15C2
00C560  2  20 6E C6           JSR   LAB_1629          ; do CRTL-C check vector
00C563  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00C565  2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
00C567  2               
00C567  2  A6 88              LDX   Clineh            ; continue line is $FFxx for immediate mode
00C569  2                                             ; ($00xx for RUN from immediate mode)
00C569  2  E8                 INX                     ; increment it (now $00 if immediate mode)
00C56A  2               ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
00C56A  2               ;      BEQ   LAB_15D1          ; branch if null (immediate mode)
00C56A  2               
00C56A  2  85 8B              STA   Cpntrl            ; save continue pointer low byte
00C56C  2  84 8C              STY   Cpntrh            ; save continue pointer high byte
00C56E  2               LAB_15D1
00C56E  2  A0 00              LDY   #$00              ; clear index
00C570  2  B1 C3              LDA   (Bpntrl),Y        ; get next byte
00C572  2  F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
00C574  2               
00C574  2  C9 3A              CMP   #':'              ; compare with ":"
00C576  2  F0 20              BEQ   LAB_15F6          ; branch if = (statement separator)
00C578  2               
00C578  2               LAB_15D9
00C578  2  4C 51 CD           JMP   LAB_SNER          ; else syntax error then warm start
00C57B  2               
00C57B  2                                             ; have reached [EOL]
00C57B  2               LAB_15DC
00C57B  2  A0 02              LDY   #$02              ; set index
00C57D  2  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
00C57F  2  18                 CLC                     ; clear carry for no "BREAK" message
00C580  2  D0 03              BNE   @line_ptr_ok
00C582  2  4C 8A C6           JMP   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
00C585  2                                             ; marker)
00C585  2               @line_ptr_ok
00C585  2               
00C585  2  C8                 INY                     ; increment index
00C586  2  B1 C3              LDA   (Bpntrl),Y        ; get line # low byte
00C588  2  85 87              STA   Clinel            ; save current line low byte
00C58A  2  C8                 INY                     ; increment index
00C58B  2  B1 C3              LDA   (Bpntrl),Y        ; get line # high byte
00C58D  2  85 88              STA   Clineh            ; save current line high byte
00C58F  2  98                 TYA                     ; A now = 4
00C590  2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00C592  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C594  2  90 02              BCC   LAB_15F6          ; branch if no overflow
00C596  2               
00C596  2  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
00C598  2               LAB_15F6
00C598  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C59B  2               
00C59B  2               LAB_15F9
00C59B  2  20 A1 C5           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
00C59E  2               
00C59E  2               LAB_15FC
00C59E  2  4C 60 C5           JMP   LAB_15C2          ; loop
00C5A1  2               
00C5A1  2               ; interpret BASIC code from (Bpntrl)
00C5A1  2               
00C5A1  2               LAB_15FF
00C5A1  2  D0 03              BNE   @stmt_not_eol
00C5A3  2  4C A6 C6           JMP   LAB_1628          ; exit if zero [EOL]
00C5A6  2               @stmt_not_eol
00C5A6  2  C9 01              CMP   #TKX_PREFIX       ; extended two-byte token prefix?
00C5A8  2  F0 16              BEQ   LAB_1602X         ; yes, dispatch from extension table
00C5AA  2               
00C5AA  2               LAB_1602
00C5AA  2  0A                 ASL                     ; *2 bytes per vector and normalise token
00C5AB  2  B0 03              BCS   LAB_1609          ; branch if was token
00C5AD  2               
00C5AD  2  4C 0B C9           JMP   LAB_LET           ; else go do implied LET
00C5B0  2               
00C5B0  2               LAB_1609
00C5B0  2  C9 82              CMP   #(TK_TAB-$80)*2   ; compare normalised token * 2 with TAB
00C5B2  2  B0 C4              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
00C5B4  2                                             ; only tokens before TAB can start a line
00C5B4  2  A8                 TAY                     ; copy to index
00C5B5  2  B9 7D F7           LDA   LAB_CTBL+1,Y      ; get vector high byte
00C5B8  2  48                 PHA                     ; onto stack
00C5B9  2  B9 7C F7           LDA   LAB_CTBL,Y        ; get vector low byte
00C5BC  2  48                 PHA                     ; onto stack
00C5BD  2  4C BC 00           JMP   LAB_IGBY          ; jump to increment and scan memory
00C5C0  2                                             ; then "return" to vector
00C5C0  2               
00C5C0  2               ; dispatch extended two-byte command tokens
00C5C0  2               ; entry with A = TKX_PREFIX at current BASIC execute pointer
00C5C0  2               
00C5C0  2               LAB_1602X
00C5C0  2  20 BC 00           JSR   LAB_IGBY          ; consume prefix, get extension id in A
00C5C3  2  A0 00              LDY   #$00
00C5C5  2  B1 C3              LDA   (Bpntrl),Y        ; read raw extension id (LAB_IGBY may normalize A)
00C5C7  2  C9 47              CMP   #XTK_COUNT+1
00C5C9  2  B0 14              BCS   @syntax_err
00C5CB  2  C9 01              CMP   #$01
00C5CD  2  90 10              BCC   @syntax_err
00C5CF  2  38                 SEC
00C5D0  2  E9 01              SBC   #$01              ; 0-based index
00C5D2  2  0A                 ASL                     ; *2 for word pointer
00C5D3  2  AA                 TAX
00C5D4  2  BD E3 C5           LDA   TAB_XTKCMD+1,X
00C5D7  2  48                 PHA
00C5D8  2  BD E2 C5           LDA   TAB_XTKCMD,X
00C5DB  2  48                 PHA
00C5DC  2  4C BC 00           JMP   LAB_IGBY          ; consume extension id, RTS -> handler
00C5DF  2               
00C5DF  2               @syntax_err
00C5DF  2  4C 78 C5           JMP   LAB_15D9          ; syntax error
00C5E2  2               
00C5E2  2               TAB_XTKCMD
00C5E2  2  B5 F2              .word LAB_DIR-1         ; XTK_DIR   ($01)
00C5E4  2  46 F2              .word LAB_FDEL-1        ; XTK_DEL   ($02)
00C5E6  2  D8 F3              .word LAB_XMEM-1        ; XTK_XMEM  ($03)
00C5E8  2  4F F4              .word LAB_XBANK-1       ; XTK_XBANK ($04)
00C5EA  2  5E F4              .word LAB_XPOKE-1       ; XTK_XPOKE ($05)
00C5EC  2  77 C5              .word LAB_15D9-1        ; XTK_XPEEK ($06) - function only, syntax error
00C5EE  2  72 F4              .word LAB_XSTASH-1      ; XTK_STASH ($07)
00C5F0  2  D4 F4              .word LAB_XFETCH-1      ; XTK_FETCH ($08)
00C5F2  2  2E F5              .word LAB_XFREE-1       ; XTK_XFREE ($09)
00C5F4  2  49 F5              .word LAB_XRESET-1      ; XTK_XRESET ($0A)
00C5F6  2  51 F5              .word LAB_XALLOC-1      ; XTK_XALLOC ($0B)
00C5F8  2  66 F5              .word LAB_XDIR-1        ; XTK_XDIR  ($0C)
00C5FA  2  A2 F5              .word LAB_XDEL-1        ; XTK_XDEL  ($0D)
00C5FC  2  B2 F5              .word LAB_XMAP-1        ; XTK_XMAP  ($0E)
00C5FE  2  D5 F5              .word LAB_XUNMAP-1      ; XTK_XUNMAP ($0F)
00C600  2  AC EB              .word LAB_GSAVE-1       ; XTK_GSAVE ($10)
00C602  2  ED EB              .word LAB_GLOAD-1       ; XTK_GLOAD ($11)
00C604  2  47 EC              .word LAB_SIDPLAY-1     ; XTK_SIDPLAY ($12)
00C606  2  7F EC              .word LAB_SIDSTOP-1     ; XTK_SIDSTOP ($13)
00C608  2  85 EC              .word LAB_MUSIC-1       ; XTK_MUSIC ($14)
00C60A  2  77 C5              .word LAB_15D9-1        ; XTK_PLAYING ($15) - function only, syntax error
00C60C  2  77 C5              .word LAB_15D9-1        ; XTK_MNOTE ($16)   - function only, syntax error
00C60E  2  AD ED              .word LAB_COPPER-1      ; XTK_COPPER ($17)
00C610  2  6C EF              .word LAB_RESET-1       ; XTK_RESET  ($18)
00C612  2  74 EF              .word LAB_NOPEN-1       ; XTK_NOPEN   ($19)
00C614  2  B3 EF              .word LAB_NCLOSE-1      ; XTK_NCLOSE  ($1A)
00C616  2  BF EF              .word LAB_NLISTEN-1     ; XTK_NLISTEN ($1B)
00C618  2  DB EF              .word LAB_NACCEPT-1     ; XTK_NACCEPT ($1C)
00C61A  2  E7 EF              .word LAB_NSEND-1       ; XTK_NSEND   ($1D)
00C61C  2  77 C5              .word LAB_15D9-1        ; XTK_NRECV   ($1E) — function only
00C61E  2  77 C5              .word LAB_15D9-1        ; XTK_NSTATUS ($1F) — function only
00C620  2  77 C5              .word LAB_15D9-1        ; $20 — reserved (space), syntax error
00C622  2  77 C5              .word LAB_15D9-1        ; XTK_NREADY  ($21) — function only
00C624  2  77 C5              .word LAB_15D9-1        ; XTK_NLEN    ($22) — function only
00C626  2  0F F0              .word LAB_DMACOPY-1     ; XTK_DMACOPY ($23)
00C628  2  92 F0              .word LAB_DMAFILL-1     ; XTK_DMAFILL ($24)
00C62A  2  77 C5              .word LAB_15D9-1        ; XTK_DMASTATUS ($25) — function only
00C62C  2  77 C5              .word LAB_15D9-1        ; $26 — reserved, syntax error
00C62E  2  77 C5              .word LAB_15D9-1        ; XTK_DMAERR    ($27) — function only
00C630  2  77 C5              .word LAB_15D9-1        ; XTK_DMACOUNT  ($28) — function only
00C632  2                     ; $29-$3F reserved (23 entries)
00C632  2  77 C5 77 C5        .repeat $17
00C636  2  77 C5 77 C5  
00C63A  2  77 C5 77 C5  
00C660  2                     .word LAB_15D9-1
00C660  2                     .endrepeat
00C660  2  00 F1              .word LAB_BLITCOPY-1    ; XTK_BLITCOPY   ($40)
00C662  2  B4 F1              .word LAB_BLITFILL-1    ; XTK_BLITFILL   ($41)
00C664  2  77 C5              .word LAB_15D9-1        ; XTK_BLITSTATUS ($42) — function only
00C666  2  77 C5              .word LAB_15D9-1        ; XTK_BLITERR    ($43) — function only
00C668  2  77 C5              .word LAB_15D9-1        ; XTK_BLITCOUNT  ($44) — function only
00C66A  2  A3 E0              .word LAB_BITTGL-1      ; XTK_BITTGL     ($45) — toggle bits
00C66C  2  AE E0              .word LAB_HELP-1        ; XTK_HELP       ($46)
00C66E  2               
00C66E  2               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
00C66E  2               ; key press is detected.
00C66E  2               
00C66E  2               LAB_1629
00C66E  2  6C 03 02           JMP   (VEC_CC)          ; ctrl c check vector
00C671  2               
00C671  2               ; if there was a key press it gets back here ..
00C671  2               
00C671  2               LAB_1636
00C671  2  C9 03              CMP   #$03              ; compare with CTRL-C
00C673  2               
00C673  2               ; perform STOP
00C673  2               
00C673  2               LAB_STOP
00C673  2  B0 01              BCS   LAB_163B          ; branch if token follows STOP
00C675  2                                             ; else just END
00C675  2               ; END
00C675  2               
00C675  2               LAB_END
00C675  2  18                 CLC                     ; clear the carry, indicate a normal program end
00C676  2               LAB_163B
00C676  2  D0 5F              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
00C678  2               
00C678  2  A5 C4              LDA   Bpntrh            ; get the BASIC execute pointer high byte
00C67A  2               ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
00C67A  2               ;      EOR   #>Ibuffs          ; compare with buffer address high byte (Cb unchanged)
00C67A  2               ;      BEQ   LAB_164F          ; branch if the BASIC pointer is in the input buffer
00C67A  2               ;                              ; (can't continue in immediate mode)
00C67A  2               ;                              ; else ..
00C67A  2               ;      EOR   #>Ibuffs          ; correct the bits
00C67A  2  A4 C3              LDY   Bpntrl            ; get BASIC execute pointer low byte
00C67C  2  84 8B              STY   Cpntrl            ; save continue pointer low byte
00C67E  2  85 8C              STA   Cpntrh            ; save continue pointer high byte
00C680  2               LAB_1647
00C680  2  A5 87              LDA   Clinel            ; get current line low byte
00C682  2  A4 88              LDY   Clineh            ; get current line high byte
00C684  2  85 89              STA   Blinel            ; save break line low byte
00C686  2  84 8A              STY   Blineh            ; save break line high byte
00C688  2               LAB_164F
00C688  2  68                 PLA                     ; pull return address low
00C689  2  68                 PLA                     ; pull return address high
00C68A  2               LAB_1651
00C68A  2  90 07              BCC   LAB_165E          ; if was program end just do warm start
00C68C  2               
00C68C  2                                             ; else ..
00C68C  2  A9 97              LDA   #<LAB_BMSG        ; point to "Break" low byte
00C68E  2  A0 FE              LDY   #>LAB_BMSG        ; point to "Break" high byte
00C690  2  4C 5C C1           JMP   LAB_1269          ; print "Break" and do warm start
00C693  2               
00C693  2               LAB_165E
00C693  2  4C 67 C1           JMP   LAB_1274          ; go do warm start
00C696  2               
00C696  2               ; perform RESTORE
00C696  2               
00C696  2               LAB_RESTORE
00C696  2  D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
00C698  2               
00C698  2               LAB_161A
00C698  2  38                 SEC                     ; set carry for subtract
00C699  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C69B  2  E9 01              SBC   #$01              ; -1
00C69D  2  A4 7A              LDY   Smemh             ; get start of mem high byte
00C69F  2  B0 01              BCS   LAB_1624          ; branch if no underflow
00C6A1  2               
00C6A1  2               LAB_uflow
00C6A1  2  88                 DEY                     ; else decrement high byte
00C6A2  2               LAB_1624
00C6A2  2  85 8F              STA   Dptrl             ; save DATA pointer low byte
00C6A4  2  84 90              STY   Dptrh             ; save DATA pointer high byte
00C6A6  2               LAB_1628
00C6A6  2  60                 RTS
00C6A7  2               
00C6A7  2                                             ; is RESTORE n
00C6A7  2               LAB_RESTOREn
00C6A7  2  20 AC C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00C6AA  2  20 F4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
00C6AD  2  A5 88              LDA   Clineh            ; get current line high byte
00C6AF  2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
00C6B1  2  B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
00C6B3  2               
00C6B3  2  98                 TYA                     ; else copy line index to A
00C6B4  2  38                 SEC                     ; set carry (+1)
00C6B5  2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00C6B7  2  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
00C6B9  2  90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
00C6BB  2               
00C6BB  2  E8                 INX                     ; increment high byte
00C6BC  2  B0 04              BCS   LAB_go_search     ; branch always (can never be carry clear)
00C6BE  2               
00C6BE  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
00C6BE  2               
00C6BE  2               LAB_reset_search
00C6BE  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C6C0  2  A6 7A              LDX   Smemh             ; get start of mem high byte
00C6C2  2               
00C6C2  2               ; search for line # in temp (Itempl/Itemph) from (AX)
00C6C2  2               
00C6C2  2               LAB_go_search
00C6C2  2               
00C6C2  2  20 8E C3           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
00C6C5  2  B0 03              BCS   LAB_line_found    ; if carry set go set pointer
00C6C7  2               
00C6C7  2  4C C6 C7           JMP   LAB_16F7          ; else go do "Undefined statement" error
00C6CA  2               
00C6CA  2               LAB_line_found
00C6CA  2                                             ; carry already set for subtract
00C6CA  2  A5 AA              LDA   Baslnl            ; get pointer low byte
00C6CC  2  E9 01              SBC   #$01              ; -1
00C6CE  2  A4 AB              LDY   Baslnh            ; get pointer high byte
00C6D0  2  B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
00C6D2  2               
00C6D2  2  90 CD              BCC   LAB_uflow         ; else decrement high byte then save DATA pointer and
00C6D4  2                                             ; return (branch always)
00C6D4  2               
00C6D4  2               ; perform NULL
00C6D4  2               
00C6D4  2               LAB_NULL
00C6D4  2  20 8F D7           JSR   LAB_GTBY          ; parse and discard byte parameter
00C6D7  2               LAB_167A
00C6D7  2  60                 RTS
00C6D8  2               
00C6D8  2               ; perform CONT
00C6D8  2               
00C6D8  2               LAB_CONT
00C6D8  2  D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
00C6DA  2               
00C6DA  2  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
00C6DC  2  C0 02              CPY   #>Ibuffs          ; *** fix p2: test direct mode
00C6DE  2  D0 05              BNE   LAB_166C          ; go do continue if we can
00C6E0  2               
00C6E0  2  A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
00C6E2  2  4C 49 C1           JMP   LAB_XERR          ; do error #X, then warm start
00C6E5  2               
00C6E5  2                                             ; we can continue so ..
00C6E5  2               LAB_166C
00C6E5  2  A9 93              LDA   #TK_ON            ; set token for ON
00C6E7  2  20 11 E3           JSR   LAB_IRQ           ; set IRQ flags
00C6EA  2  A9 93              LDA   #TK_ON            ; set token for ON
00C6EC  2  20 14 E3           JSR   LAB_NMI           ; set NMI flags
00C6EF  2               
00C6EF  2  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
00C6F1  2  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
00C6F3  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C6F5  2  A5 89              LDA   Blinel            ; get break line low byte
00C6F7  2  A4 8A              LDY   Blineh            ; get break line high byte
00C6F9  2  85 87              STA   Clinel            ; set current line low byte
00C6FB  2  84 88              STY   Clineh            ; set current line high byte
00C6FD  2  60                 RTS
00C6FE  2               
00C6FE  2               ; perform RUN
00C6FE  2               
00C6FE  2               LAB_RUN
00C6FE  2  D0 03              BNE   LAB_1696          ; branch if RUN n
00C700  2  4C CB C3           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack and
00C703  2                                             ; return
00C703  2               
00C703  2               ; does RUN n
00C703  2               
00C703  2               LAB_1696
00C703  2  20 D8 C3           JSR   LAB_147A          ; go do "CLEAR"
00C706  2  F0 2E              BEQ   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
00C708  2               
00C708  2               ; perform DO
00C708  2               
00C708  2               LAB_DO
00C708  2  A9 05              LDA   #$05              ; need 5 bytes for DO
00C70A  2  20 0D C1           JSR   LAB_1212          ; check room on stack for A bytes
00C70D  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00C70F  2  48                 PHA                     ; push on stack
00C710  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00C712  2  48                 PHA                     ; push on stack
00C713  2  A5 88              LDA   Clineh            ; get current line high byte
00C715  2  48                 PHA                     ; push on stack
00C716  2  A5 87              LDA   Clinel            ; get current line low byte
00C718  2  48                 PHA                     ; push on stack
00C719  2  A9 9D              LDA   #TK_DO            ; token for DO
00C71B  2  48                 PHA                     ; push on stack
00C71C  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C71F  2  4C 60 C5           JMP   LAB_15C2          ; go do interpreter inner loop
00C722  2               
00C722  2               ; perform GOSUB
00C722  2               
00C722  2               LAB_GOSUB
00C722  2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
00C724  2  20 0D C1           JSR   LAB_1212          ; check room on stack for A bytes
00C727  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00C729  2  48                 PHA                     ; push on stack
00C72A  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00C72C  2  48                 PHA                     ; push on stack
00C72D  2  A5 88              LDA   Clineh            ; get current line high byte
00C72F  2  48                 PHA                     ; push on stack
00C730  2  A5 87              LDA   Clinel            ; get current line low byte
00C732  2  48                 PHA                     ; push on stack
00C733  2  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
00C735  2  48                 PHA                     ; push on stack
00C736  2               LAB_16B0
00C736  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C739  2  20 3F C7           JSR   LAB_GOTO          ; perform GOTO n
00C73C  2  4C 60 C5           JMP   LAB_15C2          ; go do interpreter inner loop
00C73F  2                                             ; (can't RTS, we used the stack!)
00C73F  2               
00C73F  2               ; perform GOTO
00C73F  2               
00C73F  2               LAB_GOTO
00C73F  2  20 AC C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00C742  2  20 F4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
00C745  2  A5 88              LDA   Clineh            ; get current line high byte
00C747  2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
00C749  2  B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
00C74B  2               
00C74B  2  98                 TYA                     ; else copy line index to A
00C74C  2  38                 SEC                     ; set carry (+1)
00C74D  2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00C74F  2  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
00C751  2  90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
00C753  2               
00C753  2  E8                 INX                     ; increment high byte
00C754  2  B0 04              BCS   LAB_16D4          ; branch always (can never be carry)
00C756  2               
00C756  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
00C756  2               
00C756  2               LAB_16D0
00C756  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C758  2  A6 7A              LDX   Smemh             ; get start of mem high byte
00C75A  2               
00C75A  2               ; search for line # in temp (Itempl/Itemph) from (AX)
00C75A  2               
00C75A  2               LAB_16D4
00C75A  2  20 8E C3           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
00C75D  2  90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
00C75F  2                                             ; (unspecified statement)
00C75F  2               
00C75F  2                                             ; carry already set for subtract
00C75F  2  A5 AA              LDA   Baslnl            ; get pointer low byte
00C761  2  E9 01              SBC   #$01              ; -1
00C763  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C765  2  A5 AB              LDA   Baslnh            ; get pointer high byte
00C767  2  E9 00              SBC   #$00              ; subtract carry
00C769  2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00C76B  2               LAB_16E5
00C76B  2  60                 RTS
00C76C  2               
00C76C  2               LAB_DONOK
00C76C  2  A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
00C76E  2  4C 49 C1           JMP   LAB_XERR          ; do error #X, then warm start
00C771  2               
00C771  2               ; perform LOOP
00C771  2               
00C771  2               LAB_LOOP
00C771  2  A8                 TAY                     ; save following token
00C772  2  BA                 TSX                     ; copy stack pointer
00C773  2  BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
00C776  2  C9 9D              CMP   #TK_DO            ; compare with DO token
00C778  2  D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
00C77A  2               
00C77A  2  E8                 INX                     ; dump calling routine return address
00C77B  2  E8                 INX                     ; dump calling routine return address
00C77C  2  9A                 TXS                     ; correct stack
00C77D  2  98                 TYA                     ; get saved following token back
00C77E  2  F0 20              BEQ   LoopAlways        ; if no following token loop forever
00C780  2                                             ; (stack pointer in X)
00C780  2               
00C780  2  C9 3A              CMP   #':'              ; could be ':'
00C782  2  F0 1C              BEQ   LoopAlways        ; if :... loop forever
00C784  2               
00C784  2  E9 C9              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
00C786  2  AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
00C787  2  F0 04              BEQ   DoRest            ; branch if was UNTIL
00C789  2               
00C789  2  CA                 DEX                     ; decrement result
00C78A  2  D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
00C78C  2                                             ; only if the token was WHILE will this fail
00C78C  2               
00C78C  2  CA                 DEX                     ; set invert result byte
00C78D  2               DoRest
00C78D  2  86 98              STX   Frnxth            ; save invert result byte
00C78F  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C792  2  20 29 CC           JSR   LAB_EVEX          ; evaluate expression
00C795  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00C797  2  F0 02              BEQ   DoCmp             ; if =0 go do straight compare
00C799  2               
00C799  2  A9 FF              LDA   #$FF              ; else set all bits
00C79B  2               DoCmp
00C79B  2  BA                 TSX                     ; copy stack pointer
00C79C  2  45 98              EOR   Frnxth            ; EOR with invert byte
00C79E  2  D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
00C7A0  2               
00C7A0  2                                             ; loop condition wasn't met so do it again
00C7A0  2               LoopAlways
00C7A0  2  BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
00C7A3  2  85 87              STA   Clinel            ; save current line low byte
00C7A5  2  BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
00C7A8  2  85 88              STA   Clineh            ; save current line high byte
00C7AA  2  BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
00C7AD  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C7AF  2  BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
00C7B2  2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00C7B4  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C7B7  2  4C 60 C5           JMP   LAB_15C2          ; go do interpreter inner loop
00C7BA  2               
00C7BA  2                                             ; clear stack and back to interpreter loop
00C7BA  2               LoopDone
00C7BA  2  E8                 INX                     ; dump DO token
00C7BB  2  E8                 INX                     ; dump current line low byte
00C7BC  2  E8                 INX                     ; dump current line high byte
00C7BD  2  E8                 INX                     ; dump BASIC execute pointer low byte
00C7BE  2  E8                 INX                     ; dump BASIC execute pointer high byte
00C7BF  2  9A                 TXS                     ; correct stack
00C7C0  2  4C E0 C7           JMP   LAB_DATA          ; go perform DATA (find : or [EOL])
00C7C3  2               
00C7C3  2               ; do the return without gosub error
00C7C3  2               
00C7C3  2               LAB_16F4
00C7C3  2  A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
00C7C5  2  2C                 .byte $2C               ; makes next line BIT LAB_0EA2
00C7C6  2               
00C7C6  2               LAB_16F7                      ; do undefined statement error
00C7C6  2  A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
00C7C8  2  4C 49 C1           JMP   LAB_XERR          ; do error #X, then warm start
00C7CB  2               
00C7CB  2               ; perform RETURN
00C7CB  2               
00C7CB  2               LAB_RETURN
00C7CB  2  D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
00C7CD  2               
00C7CD  2               LAB_16E8
00C7CD  2  68                 PLA                     ; dump calling routine return address
00C7CE  2  68                 PLA                     ; dump calling routine return address
00C7CF  2  68                 PLA                     ; pull token
00C7D0  2  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
00C7D2  2  D0 EF              BNE   LAB_16F4          ; branch if no matching GOSUB
00C7D4  2               
00C7D4  2               LAB_16FF
00C7D4  2  68                 PLA                     ; pull current line low byte
00C7D5  2  85 87              STA   Clinel            ; save current line low byte
00C7D7  2  68                 PLA                     ; pull current line high byte
00C7D8  2  85 88              STA   Clineh            ; save current line high byte
00C7DA  2  68                 PLA                     ; pull BASIC execute pointer low byte
00C7DB  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C7DD  2  68                 PLA                     ; pull BASIC execute pointer high byte
00C7DE  2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00C7E0  2               
00C7E0  2                                             ; now do the DATA statement as we could be returning into
00C7E0  2                                             ; the middle of an ON <var> GOSUB n,m,p,q line
00C7E0  2                                             ; (the return address used by the DATA statement is the one
00C7E0  2                                             ; pushed before the GOSUB was executed!)
00C7E0  2               
00C7E0  2               ; perform DATA
00C7E0  2               
00C7E0  2               LAB_DATA
00C7E0  2  20 F1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
00C7E3  2               
00C7E3  2                                             ; set BASIC execute pointer
00C7E3  2               LAB_170F
00C7E3  2  98                 TYA                     ; copy index to A
00C7E4  2  18                 CLC                     ; clear carry for add
00C7E5  2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00C7E7  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C7E9  2  90 02              BCC   LAB_1719          ; skip next if no carry
00C7EB  2               
00C7EB  2  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
00C7ED  2               LAB_1719
00C7ED  2  60                 RTS
00C7EE  2               
00C7EE  2               LAB_16FC
00C7EE  2  4C 51 CD           JMP   LAB_SNER          ; do syntax error then warm start
00C7F1  2               
00C7F1  2               ; scan for next BASIC statement ([:] or [EOL])
00C7F1  2               ; returns Y as index to [:] or [EOL]
00C7F1  2               
00C7F1  2               LAB_SNBS
00C7F1  2  A2 3A              LDX   #':'              ; set look for character = ":"
00C7F3  2  2C                 .byte $2C               ; makes next line BIT $00A2
00C7F4  2               
00C7F4  2               ; scan for next BASIC line
00C7F4  2               ; returns Y as index to [EOL]
00C7F4  2               
00C7F4  2               LAB_SNBL
00C7F4  2  A2 00              LDX   #$00              ; set alt search character = [EOL]
00C7F6  2  A0 00              LDY   #$00              ; set search character = [EOL]
00C7F8  2  84 5C              STY   Asrch             ; store search character
00C7FA  2               LAB_1725
00C7FA  2  8A                 TXA                     ; get alt search character
00C7FB  2  45 5C              EOR   Asrch             ; toggle search character, effectively swap with $00
00C7FD  2  85 5C              STA   Asrch             ; save swapped search character
00C7FF  2               LAB_172D
00C7FF  2  B1 C3              LDA   (Bpntrl),Y        ; get next byte
00C801  2  F0 EA              BEQ   LAB_1719          ; exit if null [EOL]
00C803  2               
00C803  2  C5 5C              CMP   Asrch             ; compare with search character
00C805  2  F0 E6              BEQ   LAB_1719          ; exit if found
00C807  2               
00C807  2  C8                 INY                     ; increment index
00C808  2  C9 22              CMP   #$22              ; compare current character with open quote
00C80A  2  D0 F3              BNE   LAB_172D          ; if not open quote go get next character
00C80C  2               
00C80C  2  F0 EC              BEQ   LAB_1725          ; if found go swap search character for alt search character
00C80E  2               
00C80E  2               ; perform IF
00C80E  2               
00C80E  2               LAB_IF
00C80E  2  20 29 CC           JSR   LAB_EVEX          ; evaluate the expression
00C811  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C814  2  C9 C6              CMP   #TK_THEN          ; compare with THEN token
00C816  2  F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
00C818  2               
00C818  2                                             ; wasn't IF .. THEN so must be IF .. GOTO
00C818  2  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
00C81A  2  D0 D2              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
00C81C  2               
00C81C  2  A6 C3              LDX   Bpntrl            ; save the basic pointer low byte
00C81E  2  A4 C4              LDY   Bpntrh            ; save the basic pointer high byte
00C820  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C823  2  B0 C9              BCS   LAB_16FC          ; if not numeric go do syntax error
00C825  2               
00C825  2  86 C3              STX   Bpntrl            ; restore the basic pointer low byte
00C827  2  84 C4              STY   Bpntrh            ; restore the basic pointer high byte
00C829  2               LAB_174B
00C829  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00C82B  2  F0 1E              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
00C82D  2               
00C82D  2  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
00C830  2  B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
00C832  2               
00C832  2               LAB_174C
00C832  2  4C 3F C7           JMP   LAB_GOTO          ; else was numeric so do GOTO n
00C835  2               
00C835  2                                             ; is var or keyword
00C835  2               LAB_174D
00C835  2               ; *** patch       allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
00C835  2               ; *** replace
00C835  2               ;      CMP   #TK_RETURN        ; compare the byte with the token for RETURN
00C835  2               ;      BNE   LAB_174G          ; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
00C835  2               ;                              ; and return to this code to process any following code
00C835  2               ;
00C835  2               ;      JMP   LAB_1602          ; else it was RETURN so interpret BASIC code from (Bpntrl)
00C835  2               ;                              ; but don't return here
00C835  2               ;
00C835  2               ;LAB_174G
00C835  2               ;      JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
00C835  2               ;
00C835  2               ;; the IF was executed and there may be a following ELSE so the code needs to return
00C835  2               ;; here to check and ignore the ELSE if present
00C835  2               ;
00C835  2               ;      LDY   #$00              ; clear the index
00C835  2               ;      LDA   (Bpntrl),Y        ; get the next BASIC byte
00C835  2               ;      CMP   #TK_ELSE          ; compare it with the token for ELSE
00C835  2               ;      BEQ   LAB_DATA          ; if ELSE ignore the following statement
00C835  2               ;
00C835  2               ;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00C835  2               ;; following ELSE will, correctly, cause a syntax error
00C835  2               ;
00C835  2               ;      RTS                     ; else return to the interpreter inner loop
00C835  2               ;
00C835  2               ; *** with
00C835  2  68                 PLA                     ; discard interpreter loop return address
00C836  2  68                 PLA                     ; so data structures are at the correct stack offset
00C837  2  20 C2 00           JSR   LAB_GBYT          ; restore token or variable
00C83A  2  20 A1 C5           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
00C83D  2               
00C83D  2               ; the IF was executed and there may be a following ELSE so the code needs to return
00C83D  2               ; here to check and ignore the ELSE if present
00C83D  2               
00C83D  2  A0 00              LDY   #$00              ; clear the index
00C83F  2  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
00C841  2  C9 C2              CMP   #TK_ELSE          ; compare it with the token for ELSE
00C843  2  D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
00C845  2  20 E0 C7           JSR   LAB_DATA          ; yes - skip the rest of the line
00C848  2               
00C848  2               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00C848  2               ; following ELSE will, correctly, cause a syntax error
00C848  2               
00C848  2               LAB_no_ELSE
00C848  2  4C 60 C5           JMP LAB_15C2            ; return to the interpreter inner loop
00C84B  2               ; *** end patch  allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
00C84B  2               
00C84B  2               ; perform ELSE after IF
00C84B  2               
00C84B  2               LAB_174E
00C84B  2  A0 00              LDY   #$00              ; clear the BASIC byte index
00C84D  2  A2 01              LDX   #$01              ; clear the nesting depth
00C84F  2               LAB_1750
00C84F  2  C8                 INY                     ; increment the BASIC byte index
00C850  2  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
00C852  2  F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
00C854  2               
00C854  2  C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
00C856  2  D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
00C858  2               
00C858  2  E8                 INX                     ; else increment the nesting depth ..
00C859  2  D0 F4              BNE   LAB_1750          ; .. and continue looking
00C85B  2               
00C85B  2               LAB_1752
00C85B  2  C9 C2              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
00C85D  2  D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
00C85F  2               
00C85F  2  CA                 DEX                     ; was ELSE so decrement the nesting depth
00C860  2  D0 ED              BNE   LAB_1750          ; loop if still nested
00C862  2               
00C862  2  C8                 INY                     ; increment the BASIC byte index past the ELSE
00C863  2               
00C863  2               ; found the matching ELSE, now do <{n|statement}>
00C863  2               
00C863  2               LAB_1753
00C863  2  98                 TYA                     ; else copy line index to A
00C864  2  18                 CLC                     ; clear carry for add
00C865  2  65 C3              ADC   Bpntrl            ; add the BASIC execute pointer low byte
00C867  2  85 C3              STA   Bpntrl            ; save the BASIC execute pointer low byte
00C869  2  90 02              BCC   LAB_1754          ; branch if no overflow to high byte
00C86B  2               
00C86B  2  E6 C4              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
00C86D  2               LAB_1754
00C86D  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C870  2  90 C0              BCC   LAB_174C          ; if numeric do GOTO n
00C872  2                                             ; the code will return to the interpreter loop at the
00C872  2                                             ; tail end of the GOTO <n>
00C872  2               
00C872  2  4C A1 C5           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
00C875  2                                             ; the code will return to the interpreter loop at the
00C875  2                                             ; tail end of the <statement>
00C875  2               
00C875  2               ; perform REM, skip (rest of) line
00C875  2               
00C875  2               LAB_REM
00C875  2  20 F4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
00C878  2  4C E3 C7           JMP   LAB_170F          ; go set BASIC execute pointer and return, branch always
00C87B  2               
00C87B  2               LAB_16FD
00C87B  2  4C 51 CD           JMP   LAB_SNER          ; do syntax error then warm start
00C87E  2               
00C87E  2               ; perform ON
00C87E  2               
00C87E  2               LAB_ON
00C87E  2  C9 A9              CMP   #TK_IRQ           ; was it IRQ token ?
00C880  2  D0 03              BNE   LAB_NOIN          ; if not go check NMI
00C882  2               
00C882  2  4C 35 E3           JMP   LAB_SIRQ          ; else go set-up IRQ
00C885  2               
00C885  2               LAB_NOIN
00C885  2  C9 AA              CMP   #TK_NMI           ; was it NMI token ?
00C887  2  D0 03              BNE   LAB_NONM          ; if not go do normal ON command
00C889  2               
00C889  2  4C 39 E3           JMP   LAB_SNMI          ; else go set-up NMI
00C88C  2               
00C88C  2               LAB_NONM
00C88C  2  20 8F D7           JSR   LAB_GTBY          ; get byte parameter
00C88F  2  48                 PHA                     ; push GOTO/GOSUB token
00C890  2  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
00C892  2  F0 04              BEQ   LAB_176B          ; branch if GOSUB
00C894  2               
00C894  2  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
00C896  2               LAB_1767
00C896  2  D0 E3              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
00C898  2               
00C898  2               
00C898  2               ; next character was GOTO or GOSUB
00C898  2               
00C898  2               LAB_176B
00C898  2  C6 AF              DEC   FAC1_3            ; decrement index (byte value)
00C89A  2  D0 04              BNE   LAB_1773          ; branch if not zero
00C89C  2               
00C89C  2  68                 PLA                     ; pull GOTO/GOSUB token
00C89D  2  4C AA C5           JMP   LAB_1602          ; go execute it
00C8A0  2               
00C8A0  2               LAB_1773
00C8A0  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C8A3  2  20 AC C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
00C8A6  2                                             ; (we could LDX #',' and JSR LAB_SNBL+2, then we
00C8A6  2                                             ; just BNE LAB_176B for the loop. should be quicker ..
00C8A6  2                                             ; no we can't, what if we meet a colon or [EOL]?)
00C8A6  2  C9 2C              CMP   #$2C              ; compare next character with ","
00C8A8  2  F0 EE              BEQ   LAB_176B          ; loop if ","
00C8AA  2               
00C8AA  2               LAB_177E
00C8AA  2  68                 PLA                     ; else pull keyword token (run out of options)
00C8AB  2                                             ; also dump +/-1 pointer low byte and exit
00C8AB  2               LAB_177F
00C8AB  2  60                 RTS
00C8AC  2               
00C8AC  2               ; takes n * 106 + 11 cycles where n is the number of digits
00C8AC  2               
00C8AC  2               ; get fixed-point number into temp integer
00C8AC  2               
00C8AC  2               LAB_GFPN
00C8AC  2  A2 00              LDX   #$00              ; clear reg
00C8AE  2  86 11              STX   Itempl            ; clear temporary integer low byte
00C8B0  2               LAB_1785
00C8B0  2  86 12              STX   Itemph            ; save temporary integer high byte
00C8B2  2  B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
00C8B4  2                                             ; not 0-9
00C8B4  2               
00C8B4  2  E0 19              CPX   #$19              ; compare high byte with $19
00C8B6  2  A8                 TAY                     ; ensure Zb = 0 if the branch is taken
00C8B7  2  B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
00C8B9  2                                             ; bit does *$0A, = 64000, compare at target will fail
00C8B9  2                                             ; and do syntax error
00C8B9  2               
00C8B9  2  E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
00C8BB  2  A8                 TAY                     ; copy binary digit
00C8BC  2  A5 11              LDA   Itempl            ; get temporary integer low byte
00C8BE  2  0A                 ASL                     ; *2 low byte
00C8BF  2  26 12              ROL   Itemph            ; *2 high byte
00C8C1  2  0A                 ASL                     ; *2 low byte
00C8C2  2  26 12              ROL   Itemph            ; *2 high byte, *4
00C8C4  2  65 11              ADC   Itempl            ; + low byte, *5
00C8C6  2  85 11              STA   Itempl            ; save it
00C8C8  2  8A                 TXA                     ; get high byte copy to A
00C8C9  2  65 12              ADC   Itemph            ; + high byte, *5
00C8CB  2  06 11              ASL   Itempl            ; *2 low byte, *10d
00C8CD  2  2A                 ROL                     ; *2 high byte, *10d
00C8CE  2  AA                 TAX                     ; copy high byte back to X
00C8CF  2  98                 TYA                     ; get binary digit back
00C8D0  2  65 11              ADC   Itempl            ; add number low byte
00C8D2  2  85 11              STA   Itempl            ; save number low byte
00C8D4  2  90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
00C8D6  2               
00C8D6  2  E8                 INX                     ; else increment high byte
00C8D7  2               LAB_17B3
00C8D7  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C8DA  2  4C B0 C8           JMP   LAB_1785          ; loop for next character
00C8DD  2               
00C8DD  2               ; perform DEC
00C8DD  2               
00C8DD  2               LAB_DEC
00C8DD  2  A9 59              LDA   #<LAB_2AFD        ; set -1 pointer low byte
00C8DF  2  2C                 .byte $2C               ; BIT abs to skip the LDA below
00C8E0  2               
00C8E0  2               ; perform INC
00C8E0  2               
00C8E0  2               LAB_INC
00C8E0  2  A9 55              LDA   #<LAB_259C        ; set 1 pointer low byte
00C8E2  2               LAB_17B5
00C8E2  2  48                 PHA                     ; save +/-1 pointer low byte
00C8E3  2               LAB_17B7
00C8E3  2  20 95 D0           JSR   LAB_GVAR          ; get var address
00C8E6  2  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
00C8E8  2  30 1E              BMI   IncrErr           ; exit if string
00C8EA  2               
00C8EA  2  85 97              STA   Lvarpl            ; save var address low byte
00C8EC  2  84 98              STY   Lvarph            ; save var address high byte
00C8EE  2  20 87 DB           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00C8F1  2  68                 PLA                     ; get +/-1 pointer low byte
00C8F2  2  48                 PHA                     ; save +/-1 pointer low byte
00C8F3  2  A0 F7              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
00C8F5  2  20 C8 D8           JSR   LAB_246C          ; add (AY) to FAC1
00C8F8  2  20 AD DB           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
00C8FB  2               
00C8FB  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C8FE  2  C9 2C              CMP   #','              ; compare with ","
00C900  2  D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
00C902  2               
00C902  2                                             ; was "," so another INCR variable to do
00C902  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C905  2  4C E3 C8           JMP   LAB_17B7          ; go do next var
00C908  2               
00C908  2               IncrErr
00C908  2  4C 24 CC           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
00C90B  2               
00C90B  2               ; perform LET
00C90B  2               
00C90B  2               LAB_LET
00C90B  2  20 95 D0           JSR   LAB_GVAR          ; get var address
00C90E  2  85 97              STA   Lvarpl            ; save var address low byte
00C910  2  84 98              STY   Lvarph            ; save var address high byte
00C912  2  A9 D7              LDA   #TK_EQUAL         ; get = token
00C914  2  20 40 CD           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00C917  2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
00C919  2  48                 PHA                     ; push data type flag
00C91A  2  20 29 CC           JSR   LAB_EVEX          ; evaluate expression
00C91D  2  68                 PLA                     ; pop data type flag
00C91E  2  2A                 ROL                     ; set carry if type = string
00C91F  2               ; *** begin patch  result of a string compare stores string pointer to variable
00C91F  2               ;                  but should store FAC1 (true/false value)
00C91F  2               ; *** replace
00C91F  2               ;      JSR   LAB_CKTM          ; type match check, set C for string
00C91F  2               ;      BNE   LAB_17D5          ; branch if string
00C91F  2               ; *** with
00C91F  2  20 1B CC           JSR   LAB_CKTM          ; type match check, keep C (expected type)
00C922  2  B0 03              BCS   LAB_17D5          ; branch if string
00C924  2               ; *** end patch
00C924  2               
00C924  2  4C AD DB           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
00C927  2               
00C927  2               ; string LET
00C927  2               
00C927  2               LAB_17D5
00C927  2  A0 02              LDY   #$02              ; set index to pointer high byte
00C929  2  B1 AE              LDA   (des_pl),Y        ; get string pointer high byte
00C92B  2  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
00C92D  2  90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
00C92F  2               
00C92F  2  D0 07              BNE   LAB_17E6          ; branch if >
00C931  2                                             ; else was equal so compare low bytes
00C931  2  88                 DEY                     ; decrement index
00C932  2  B1 AE              LDA   (des_pl),Y        ; get pointer low byte
00C934  2  C5 81              CMP   Sstorl            ; compare bottom of string space low byte
00C936  2  90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
00C938  2               
00C938  2                                             ; pointer was >= to bottom of string space pointer
00C938  2               LAB_17E6
00C938  2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
00C93A  2  C4 7C              CPY   Svarh             ; compare start of vars high byte
00C93C  2  90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
00C93E  2               
00C93E  2  D0 0D              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
00C940  2               
00C940  2                                             ; else high bytes were equal so ..
00C940  2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
00C942  2  C5 7B              CMP   Svarl             ; compare start of vars low byte
00C944  2  B0 07              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
00C946  2               
00C946  2               LAB_17F4
00C946  2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
00C948  2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
00C94A  2  4C 63 C9           JMP   LAB_1811          ; clean stack, copy descriptor to variable and return
00C94D  2               
00C94D  2                                             ; make space and copy string
00C94D  2               LAB_17FB
00C94D  2  A0 00              LDY   #$00              ; index to length
00C94F  2  B1 AE              LDA   (des_pl),Y        ; get string length
00C951  2  20 1D D4           JSR   LAB_209C          ; copy string
00C954  2  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
00C956  2  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
00C958  2  85 B8              STA   ssptr_l           ; save descriptor pointer low byte
00C95A  2  84 B9              STY   ssptr_h           ; save descriptor pointer high byte
00C95C  2  20 02 D6           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
00C95F  2  A9 AC              LDA   #<FAC1_e          ; set descriptor pointer low byte
00C961  2  A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
00C963  2               
00C963  2                                             ; clean stack and assign value to string variable
00C963  2               LAB_1811
00C963  2  85 9E              STA   des_2l            ; save descriptor_2 pointer low byte
00C965  2  84 9F              STY   des_2h            ; save descriptor_2 pointer high byte
00C967  2  20 64 D6           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
00C96A  2  A0 00              LDY   #$00              ; index to length
00C96C  2  B1 9E              LDA   (des_2l),Y        ; get string length
00C96E  2  91 97              STA   (Lvarpl),Y        ; copy to let string variable
00C970  2  C8                 INY                     ; index to string pointer low byte
00C971  2  B1 9E              LDA   (des_2l),Y        ; get string pointer low byte
00C973  2  91 97              STA   (Lvarpl),Y        ; copy to let string variable
00C975  2  C8                 INY                     ; index to string pointer high byte
00C976  2  B1 9E              LDA   (des_2l),Y        ; get string pointer high byte
00C978  2  91 97              STA   (Lvarpl),Y        ; copy to let string variable
00C97A  2  60                 RTS
00C97B  2               
00C97B  2               ; perform GET
00C97B  2               
00C97B  2               LAB_GET
00C97B  2  20 95 D0           JSR   LAB_GVAR          ; get var address
00C97E  2  85 97              STA   Lvarpl            ; save var address low byte
00C980  2  84 98              STY   Lvarph            ; save var address high byte
00C982  2  20 FD E2           JSR   INGET             ; get input byte
00C985  2  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
00C987  2  30 07              BMI   LAB_GETS          ; go get string character
00C989  2               
00C989  2                                             ; was numeric get
00C989  2  A8                 TAY                     ; copy character to Y
00C98A  2  20 51 D3           JSR   LAB_1FD0          ; convert Y to byte in FAC1
00C98D  2  4C AD DB           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
00C990  2               
00C990  2               LAB_GETS
00C990  2  48                 PHA                     ; save character
00C991  2  A9 01              LDA   #$01              ; string is single byte
00C993  2  B0 01              BCS   LAB_IsByte        ; branch if byte received
00C995  2               
00C995  2  68                 PLA                     ; string is null
00C996  2               LAB_IsByte
00C996  2  20 25 D4           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
00C999  2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00C999  2  F0 05              BEQ   LAB_NoSt          ; skip store if null string
00C99B  2               
00C99B  2  68                 PLA                     ; get character back
00C99C  2  A0 00              LDY   #$00              ; clear index
00C99E  2  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
00C9A0  2               LAB_NoSt
00C9A0  2  20 72 D4           JSR   LAB_RTST          ; check for space on descriptor stack then put address
00C9A3  2                                             ; and length on descriptor stack and update stack pointers
00C9A3  2               
00C9A3  2  4C 27 C9           JMP   LAB_17D5          ; do string LET and return
00C9A6  2               
00C9A6  2               ; perform PRINT
00C9A6  2               
00C9A6  2               LAB_1829
00C9A6  2  20 2D CA           JSR   LAB_18C6          ; print string from Sutill/Sutilh
00C9A9  2               LAB_182C
00C9A9  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C9AC  2               
00C9AC  2               ; PRINT
00C9AC  2               
00C9AC  2               LAB_PRINT
00C9AC  2  F0 3B              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
00C9AE  2               
00C9AE  2               LAB_1831
00C9AE  2  C9 C1              CMP   #TK_TAB           ; compare with TAB( token
00C9B0  2  F0 56              BEQ   LAB_18A2          ; go do TAB/SPC
00C9B2  2               
00C9B2  2  C9 C5              CMP   #TK_SPC           ; compare with SPC( token
00C9B4  2  F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
00C9B6  2               
00C9B6  2  C9 2C              CMP   #','              ; compare with ","
00C9B8  2  F0 38              BEQ   LAB_188B          ; go do move to next TAB mark
00C9BA  2               
00C9BA  2  C9 3B              CMP   #';'              ; compare with ";"
00C9BC  2  F0 66              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
00C9BE  2               
00C9BE  2  20 29 CC           JSR   LAB_EVEX          ; evaluate expression
00C9C1  2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
00C9C3  2  30 E1              BMI   LAB_1829          ; branch if string
00C9C5  2               
00C9C5  2  20 9F DD           JSR   LAB_296E          ; convert FAC1 to string
00C9C8  2  20 2F D4           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
00C9CB  2  A0 00              LDY   #$00              ; clear index
00C9CD  2               
00C9CD  2               ; don't check fit if terminal width byte is zero
00C9CD  2               
00C9CD  2  A5 0F              LDA   TWidth            ; get terminal width byte
00C9CF  2  F0 0A              BEQ   LAB_185E          ; skip check if zero
00C9D1  2               
00C9D1  2  38                 SEC                     ; set carry for subtract
00C9D2  2  E5 0E              SBC   TPos              ; subtract terminal position
00C9D4  2  F1 AE              SBC   (des_pl),Y        ; subtract string length
00C9D6  2  B0 03              BCS   LAB_185E          ; branch if less than terminal width
00C9D8  2               
00C9D8  2  20 E9 C9           JSR   LAB_CRLF          ; else print CR/LF
00C9DB  2               LAB_185E
00C9DB  2  20 2D CA           JSR   LAB_18C6          ; print string from Sutill/Sutilh
00C9DE  2  F0 C9              BEQ   LAB_182C          ; always go continue processing line
00C9E0  2               
00C9E0  2               ; CR/LF return to BASIC from BASIC input handler
00C9E0  2               
00C9E0  2               LAB_1866
00C9E0  2  A9 00              LDA   #$00              ; clear byte
00C9E2  2  9D 21 02           STA   Ibuffs,X          ; null terminate input
00C9E5  2  A2 21              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
00C9E7  2  A0 02              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
00C9E9  2               
00C9E9  2               ; print CR/LF
00C9E9  2               
00C9E9  2               LAB_CRLF
00C9E9  2  A9 0D              LDA   #$0D              ; load [CR]
00C9EB  2  20 44 CA           JSR   LAB_PRNA          ; go print the character
00C9EE  2  A9 0A              LDA   #$0A              ; load [LF]
00C9F0  2  D0 52              BNE   LAB_PRNA          ; go print the character and return, branch always
00C9F2  2               
00C9F2  2               LAB_188B
00C9F2  2  A5 0E              LDA   TPos              ; get terminal position
00C9F4  2  C5 10              CMP   Iclim             ; compare with input column limit
00C9F6  2  90 05              BCC   LAB_1897          ; branch if less
00C9F8  2               
00C9F8  2  20 E9 C9           JSR   LAB_CRLF          ; else print CR/LF (next line)
00C9FB  2  D0 27              BNE   LAB_18BD          ; continue with PRINT processing (branch always)
00C9FD  2               
00C9FD  2               LAB_1897
00C9FD  2  38                 SEC                     ; set carry for subtract
00C9FE  2               LAB_1898
00C9FE  2  E5 64              SBC   TabSiz            ; subtract TAB size
00CA00  2  B0 FC              BCS   LAB_1898          ; loop if result was +ve
00CA02  2               
00CA02  2  49 FF              EOR   #$FF              ; complement it
00CA04  2  69 01              ADC   #$01              ; +1 (twos complement)
00CA06  2  D0 12              BNE   LAB_18B6          ; always print A spaces (result is never $00)
00CA08  2               
00CA08  2                                             ; do TAB/SPC
00CA08  2               LAB_18A2
00CA08  2  48                 PHA                     ; save token
00CA09  2  20 7A D7           JSR   LAB_SGBY          ; scan and get byte parameter
00CA0C  2  C9 29              CMP   #$29              ; is next character )
00CA0E  2  D0 6D              BNE   LAB_1910          ; if not do syntax error then warm start
00CA10  2               
00CA10  2  68                 PLA                     ; get token back
00CA11  2  C9 C1              CMP   #TK_TAB           ; was it TAB ?
00CA13  2  D0 06              BNE   LAB_18B7          ; if not go do SPC
00CA15  2               
00CA15  2                                             ; calculate TAB offset
00CA15  2  8A                 TXA                     ; copy integer value to A
00CA16  2  E5 0E              SBC   TPos              ; subtract terminal position
00CA18  2  90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
00CA1A  2               
00CA1A  2                                             ; print A spaces
00CA1A  2               LAB_18B6
00CA1A  2  AA                 TAX                     ; copy result to X
00CA1B  2               LAB_18B7
00CA1B  2  8A                 TXA                     ; set flags on size for SPC
00CA1C  2  F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
00CA1E  2               
00CA1E  2                                             ; print X spaces
00CA1E  2               LAB_18BA
00CA1E  2  20 3F CA           JSR   LAB_18E0          ; print " "
00CA21  2  CA                 DEX                     ; decrement count
00CA22  2  D0 FA              BNE   LAB_18BA          ; loop if not all done
00CA24  2               
00CA24  2                                             ; continue with PRINT processing
00CA24  2               LAB_18BD
00CA24  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00CA27  2  D0 85              BNE   LAB_1831          ; if more to print go do it
00CA29  2               
00CA29  2  60                 RTS
00CA2A  2               
00CA2A  2               ; print null terminated string from memory
00CA2A  2               
00CA2A  2               LAB_18C3
00CA2A  2  20 2F D4           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
00CA2D  2               
00CA2D  2               ; print string from Sutill/Sutilh
00CA2D  2               
00CA2D  2               LAB_18C6
00CA2D  2  20 2F D6           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
00CA30  2                                             ; space returns with A = length, X=$71=pointer low byte,
00CA30  2                                             ; Y=$72=pointer high byte
00CA30  2  A0 00              LDY   #$00              ; reset index
00CA32  2  AA                 TAX                     ; copy length to X
00CA33  2  F0 3B              BEQ   LAB_188C          ; exit (RTS) if null string
00CA35  2               
00CA35  2               LAB_18CD
00CA35  2               
00CA35  2  B1 71              LDA   (ut1_pl),Y        ; get next byte
00CA37  2  20 44 CA           JSR   LAB_PRNA          ; go print the character
00CA3A  2  C8                 INY                     ; increment index
00CA3B  2  CA                 DEX                     ; decrement count
00CA3C  2  D0 F7              BNE   LAB_18CD          ; loop if not done yet
00CA3E  2               
00CA3E  2  60                 RTS
00CA3F  2               
00CA3F  2                                             ; Print single format character
00CA3F  2               ; print " "
00CA3F  2               
00CA3F  2               LAB_18E0
00CA3F  2  A9 20              LDA   #$20              ; load " "
00CA41  2  2C                 .byte $2C               ; change next line to BIT LAB_3FA9
00CA42  2               
00CA42  2               ; print "?" character
00CA42  2               
00CA42  2               LAB_18E3
00CA42  2  A9 3F              LDA   #$3F              ; load "?" character
00CA44  2               
00CA44  2               ; print character in A
00CA44  2               ; now includes the null handler
00CA44  2               ; also includes infinite line length code
00CA44  2               ; note! some routines expect this one to exit with Zb=0
00CA44  2               
00CA44  2               LAB_PRNA
00CA44  2  C9 20              CMP   #' '              ; compare with " "
00CA46  2  90 19              BCC   LAB_18F9          ; branch if less (non printing)
00CA48  2               
00CA48  2                                             ; else printable character
00CA48  2  48                 PHA                     ; save the character
00CA49  2               
00CA49  2               ; don't check fit if terminal width byte is zero
00CA49  2               
00CA49  2  A5 0F              LDA   TWidth            ; get terminal width
00CA4B  2  D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
00CA4D  2               
00CA4D  2               ; is "infinite line" so check TAB position
00CA4D  2               
00CA4D  2  A5 0E              LDA   TPos              ; get position
00CA4F  2  E5 64              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
00CA51  2  D0 0B              BNE   LAB_18F7          ; skip reset if different
00CA53  2               
00CA53  2  85 0E              STA   TPos              ; else reset position
00CA55  2  F0 07              BEQ   LAB_18F7          ; go print character
00CA57  2               
00CA57  2               LAB_18F0
00CA57  2  C5 0E              CMP   TPos              ; compare with terminal character position
00CA59  2  D0 03              BNE   LAB_18F7          ; branch if not at end of line
00CA5B  2               
00CA5B  2  20 E9 C9           JSR   LAB_CRLF          ; else print CR/LF
00CA5E  2               LAB_18F7
00CA5E  2  E6 0E              INC   TPos              ; increment terminal position
00CA60  2  68                 PLA                     ; get character back
00CA61  2               LAB_18F9
00CA61  2  20 B6 E6           JSR   V_OUTP            ; output byte via output vector
00CA64  2  C9 0D              CMP   #$0D              ; compare with [CR]
00CA66  2  D0 06              BNE   LAB_188A          ; branch if not [CR]
00CA68  2               
00CA68  2                                             ; clear terminal position after [CR]
00CA68  2  48                 PHA
00CA69  2  A9 00              LDA   #$00
00CA6B  2  85 0E              STA   TPos              ; clear terminal position
00CA6D  2  68                 PLA
00CA6E  2               LAB_188A
00CA6E  2  29 FF              AND   #$FF              ; set the flags
00CA70  2               LAB_188C
00CA70  2  60                 RTS
00CA71  2               
00CA71  2               ; handle bad input data
00CA71  2               
00CA71  2               LAB_1904
00CA71  2  A5 62              LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
00CA73  2  10 0B              BPL   LAB_1913          ; branch if INPUT (go do redo)
00CA75  2               
00CA75  2  A5 8D              LDA   Dlinel            ; get current DATA line low byte
00CA77  2  A4 8E              LDY   Dlineh            ; get current DATA line high byte
00CA79  2  85 87              STA   Clinel            ; save current line low byte
00CA7B  2  84 88              STY   Clineh            ; save current line high byte
00CA7D  2               LAB_1910
00CA7D  2  4C 51 CD           JMP   LAB_SNER          ; do syntax error then warm start
00CA80  2               
00CA80  2                                             ; mode was INPUT
00CA80  2               LAB_1913
00CA80  2  A9 CB              LDA   #<LAB_REDO        ; point to redo message (low addr)
00CA82  2  A0 FE              LDY   #>LAB_REDO        ; point to redo message (high addr)
00CA84  2  20 2A CA           JSR   LAB_18C3          ; print null terminated string from memory
00CA87  2  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
00CA89  2  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
00CA8B  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00CA8D  2  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
00CA8F  2  60                 RTS
00CA90  2               
00CA90  2               ; perform INPUT
00CA90  2               
00CA90  2               LAB_INPUT
00CA90  2  C9 22              CMP   #$22              ; compare next byte with open quote
00CA92  2  D0 0B              BNE   LAB_1934          ; branch if no prompt string
00CA94  2               
00CA94  2  20 06 CD           JSR   LAB_1BC1          ; print "..." string
00CA97  2  A9 3B              LDA   #$3B              ; load A with ";"
00CA99  2  20 40 CD           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00CA9C  2  20 2D CA           JSR   LAB_18C6          ; print string from Sutill/Sutilh
00CA9F  2               
00CA9F  2                                             ; done with prompt, now get data
00CA9F  2               LAB_1934
00CA9F  2  20 55 D3           JSR   LAB_CKRN          ; check not Direct, back here if ok
00CAA2  2  20 4D C2           JSR   LAB_INLN          ; print "? " and get BASIC input
00CAA5  2  A9 00              LDA   #$00              ; set mode = INPUT
00CAA7  2  CD 21 02           CMP   Ibuffs            ; test first byte in buffer
00CAAA  2  D0 09              BNE   LAB_1953          ; branch if not null input
00CAAC  2               
00CAAC  2               ; *** change p2: keep carry set to throw break message
00CAAC  2               ;      CLC                     ; was null input so clear carry to exit program
00CAAC  2  4C 80 C6           JMP   LAB_1647          ; go do BREAK exit
00CAAF  2               
00CAAF  2               ; perform READ
00CAAF  2               
00CAAF  2               LAB_READ
00CAAF  2  A6 8F              LDX   Dptrl             ; get DATA pointer low byte
00CAB1  2  A4 90              LDY   Dptrh             ; get DATA pointer high byte
00CAB3  2  A9 80              LDA   #$80              ; set mode = READ
00CAB5  2               
00CAB5  2               LAB_1953
00CAB5  2  85 62              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
00CAB7  2  86 91              STX   Rdptrl            ; save READ pointer low byte
00CAB9  2  84 92              STY   Rdptrh            ; save READ pointer high byte
00CABB  2               
00CABB  2                                             ; READ or INPUT next variable from list
00CABB  2               LAB_195B
00CABB  2  20 95 D0           JSR   LAB_GVAR          ; get (var) address
00CABE  2  85 97              STA   Lvarpl            ; save address low byte
00CAC0  2  84 98              STY   Lvarph            ; save address high byte
00CAC2  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00CAC4  2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
00CAC6  2  85 11              STA   Itempl            ; save as temporary integer low byte
00CAC8  2  84 12              STY   Itemph            ; save as temporary integer high byte
00CACA  2  A6 91              LDX   Rdptrl            ; get READ pointer low byte
00CACC  2  A4 92              LDY   Rdptrh            ; get READ pointer high byte
00CACE  2  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00CAD0  2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00CAD2  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00CAD5  2  D0 11              BNE   LAB_1988          ; branch if not null
00CAD7  2               
00CAD7  2                                             ; pointer was to null entry
00CAD7  2  24 62              BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
00CAD9  2  30 65              BMI   LAB_19DD          ; branch if READ
00CADB  2               
00CADB  2                                             ; mode was INPUT
00CADB  2  20 42 CA           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
00CADE  2  20 4D C2           JSR   LAB_INLN          ; print "? " and get BASIC input
00CAE1  2  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00CAE3  2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00CAE5  2               LAB_1985
00CAE5  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00CAE8  2               LAB_1988
00CAE8  2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
00CAEA  2  10 24              BPL   LAB_19B0          ; branch if numeric
00CAEC  2               
00CAEC  2                                             ; else get string
00CAEC  2  85 5B              STA   Srchc             ; save search character
00CAEE  2  C9 22              CMP   #$22              ; was it " ?
00CAF0  2  F0 07              BEQ   LAB_1999          ; branch if so
00CAF2  2               
00CAF2  2  A9 3A              LDA   #':'              ; else search character is ":"
00CAF4  2  85 5B              STA   Srchc             ; set new search character
00CAF6  2  A9 2C              LDA   #','              ; other search character is ","
00CAF8  2  18                 CLC                     ; clear carry for add
00CAF9  2               LAB_1999
00CAF9  2  85 5C              STA   Asrch             ; set second search character
00CAFB  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00CAFD  2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
00CAFF  2               
00CAFF  2  69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
00CB01  2  90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
00CB03  2               
00CB03  2  C8                 INY                     ; else increment high byte
00CB04  2               LAB_19A4
00CB04  2  20 35 D4           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
00CB07  2  20 CB D7           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
00CB0A  2  20 27 C9           JSR   LAB_17D5          ; go do string LET
00CB0D  2  4C 16 CB           JMP   LAB_19B6          ; go check string terminator
00CB10  2               
00CB10  2                                             ; get numeric INPUT
00CB10  2               LAB_19B0
00CB10  2  20 B0 DC           JSR   LAB_2887          ; get FAC1 from string
00CB13  2  20 AD DB           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
00CB16  2               LAB_19B6
00CB16  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00CB19  2  F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
00CB1B  2               
00CB1B  2  C9 2C              CMP   #','              ; else compare with ","
00CB1D  2  F0 03              BEQ   LAB_19C2          ; branch if ","
00CB1F  2               
00CB1F  2  4C 71 CA           JMP   LAB_1904          ; else go handle bad input data
00CB22  2               
00CB22  2                                             ; got good input data
00CB22  2               LAB_19C2
00CB22  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00CB25  2               LAB_19C5
00CB25  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
00CB27  2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
00CB29  2  85 91              STA   Rdptrl            ; save for now
00CB2B  2  84 92              STY   Rdptrh            ; save for now
00CB2D  2  A5 11              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
00CB2F  2  A4 12              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
00CB31  2  85 C3              STA   Bpntrl            ; set BASIC execute pointer low byte
00CB33  2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00CB35  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00CB38  2  F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
00CB3A  2               
00CB3A  2  20 4D CD           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
00CB3D  2  4C BB CA           JMP   LAB_195B          ; go INPUT next variable from list
00CB40  2               
00CB40  2                                             ; find next DATA statement or do "Out of DATA" error
00CB40  2               LAB_19DD
00CB40  2  20 F1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
00CB43  2  C8                 INY                     ; increment index
00CB44  2  AA                 TAX                     ; copy character ([:] or [EOL])
00CB45  2  D0 12              BNE   LAB_19F6          ; branch if [:]
00CB47  2               
00CB47  2  A2 06              LDX   #$06              ; set for "Out of DATA" error
00CB49  2  C8                 INY                     ; increment index, now points to next line pointer high byte
00CB4A  2  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
00CB4C  2  F0 73              BEQ   LAB_1A54          ; branch if end (eventually does error X)
00CB4E  2               
00CB4E  2  C8                 INY                     ; increment index
00CB4F  2  B1 C3              LDA   (Bpntrl),Y        ; get next line # low byte
00CB51  2  85 8D              STA   Dlinel            ; save current DATA line low byte
00CB53  2  C8                 INY                     ; increment index
00CB54  2  B1 C3              LDA   (Bpntrl),Y        ; get next line # high byte
00CB56  2  C8                 INY                     ; increment index
00CB57  2  85 8E              STA   Dlineh            ; save current DATA line high byte
00CB59  2               LAB_19F6
00CB59  2  B1 C3              LDA   (Bpntrl),Y        ; get byte
00CB5B  2  C8                 INY                     ; increment index
00CB5C  2  AA                 TAX                     ; copy to X
00CB5D  2  20 E3 C7           JSR   LAB_170F          ; set BASIC execute pointer
00CB60  2  E0 83              CPX   #TK_DATA          ; compare with "DATA" token
00CB62  2  F0 81              BEQ   LAB_1985          ; was "DATA" so go do next READ
00CB64  2               
00CB64  2  D0 DA              BNE   LAB_19DD          ; go find next statement if not "DATA"
00CB66  2               
00CB66  2               ; end of INPUT/READ routine
00CB66  2               
00CB66  2               LAB_1A03
00CB66  2  A5 91              LDA   Rdptrl            ; get temp READ pointer low byte
00CB68  2  A4 92              LDY   Rdptrh            ; get temp READ pointer high byte
00CB6A  2  A6 62              LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
00CB6C  2  10 03              BPL   LAB_1A0E          ; branch if INPUT
00CB6E  2               
00CB6E  2  4C A2 C6           JMP   LAB_1624          ; save AY as DATA pointer and return
00CB71  2               
00CB71  2                                             ; we were getting INPUT
00CB71  2               LAB_1A0E
00CB71  2  A0 00              LDY   #$00              ; clear index
00CB73  2  B1 91              LDA   (Rdptrl),Y        ; get next byte
00CB75  2  D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
00CB77  2               
00CB77  2  60                 RTS
00CB78  2               
00CB78  2                                             ; user typed too much
00CB78  2               LAB_1A1B
00CB78  2  A9 BA              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
00CB7A  2  A0 FE              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
00CB7C  2  4C 2A CA           JMP   LAB_18C3          ; print null terminated string from memory and return
00CB7F  2               
00CB7F  2               ; search the stack for FOR activity
00CB7F  2               ; exit with z=1 if FOR else exit with z=0
00CB7F  2               
00CB7F  2               LAB_11A1
00CB7F  2  BA                 TSX                     ; copy stack pointer
00CB80  2  E8                 INX                     ; +1 pass return address
00CB81  2  E8                 INX                     ; +2 pass return address
00CB82  2  E8                 INX                     ; +3 pass calling routine return address
00CB83  2  E8                 INX                     ; +4 pass calling routine return address
00CB84  2               LAB_11A6
00CB84  2  BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
00CB87  2  C9 81              CMP   #TK_FOR           ; is it FOR token
00CB89  2  D0 21              BNE   LAB_11CE          ; exit if not FOR token
00CB8B  2               
00CB8B  2                                             ; was FOR token
00CB8B  2  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
00CB8D  2  D0 0A              BNE   LAB_11BB          ; branch if not null
00CB8F  2               
00CB8F  2  BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
00CB92  2  85 97              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
00CB94  2  BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
00CB97  2  85 98              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
00CB99  2               LAB_11BB
00CB99  2  DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
00CB9C  2  D0 07              BNE   LAB_11C7          ; branch if no match
00CB9E  2               
00CB9E  2  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
00CBA0  2  DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
00CBA3  2  F0 07              BEQ   LAB_11CE          ; exit if match found
00CBA5  2               
00CBA5  2               LAB_11C7
00CBA5  2  8A                 TXA                     ; copy index
00CBA6  2  18                 CLC                     ; clear carry for add
00CBA7  2  69 10              ADC   #$10              ; add FOR stack use size
00CBA9  2  AA                 TAX                     ; copy back to index
00CBAA  2  D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
00CBAC  2               
00CBAC  2               LAB_11CE
00CBAC  2  60                 RTS
00CBAD  2               
00CBAD  2               ; perform NEXT
00CBAD  2               
00CBAD  2               LAB_NEXT
00CBAD  2  D0 04              BNE   LAB_1A46          ; branch if NEXT var
00CBAF  2               
00CBAF  2  A0 00              LDY   #$00              ; else clear Y
00CBB1  2  F0 03              BEQ   LAB_1A49          ; branch always (no variable to search for)
00CBB3  2               
00CBB3  2               ; NEXT var
00CBB3  2               
00CBB3  2               LAB_1A46
00CBB3  2  20 95 D0           JSR   LAB_GVAR          ; get variable address
00CBB6  2               LAB_1A49
00CBB6  2  85 97              STA   Frnxtl            ; store variable pointer low byte
00CBB8  2  84 98              STY   Frnxth            ; store variable pointer high byte
00CBBA  2                                             ; (both cleared if no variable defined)
00CBBA  2  20 7F CB           JSR   LAB_11A1          ; search the stack for FOR activity
00CBBD  2  F0 04              BEQ   LAB_1A56          ; branch if found
00CBBF  2               
00CBBF  2  A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
00CBC1  2               LAB_1A54
00CBC1  2  F0 63              BEQ   LAB_1ABE          ; do error #X, then warm start
00CBC3  2               
00CBC3  2               LAB_1A56
00CBC3  2  9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
00CBC4  2               
00CBC4  2  8A                 TXA                     ; copy stack pointer
00CBC5  2  38                 SEC                     ; set carry for subtract
00CBC6  2  E9 F7              SBC   #$F7              ; point to TO var
00CBC8  2  85 73              STA   ut2_pl            ; save pointer to TO var for compare
00CBCA  2  69 FB              ADC   #$FB              ; point to STEP var
00CBCC  2               
00CBCC  2  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
00CBCE  2  20 87 DB           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
00CBD1  2  BA                 TSX                     ; get stack pointer back
00CBD2  2  BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
00CBD5  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00CBD7  2  A5 97              LDA   Frnxtl            ; get FOR variable pointer low byte
00CBD9  2  A4 98              LDY   Frnxth            ; get FOR variable pointer high byte
00CBDB  2  20 C8 D8           JSR   LAB_246C          ; add (FOR variable) to FAC1
00CBDE  2  20 AD DB           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
00CBE1  2  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
00CBE3  2  20 23 DC           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
00CBE6  2  BA                 TSX                     ; get stack pointer back
00CBE7  2  DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
00CBEA  2  F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
00CBEC  2               
00CBEC  2                                             ; loop back and do it all again
00CBEC  2  BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
00CBEF  2  85 87              STA   Clinel            ; save current line low byte
00CBF1  2  BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
00CBF4  2  85 88              STA   Clineh            ; save current line high byte
00CBF6  2  BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
00CBF9  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00CBFB  2  BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
00CBFE  2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00CC00  2               LAB_1A98
00CC00  2  4C 60 C5           JMP   LAB_15C2          ; go do interpreter inner loop
00CC03  2               
00CC03  2                                             ; loop complete so carry on
00CC03  2               LAB_1A9B
00CC03  2  8A                 TXA                     ; stack copy to A
00CC04  2  69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
00CC06  2  AA                 TAX                     ; copy back to index
00CC07  2  9A                 TXS                     ; copy to stack pointer
00CC08  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00CC0B  2  C9 2C              CMP   #','              ; compare with ","
00CC0D  2  D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
00CC0F  2               
00CC0F  2                                             ; was "," so another NEXT variable to do
00CC0F  2  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
00CC12  2  20 B3 CB           JSR   LAB_1A46          ; do NEXT (var)
00CC15  2               
00CC15  2               ; evaluate expression and check is numeric, else do type mismatch
00CC15  2               
00CC15  2               LAB_EVNM
00CC15  2  20 29 CC           JSR   LAB_EVEX          ; evaluate expression
00CC18  2               
00CC18  2               ; check if source is numeric, else do type mismatch
00CC18  2               
00CC18  2               LAB_CTNM
00CC18  2  18                 CLC                     ; destination is numeric
00CC19  2  24                 .byte $24               ; makes next line BIT $38
00CC1A  2               
00CC1A  2               ; check if source is string, else do type mismatch
00CC1A  2               
00CC1A  2               LAB_CTST
00CC1A  2  38                 SEC                     ; required type is string
00CC1B  2               
00CC1B  2               ; type match check, set C for string, clear C for numeric
00CC1B  2               
00CC1B  2               LAB_CKTM
00CC1B  2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
00CC1D  2  30 03              BMI   LAB_1ABA          ; branch if data type is string
00CC1F  2               
00CC1F  2                                             ; else data type was numeric
00CC1F  2  B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
00CC21  2               LAB_1AB9
00CC21  2  60                 RTS
00CC22  2               
00CC22  2                                             ; data type was string, now check required type
00CC22  2               LAB_1ABA
00CC22  2  B0 FD              BCS   LAB_1AB9          ; exit if required type is string
00CC24  2               
00CC24  2                                             ; else do type mismatch error
00CC24  2               LAB_1ABC
00CC24  2  A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
00CC26  2               LAB_1ABE
00CC26  2  4C 49 C1           JMP   LAB_XERR          ; do error #X, then warm start
00CC29  2               
00CC29  2               ; evaluate expression
00CC29  2               
00CC29  2               LAB_EVEX
00CC29  2  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
00CC2B  2  D0 02              BNE   LAB_1AC7          ; skip next if not zero
00CC2D  2               
00CC2D  2  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
00CC2F  2               LAB_1AC7
00CC2F  2  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
00CC31  2               
00CC31  2               LAB_EVEZ
00CC31  2  A9 00              LDA   #$00              ; set null precedence (flag done)
00CC33  2               LAB_1ACC
00CC33  2  48                 PHA                     ; push precedence byte
00CC34  2  A9 02              LDA   #$02              ; 2 bytes
00CC36  2  20 0D C1           JSR   LAB_1212          ; check room on stack for A bytes
00CC39  2  20 15 CD           JSR   LAB_GVAL          ; get value from line
00CC3C  2  A9 00              LDA   #$00              ; clear A
00CC3E  2  85 9B              STA   comp_f            ; clear compare function flag
00CC40  2               LAB_1ADB
00CC40  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00CC43  2               LAB_1ADE
00CC43  2  38                 SEC                     ; set carry for subtract
00CC44  2  E9 D6              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
00CC46  2  90 17              BCC   LAB_1AFA          ; branch if < TK_GT
00CC48  2               
00CC48  2  C9 03              CMP   #$03              ; compare with ">" to "<" tokens
00CC4A  2  B0 13              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
00CC4C  2               
00CC4C  2                                             ; was token for > = or < (A = 0, 1 or 2)
00CC4C  2  C9 01              CMP   #$01              ; compare with token for =
00CC4E  2  2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
00CC4F  2                                             ; (A = 0, 3 or 5)
00CC4F  2  49 01              EOR   #$01              ; toggle b0
00CC51  2                                             ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
00CC51  2  45 9B              EOR   comp_f            ; EOR with compare function flag bits
00CC53  2  C5 9B              CMP   comp_f            ; compare with compare function flag
00CC55  2  90 67              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
00CC57  2                                             ; was more than one <, = or >)
00CC57  2               
00CC57  2  85 9B              STA   comp_f            ; save new compare function flag
00CC59  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00CC5C  2  4C 43 CC           JMP   LAB_1ADE          ; go do next character
00CC5F  2               
00CC5F  2                                             ; token is < ">" or > "<" tokens
00CC5F  2               LAB_1AFA
00CC5F  2  A6 9B              LDX   comp_f            ; get compare function flag
00CC61  2  D0 2C              BNE   LAB_1B2A          ; branch if compare function
00CC63  2               
00CC63  2  B0 79              BCS   LAB_1B78          ; go do functions
00CC65  2               
00CC65  2                                             ; else was <  TK_GT so is operator or lower
00CC65  2  69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
00CC67  2  90 75              BCC   LAB_1B78          ; branch if < + operator
00CC69  2               
00CC69  2                                             ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
00CC69  2  D0 07              BNE   LAB_1B0B          ; branch if not + token
00CC6B  2               
00CC6B  2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
00CC6D  2  10 03              BPL   LAB_1B0B          ; branch if not string
00CC6F  2               
00CC6F  2                                             ; will only be $00 if type is string and token was +
00CC6F  2  4C C5 D5           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
00CC72  2                                             ; is in line, and return
00CC72  2               
00CC72  2               LAB_1B0B
00CC72  2  85 71              STA   ut1_pl            ; save it
00CC74  2  0A                 ASL                     ; *2
00CC75  2  65 71              ADC   ut1_pl            ; *3
00CC77  2  A8                 TAY                     ; copy to index
00CC78  2               LAB_1B13
00CC78  2  68                 PLA                     ; pull previous precedence
00CC79  2  D9 9A F8           CMP   LAB_OPPT,Y        ; compare with precedence byte
00CC7C  2  B0 65              BCS   LAB_1B7D          ; branch if A >=
00CC7E  2               
00CC7E  2  20 18 CC           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00CC81  2               LAB_1B1C
00CC81  2  48                 PHA                     ; save precedence
00CC82  2               LAB_1B1D
00CC82  2  20 AA CC           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
00CC85  2  68                 PLA                     ; restore precedence
00CC86  2  A4 99              LDY   prstk             ; get precedence stacked flag
00CC88  2  10 19              BPL   LAB_1B3C          ; branch if stacked values
00CC8A  2               
00CC8A  2  AA                 TAX                     ; copy precedence (set flags)
00CC8B  2  F0 76              BEQ   LAB_1B9D          ; exit if done
00CC8D  2               
00CC8D  2  D0 5D              BNE   LAB_1B86          ; else pop FAC2 and return, branch always
00CC8F  2               
00CC8F  2               LAB_1B2A
00CC8F  2  26 5F              ROL   Dtypef            ; shift data type flag into Cb
00CC91  2  8A                 TXA                     ; copy compare function flag
00CC92  2  85 5F              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
00CC94  2  2A                 ROL                     ; shift data type into compare function byte b0
00CC95  2  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
00CC97  2  D0 02              BNE   LAB_1B34          ; branch if no underflow
00CC99  2               
00CC99  2  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
00CC9B  2               LAB_1B34
00CC9B  2  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
00CC9D  2               TK_LT_PLUS  = TK_LT-TK_PLUS
00CC9D  2  A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
00CC9F  2  85 9B              STA   comp_f            ; save new compare function flag
00CCA1  2  D0 D5              BNE   LAB_1B13          ; branch always
00CCA3  2               
00CCA3  2               LAB_1B3C
00CCA3  2  D9 9A F8           CMP   LAB_OPPT,Y        ;.compare with stacked function precedence
00CCA6  2  B0 44              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
00CCA8  2               
00CCA8  2  90 D7              BCC   LAB_1B1C          ; branch always
00CCAA  2               
00CCAA  2               ;.get vector, execute function then continue evaluation
00CCAA  2               
00CCAA  2               LAB_1B43
00CCAA  2  B9 9C F8           LDA   LAB_OPPT+2,Y      ; get function vector high byte
00CCAD  2  48                 PHA                     ; onto stack
00CCAE  2  B9 9B F8           LDA   LAB_OPPT+1,Y      ; get function vector low byte
00CCB1  2  48                 PHA                     ; onto stack
00CCB2  2                                             ; now push sign, round FAC1 and put on stack
00CCB2  2               ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00CCB2  2               ; *** add
00CCB2  2                  .IF (* & $FF)=$FD
00CCB2  2                     NOP                     ; return address of JSR +1 (on  next page)
00CCB2  2                  .ENDIF
00CCB2  2               ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00CCB2  2  20 C1 CC           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
00CCB5  2                                             ; the function
00CCB5  2  A5 9B              LDA   comp_f            ; get compare function flag
00CCB7  2  48                 PHA                     ; push compare evaluation byte
00CCB8  2  B9 9A F8           LDA   LAB_OPPT,Y        ; get precedence byte
00CCBB  2  4C 33 CC           JMP   LAB_1ACC          ; continue evaluating expression
00CCBE  2               
00CCBE  2               LAB_1B53
00CCBE  2  4C 51 CD           JMP   LAB_SNER          ; do syntax error then warm start
00CCC1  2               
00CCC1  2               ; push sign, round FAC1 and put on stack
00CCC1  2               
00CCC1  2               LAB_1B5B
00CCC1  2  68                 PLA                     ; get return addr low byte
00CCC2  2  85 71              STA   ut1_pl            ; save it
00CCC4  2  E6 71              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
00CCC6  2                                             ; note! no check is made on the high byte! if the calling
00CCC6  2                                             ; routine assembles to a page edge then this all goes
00CCC6  2                                             ; horribly wrong !!!
00CCC6  2  68                 PLA                     ; get return addr high byte
00CCC7  2  85 72              STA   ut1_ph            ; save it
00CCC9  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00CCCB  2  48                 PHA                     ; push sign
00CCCC  2               
00CCCC  2               ; round FAC1 and put on stack
00CCCC  2               
00CCCC  2               ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
00CCCC  2               ; *** replace
00CCCC  2               ;LAB_1B66
00CCCC  2               ;      JSR   LAB_27BA          ; round FAC1
00CCCC  2               ; *** with
00CCCC  2  20 E3 DB           JSR   LAB_27BA          ; round FAC1
00CCCF  2               LAB_1B66
00CCCF  2               ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
00CCCF  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00CCD1  2  48                 PHA                     ; push on stack
00CCD2  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CCD4  2  48                 PHA                     ; push on stack
00CCD5  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00CCD7  2  48                 PHA                     ; push on stack
00CCD8  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00CCDA  2  48                 PHA                     ; push on stack
00CCDB  2  6C 71 00           JMP   (ut1_pl)          ; return, sort of
00CCDE  2               
00CCDE  2               ; do functions
00CCDE  2               
00CCDE  2               LAB_1B78
00CCDE  2  A0 FF              LDY   #$FF              ; flag function
00CCE0  2  68                 PLA                     ; pull precedence byte
00CCE1  2               LAB_1B7B
00CCE1  2  F0 20              BEQ   LAB_1B9D          ; exit if done
00CCE3  2               
00CCE3  2               LAB_1B7D
00CCE3  2  C9 64              CMP   #$64              ; compare previous precedence with $64
00CCE5  2  F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
00CCE7  2               
00CCE7  2  20 18 CC           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00CCEA  2               LAB_1B84
00CCEA  2  84 99              STY   prstk             ; save precedence stacked flag
00CCEC  2               
00CCEC  2                                             ; pop FAC2 and return
00CCEC  2               LAB_1B86
00CCEC  2  68                 PLA                     ; pop byte
00CCED  2  4A                 LSR                     ; shift out comparison evaluation lowest bit
00CCEE  2  85 63              STA   Cflag             ; save comparison evaluation flag
00CCF0  2  68                 PLA                     ; pop exponent
00CCF1  2  85 B3              STA   FAC2_e            ; save FAC2 exponent
00CCF3  2  68                 PLA                     ; pop mantissa1
00CCF4  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00CCF6  2  68                 PLA                     ; pop mantissa2
00CCF7  2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
00CCF9  2  68                 PLA                     ; pop mantissa3
00CCFA  2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
00CCFC  2  68                 PLA                     ; pop sign
00CCFD  2  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
00CCFF  2  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
00CD01  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00CD03  2               LAB_1B9D
00CD03  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00CD05  2  60                 RTS
00CD06  2               
00CD06  2               ; print "..." string to string util area
00CD06  2               
00CD06  2               LAB_1BC1
00CD06  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00CD08  2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
00CD0A  2  69 00              ADC   #$00              ; add carry to low byte
00CD0C  2  90 01              BCC   LAB_1BCA          ; branch if no overflow
00CD0E  2               
00CD0E  2  C8                 INY                     ; increment high byte
00CD0F  2               LAB_1BCA
00CD0F  2  20 2F D4           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
00CD12  2  4C CB D7           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
00CD15  2               
00CD15  2               ; get value from line
00CD15  2               
00CD15  2               LAB_GVAL
00CD15  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00CD18  2  B0 03              BCS   LAB_1BAC          ; branch if not numeric character
00CD1A  2               
00CD1A  2                                             ; else numeric string found (e.g. 123)
00CD1A  2               LAB_1BA9
00CD1A  2  4C B0 DC           JMP   LAB_2887          ; get FAC1 from string and return
00CD1D  2               
00CD1D  2               ; get value from line .. continued
00CD1D  2               
00CD1D  2                                             ; wasn't a number so ..
00CD1D  2               LAB_1BAC
00CD1D  2  C9 01              CMP   #TKX_PREFIX       ; extended token prefix? (GBYT sets carry for $01)
00CD1F  2  F0 5F              BEQ   LAB_1BEE          ; go handle extended token functions
00CD21  2  AA                 TAX                     ; set the flags
00CD22  2  30 32              BMI   LAB_1BD0          ; if -ve go test token values
00CD24  2               
00CD24  2                                             ; else it is either a string, number, variable or (<expr>)
00CD24  2  C9 24              CMP   #'$'              ; compare with "$"
00CD26  2  F0 F2              BEQ   LAB_1BA9          ; branch if "$", hex number
00CD28  2               
00CD28  2  C9 25              CMP   #'%'              ; else compare with "%"
00CD2A  2  F0 EE              BEQ   LAB_1BA9          ; branch if "%", binary number
00CD2C  2               
00CD2C  2  C9 2E              CMP   #'.'              ; compare with "."
00CD2E  2  F0 EA              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
00CD30  2               
00CD30  2                                             ; it wasn't any sort of number so ..
00CD30  2  C9 22              CMP   #$22              ; compare with "
00CD32  2  F0 D2              BEQ   LAB_1BC1          ; branch if open quote
00CD34  2               
00CD34  2                                             ; wasn't any sort of number so ..
00CD34  2               
00CD34  2               ; evaluate expression within parentheses
00CD34  2               
00CD34  2  C9 28              CMP   #'('              ; compare with "("
00CD36  2  F0 03              BEQ   @gval_paren
00CD38  2  4C 24 CF           JMP   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
00CD3B  2               @gval_paren
00CD3B  2               
00CD3B  2               LAB_1BF7
00CD3B  2  20 31 CC           JSR   LAB_EVEZ          ; evaluate expression, no decrement
00CD3E  2               
00CD3E  2               ; all the 'scan for' routines return the character after the sought character
00CD3E  2               
00CD3E  2               ; scan for ")" , else do syntax error then warm start
00CD3E  2               
00CD3E  2               LAB_1BFB
00CD3E  2  A9 29              LDA   #$29              ; load A with ")"
00CD40  2               
00CD40  2               ; scan for CHR$(A) , else do syntax error then warm start
00CD40  2               
00CD40  2               LAB_SCCA
00CD40  2  A0 00              LDY   #$00              ; clear index
00CD42  2  D1 C3              CMP   (Bpntrl),Y        ; check next byte is = A
00CD44  2  D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
00CD46  2               
00CD46  2  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then return
00CD49  2               
00CD49  2               ; scan for "(" , else do syntax error then warm start
00CD49  2               
00CD49  2               LAB_1BFE
00CD49  2  A9 28              LDA   #$28              ; load A with "("
00CD4B  2  D0 F3              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00CD4D  2                                             ; (branch always)
00CD4D  2               
00CD4D  2               ; scan for "," , else do syntax error then warm start
00CD4D  2               
00CD4D  2               LAB_1C01
00CD4D  2  A9 2C              LDA   #$2C              ; load A with ","
00CD4F  2  D0 EF              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00CD51  2                                             ; (branch always)
00CD51  2               
00CD51  2               ; syntax error then warm start
00CD51  2               
00CD51  2               LAB_SNER
00CD51  2  A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
00CD53  2  4C 49 C1           JMP   LAB_XERR          ; do error #X, then warm start
00CD56  2               
00CD56  2               ; get value from line .. continued
00CD56  2               ; do tokens
00CD56  2               
00CD56  2               LAB_1BD0
00CD56  2  C9 CD              CMP   #TK_MINUS         ; compare with token for -
00CD58  2  D0 03              BNE   @not_minus
00CD5A  2  4C 11 CF           JMP   LAB_1C11          ; branch if - token (do set-up for functions)
00CD5D  2               @not_minus
00CD5D  2               
00CD5D  2                                             ; wasn't -n so ..
00CD5D  2  C9 CC              CMP   #TK_PLUS          ; compare with token for +
00CD5F  2  F0 B4              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
00CD61  2               
00CD61  2  C9 C7              CMP   #TK_NOT           ; compare with token for NOT
00CD63  2  D0 14              BNE   LAB_1BE7          ; branch if not token for NOT
00CD65  2               
00CD65  2                                             ; was NOT token
00CD65  2               TK_EQUAL_PLUS     = TK_EQUAL-TK_PLUS
00CD65  2  A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
00CD67  2  4C 13 CF           JMP   LAB_1C13          ; do set-up for function then execute
00CD6A  2               
00CD6A  2               ; do = compare
00CD6A  2               
00CD6A  2               LAB_EQUAL
00CD6A  2  20 91 D1           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
00CD6D  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00CD6F  2  49 FF              EOR   #$FF              ; invert it
00CD71  2  A8                 TAY                     ; copy it
00CD72  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CD74  2  49 FF              EOR   #$FF              ; invert it
00CD76  2  4C 44 D3           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00CD79  2               
00CD79  2               ; get value from line .. continued
00CD79  2               
00CD79  2                                             ; wasn't +, -, or NOT so ..
00CD79  2               LAB_1BE7
00CD79  2  C9 C4              CMP   #TK_FN            ; compare with token for FN
00CD7B  2  D0 03              BNE   LAB_1BEE          ; branch if not token for FN
00CD7D  2               
00CD7D  2  4C 9F D3           JMP   LAB_201E          ; go evaluate FNx
00CD80  2               
00CD80  2               ; get value from line .. continued
00CD80  2               
00CD80  2                                             ; wasn't +, -, NOT or FN so ..
00CD80  2               LAB_1BEE
00CD80  2  C9 01              CMP   #TKX_PREFIX       ; extended token prefix (e.g. XPEEK)
00CD82  2  F0 03              BEQ   @is_xtk
00CD84  2  4C 09 CF           JMP   LAB_1BEE_STD
00CD87  2               @is_xtk
00CD87  2  20 BC 00           JSR   LAB_IGBY          ; consume prefix, get extension id
00CD8A  2  A0 00              LDY   #$00
00CD8C  2  B1 C3              LDA   (Bpntrl),Y        ; read raw extension id (LAB_IGBY may normalize A)
00CD8E  2  C9 15              CMP   #XTK_PLAYING
00CD90  2  F0 51              BEQ   @j_playing
00CD92  2  C9 16              CMP   #XTK_MNOTE
00CD94  2  F0 50              BEQ   @j_mnote
00CD96  2  C9 06              CMP   #XTK_XPEEK
00CD98  2  F0 4F              BEQ   @xtk_xpeek
00CD9A  2  C9 1E              CMP   #XTK_NRECV
00CD9C  2  F0 27              BEQ   @j_nrecv
00CD9E  2  C9 1F              CMP   #XTK_NSTATUS
00CDA0  2  F0 26              BEQ   @j_nstatus
00CDA2  2  C9 21              CMP   #XTK_NREADY
00CDA4  2  F0 25              BEQ   @j_nready
00CDA6  2  C9 22              CMP   #XTK_NLEN
00CDA8  2  F0 24              BEQ   @j_nlen
00CDAA  2  C9 25              CMP   #XTK_DMASTATUS
00CDAC  2  F0 23              BEQ   @j_dmastatus
00CDAE  2  C9 27              CMP   #XTK_DMAERR
00CDB0  2  F0 22              BEQ   @j_dmaerr
00CDB2  2  C9 28              CMP   #XTK_DMACOUNT
00CDB4  2  F0 21              BEQ   @j_dmacount
00CDB6  2  C9 42              CMP   #XTK_BLITSTATUS
00CDB8  2  F0 20              BEQ   @j_blitstatus
00CDBA  2  C9 43              CMP   #XTK_BLITERR
00CDBC  2  F0 1F              BEQ   @j_bliterr
00CDBE  2  C9 44              CMP   #XTK_BLITCOUNT
00CDC0  2  F0 1E              BEQ   @j_blitcount
00CDC2  2  4C 51 CD           JMP   LAB_SNER          ; unknown extension in expression
00CDC5  2               @j_nrecv
00CDC5  2  4C 51 CE           JMP   @xtk_nrecv
00CDC8  2               @j_nstatus
00CDC8  2  4C 7C CE           JMP   @xtk_nstatus
00CDCB  2               @j_nready
00CDCB  2  4C 95 CE           JMP   @xtk_nready
00CDCE  2               @j_nlen
00CDCE  2  4C BA CE           JMP   @xtk_nlen
00CDD1  2               @j_dmastatus
00CDD1  2  4C C5 CE           JMP   @xtk_dmastatus
00CDD4  2               @j_dmaerr
00CDD4  2  4C D0 CE           JMP   @xtk_dmaerr
00CDD7  2               @j_dmacount
00CDD7  2  4C DB CE           JMP   @xtk_dmacount
00CDDA  2               @j_blitstatus
00CDDA  2  4C E7 CE           JMP   @xtk_blitstatus
00CDDD  2               @j_bliterr
00CDDD  2  4C F2 CE           JMP   @xtk_bliterr
00CDE0  2               @j_blitcount
00CDE0  2  4C FD CE           JMP   @xtk_blitcount
00CDE3  2               @j_playing
00CDE3  2  4C 1A CE           JMP   @xtk_playing
00CDE6  2               @j_mnote
00CDE6  2  4C 2E CE           JMP   @xtk_mnote
00CDE9  2               
00CDE9  2               @xtk_xpeek
00CDE9  2                     ; '(' was consumed during tokenization as part of keyword
00CDE9  2  20 BC 00           JSR   LAB_IGBY          ; consume extension id, advance to argument
00CDEC  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check numeric
00CDEF  2  20 8D D1           JSR   LAB_EVPI          ; convert FAC1 to unsigned integer
00CDF2  2  20 3E CD           JSR   LAB_1BFB          ; scan for ')' and advance
00CDF5  2  A5 AF              LDA   FAC1_3            ; x offset low
00CDF7  2  8D 04 BA           STA   XMC_XAL
00CDFA  2  A5 AE              LDA   FAC1_2            ; x offset high
00CDFC  2  8D 05 BA           STA   XMC_XAM
00CDFF  2  AD 0C BA           LDA   XMC_BANK          ; current bank -> top address byte
00CE02  2  8D 06 BA           STA   XMC_XAH
00CE05  2  A9 01              LDA   #XMC_CMD_GET
00CE07  2  8D 00 BA           STA   XMC_CMD
00CE0A  2  AD 01 BA           LDA   XMC_STATUS
00CE0D  2  C9 02              CMP   #XMC_OK
00CE0F  2  F0 03              BEQ   @xpeek_ok
00CE11  2  4C 14 D2           JMP   LAB_FCER
00CE14  2               @xpeek_ok
00CE14  2  AC 0B BA           LDY   XMC_DATA
00CE17  2  4C 51 D3           JMP   LAB_1FD0          ; convert Y byte to FAC1 and return
00CE1A  2               
00CE1A  2               @xtk_playing
00CE1A  2  20 BC 00           JSR   LAB_IGBY          ; consume PLAYING token, advance past it
00CE1D  2  AD 50 BA           LDA   MUSIC_STATUS      ; read status register
00CE20  2  29 02              AND   #$02              ; isolate music playing bit
00CE22  2  F0 03              BEQ   @play_off
00CE24  2  A0 01              LDY   #$01              ; music is playing
00CE26  2  2C                 .byte $2C               ; BIT abs — skip next 2 bytes
00CE27  2               @play_off
00CE27  2  A0 00              LDY   #$00              ; music not playing
00CE29  2  A9 00              LDA   #$00              ; A = high byte = 0
00CE2B  2  4C 44 D3           JMP   LAB_AYFC          ; return AY as integer in FAC1
00CE2E  2               
00CE2E  2               @xtk_mnote
00CE2E  2                     ; MNOTE(voice) — return current MIDI note for voice 1-6
00CE2E  2                     ; '(' was consumed during tokenization as part of keyword
00CE2E  2  20 BC 00           JSR   LAB_IGBY          ; consume MNOTE token, advance to argument
00CE31  2  20 15 CC           JSR   LAB_EVNM          ; evaluate voice expression (numeric)
00CE34  2  20 3E CD           JSR   LAB_1BFB          ; scan for ')' and advance
00CE37  2  20 ED D7           JSR   LAB_F2FX          ; convert FAC1 to integer
00CE3A  2  A4 11              LDY   Itempl            ; voice number (1-6)
00CE3C  2  88                 DEY                     ; make 0-based
00CE3D  2  C0 06              CPY   #$06
00CE3F  2  B0 09              BCS   @mnote_bad        ; out of range
00CE41  2  B9 51 BA           LDA   MUSIC_NOTE1,Y     ; read note register
00CE44  2  A8                 TAY
00CE45  2  A9 00              LDA   #$00
00CE47  2  4C 44 D3           JMP   LAB_AYFC          ; return AY as integer in FAC1
00CE4A  2               @mnote_bad
00CE4A  2  A0 00              LDY   #$00              ; return 0 for invalid voice
00CE4C  2  A9 00              LDA   #$00
00CE4E  2  4C 44 D3           JMP   LAB_AYFC
00CE51  2               
00CE51  2               ; NRECV$(slot) — receive message as BASIC string
00CE51  2               @xtk_nrecv
00CE51  2  20 BC 00           JSR   LAB_IGBY          ; consume token, advance to argument
00CE54  2  20 15 CC           JSR   LAB_EVNM          ; evaluate numeric expression (slot)
00CE57  2  20 3E CD           JSR   LAB_1BFB          ; scan for ')'
00CE5A  2  20 92 D7           JSR   LAB_EVBY          ; convert to byte → X
00CE5D  2  8E 02 A1           STX   NIC_SLOT
00CE60  2  A9 FF              LDA   #$FF              ; 255 bytes max
00CE62  2  20 25 D4           JSR   LAB_MSSP          ; allocate string space, str_pl/ph set
00CE65  2                     ; Point DMA at string buffer
00CE65  2  A5 AD              LDA   str_pl
00CE67  2  8D 10 A1           STA   NIC_DMAL
00CE6A  2  A5 AE              LDA   str_ph
00CE6C  2  8D 11 A1           STA   NIC_DMAH
00CE6F  2  A9 04              LDA   #NIC_CMD_RECV
00CE71  2  8D 00 A1           STA   NIC_CMD
00CE74  2  AD 13 A1           LDA   NIC_MSGLEN
00CE77  2  85 AC              STA   str_ln            ; actual received length (0=empty)
00CE79  2  4C 72 D4           JMP   LAB_RTST          ; push descriptor, return
00CE7C  2               
00CE7C  2               ; NSTATUS(slot) — return slot status byte
00CE7C  2               @xtk_nstatus
00CE7C  2  20 BC 00           JSR   LAB_IGBY          ; consume token
00CE7F  2  20 15 CC           JSR   LAB_EVNM          ; evaluate numeric expression (slot)
00CE82  2  20 3E CD           JSR   LAB_1BFB          ; scan for ')'
00CE85  2  20 92 D7           JSR   LAB_EVBY          ; convert to byte → X
00CE88  2  8A                 TXA
00CE89  2  29 03              AND   #$03              ; clamp 0-3
00CE8B  2  AA                 TAX
00CE8C  2  BD 18 A1           LDA   NIC_SLOTST0,X    ; read slot status
00CE8F  2  A8                 TAY
00CE90  2  A9 00              LDA   #$00
00CE92  2  4C 44 D3           JMP   LAB_AYFC          ; return AY as integer
00CE95  2               
00CE95  2               ; NREADY(slot) — return -1 (true) if data waiting, 0 (false) otherwise
00CE95  2               ; Uses BASIC boolean convention: true = $FFFF (-1) so NOT works correctly
00CE95  2               @xtk_nready
00CE95  2  20 BC 00           JSR   LAB_IGBY          ; consume token
00CE98  2  20 15 CC           JSR   LAB_EVNM          ; evaluate numeric expression (slot)
00CE9B  2  20 3E CD           JSR   LAB_1BFB          ; scan for ')'
00CE9E  2  20 92 D7           JSR   LAB_EVBY          ; convert to byte → X
00CEA1  2  8A                 TXA
00CEA2  2  29 03              AND   #$03
00CEA4  2  AA                 TAX
00CEA5  2  BD 18 A1           LDA   NIC_SLOTST0,X
00CEA8  2  29 02              AND   #NIC_ST_DATAREADY
00CEAA  2  F0 07              BEQ   @nready_no
00CEAC  2  A0 FF              LDY   #$FF              ; true = $FFFF (-1)
00CEAE  2  A9 FF              LDA   #$FF
00CEB0  2  4C 44 D3           JMP   LAB_AYFC
00CEB3  2               @nready_no
00CEB3  2  A0 00              LDY   #$00              ; false = $0000 (0)
00CEB5  2  A9 00              LDA   #$00
00CEB7  2  4C 44 D3           JMP   LAB_AYFC
00CEBA  2               
00CEBA  2               ; NLEN — return last received message length (no args)
00CEBA  2               @xtk_nlen
00CEBA  2  20 BC 00           JSR   LAB_IGBY          ; consume token
00CEBD  2  AC 13 A1           LDY   NIC_MSGLEN
00CEC0  2  A9 00              LDA   #$00
00CEC2  2  4C 44 D3           JMP   LAB_AYFC
00CEC5  2               
00CEC5  2               ; DMASTATUS — return DMA status register (no args)
00CEC5  2               @xtk_dmastatus
00CEC5  2  20 BC 00           JSR   LAB_IGBY          ; consume token
00CEC8  2  AC 61 BA           LDY   DMA_STATUS
00CECB  2  A9 00              LDA   #$00
00CECD  2  4C 44 D3           JMP   LAB_AYFC
00CED0  2               
00CED0  2               ; DMAERR — return DMA error code register (no args)
00CED0  2               @xtk_dmaerr
00CED0  2  20 BC 00           JSR   LAB_IGBY          ; consume token
00CED3  2  AC 62 BA           LDY   DMA_ERRCODE
00CED6  2  A9 00              LDA   #$00
00CED8  2  4C 44 D3           JMP   LAB_AYFC
00CEDB  2               
00CEDB  2               ; DMACOUNT — return last DMA byte count (low 16 bits)
00CEDB  2               @xtk_dmacount
00CEDB  2  20 BC 00           JSR   LAB_IGBY          ; consume token
00CEDE  2  AC 70 BA           LDY   DMA_CNTL
00CEE1  2  AD 71 BA           LDA   DMA_CNTM
00CEE4  2  4C 44 D3           JMP   LAB_AYFC
00CEE7  2               
00CEE7  2               ; BLITSTATUS — return blitter status register (no args)
00CEE7  2               @xtk_blitstatus
00CEE7  2  20 BC 00           JSR   LAB_IGBY          ; consume token
00CEEA  2  AC 81 BA           LDY   BLT_STATUS
00CEED  2  A9 00              LDA   #$00
00CEEF  2  4C 44 D3           JMP   LAB_AYFC
00CEF2  2               
00CEF2  2               ; BLITERR — return blitter error code register (no args)
00CEF2  2               @xtk_bliterr
00CEF2  2  20 BC 00           JSR   LAB_IGBY          ; consume token
00CEF5  2  AC 82 BA           LDY   BLT_ERRCODE
00CEF8  2  A9 00              LDA   #$00
00CEFA  2  4C 44 D3           JMP   LAB_AYFC
00CEFD  2               
00CEFD  2               ; BLITCOUNT — return last blit written-byte count (low 16 bits)
00CEFD  2               @xtk_blitcount
00CEFD  2  20 BC 00           JSR   LAB_IGBY          ; consume token
00CF00  2  AC 96 BA           LDY   BLT_CNTL
00CF03  2  AD 97 BA           LDA   BLT_CNTM
00CF06  2  4C 44 D3           JMP   LAB_AYFC
00CF09  2               
00CF09  2               LAB_1BEE_STD
00CF09  2  38                 SEC                     ; plain token base subtraction
00CF0A  2  E9 D9              SBC   #TK_SGN           ; subtract with token for SGN
00CF0C  2  B0 27              BCS   LAB_1C27          ; if a function token go do it
00CF0E  2               
00CF0E  2  4C 51 CD           JMP   LAB_SNER          ; else do syntax error
00CF11  2               
00CF11  2               ; set-up for functions
00CF11  2               
00CF11  2               LAB_1C11
00CF11  2               TK_GT_PLUS  = TK_GT-TK_PLUS
00CF11  2  A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
00CF13  2               LAB_1C13
00CF13  2  68                 PLA                     ; dump return address low byte
00CF14  2               ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00CF14  2               ; *** replace
00CF14  2               ;      PLA                     ; dump return address high byte
00CF14  2               ;      JMP   LAB_1B1D          ; execute function then continue evaluation
00CF14  2               ; *** with
00CF14  2  AA                 TAX                     ; save to trap concatenate
00CF15  2  68                 PLA                     ; dump return address high byte
00CF16  2  E0 CD              CPX   #<(LAB_224Da+2)   ; from concatenate low return address?
00CF18  2  D0 04              BNE   LAB_1C13b         ; No - continue!
00CF1A  2  C9 D5              CMP   #>(LAB_224Da+2)   ; from concatenate high return address?
00CF1C  2  F0 03              BEQ   LAB_1C13a         ; Yes - error!
00CF1E  2               LAB_1C13b
00CF1E  2  4C 82 CC           JMP   LAB_1B1D          ; execute function then continue evaluation
00CF21  2               LAB_1C13a
00CF21  2  4C 24 CC           JMP   LAB_1ABC          ; throw "type mismatch error" then warm start
00CF24  2               ; *** end   patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00CF24  2               
00CF24  2               ; variable name set-up
00CF24  2               ; get (var), return value in FAC_1 and $ flag
00CF24  2               
00CF24  2               LAB_1C18
00CF24  2  20 95 D0           JSR   LAB_GVAR          ; get (var) address
00CF27  2  85 AE              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
00CF29  2  84 AF              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
00CF2B  2  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
00CF2D  2  30 03              BMI   LAB_1C25          ; if string then return (does RTS)
00CF2F  2               
00CF2F  2               LAB_1C24
00CF2F  2  4C 87 DB           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
00CF32  2               
00CF32  2               LAB_1C25
00CF32  2               ; *** begin patch  string pointer high byte trashed when moved to stack
00CF32  2               ; *** add
00CF32  2  46 B9              LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
00CF34  2               ; *** end patch
00CF34  2  60                 RTS
00CF35  2               
00CF35  2               ; get value from line .. continued
00CF35  2               ; only functions left so ..
00CF35  2               
00CF35  2               ; set up function references
00CF35  2               
00CF35  2               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
00CF35  2               ; to process function calls. now the function vector is computed and pushed on the stack
00CF35  2               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
00CF35  2               ; is calculated and the routine called, if not this routine just does RTS. whichever
00CF35  2               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
00CF35  2               ; the function code
00CF35  2               
00CF35  2               ; this also removes some less than elegant code that was used to bypass type checking
00CF35  2               ; for functions that returned strings
00CF35  2               
00CF35  2               LAB_1C27
00CF35  2  0A                 ASL                     ; *2 (2 bytes per function address)
00CF36  2  A8                 TAY                     ; copy to index
00CF37  2               
00CF37  2  B9 4D F8           LDA   LAB_FTBM,Y        ; get function jump vector high byte
00CF3A  2  48                 PHA                     ; push functions jump vector high byte
00CF3B  2  B9 4C F8           LDA   LAB_FTBL,Y        ; get function jump vector low byte
00CF3E  2  48                 PHA                     ; push functions jump vector low byte
00CF3F  2               
00CF3F  2  B9 FF F7           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
00CF42  2  F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
00CF44  2               
00CF44  2  48                 PHA                     ; push functions pre process vector high byte
00CF45  2  B9 FE F7           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
00CF48  2  48                 PHA                     ; push functions pre process vector low byte
00CF49  2               
00CF49  2               LAB_1C56
00CF49  2  60                 RTS                     ; do function, or pre process, call
00CF4A  2               
00CF4A  2               ; process string expression in parenthesis
00CF4A  2               
00CF4A  2               LAB_PPFS
00CF4A  2  20 3B CD           JSR   LAB_1BF7          ; process expression in parenthesis
00CF4D  2  4C 1A CC           JMP   LAB_CTST          ; check if source is string then do function,
00CF50  2                                             ; else do type mismatch
00CF50  2               
00CF50  2               ; process numeric expression in parenthesis
00CF50  2               
00CF50  2               LAB_PPFN
00CF50  2  20 3B CD           JSR   LAB_1BF7          ; process expression in parenthesis
00CF53  2  4C 18 CC           JMP   LAB_CTNM          ; check if source is numeric then do function,
00CF56  2                                             ; else do type mismatch
00CF56  2               
00CF56  2               ; set numeric data type and increment BASIC execute pointer
00CF56  2               
00CF56  2               LAB_PPBI
00CF56  2  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
00CF58  2  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then do function
00CF5B  2               
00CF5B  2               ; process string for LEFT$, RIGHT$ or MID$
00CF5B  2               
00CF5B  2               LAB_LRMS
00CF5B  2  20 31 CC           JSR   LAB_EVEZ          ; evaluate (should be string) expression
00CF5E  2  20 4D CD           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
00CF61  2  20 1A CC           JSR   LAB_CTST          ; check if source is string, else do type mismatch
00CF64  2               
00CF64  2  68                 PLA                     ; get function jump vector low byte
00CF65  2  AA                 TAX                     ; save functions jump vector low byte
00CF66  2  68                 PLA                     ; get function jump vector high byte
00CF67  2  A8                 TAY                     ; save functions jump vector high byte
00CF68  2  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
00CF6A  2  48                 PHA                     ; push string pointer high byte
00CF6B  2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
00CF6D  2  48                 PHA                     ; push string pointer low byte
00CF6E  2  98                 TYA                     ; get function jump vector high byte back
00CF6F  2  48                 PHA                     ; save functions jump vector high byte
00CF70  2  8A                 TXA                     ; get function jump vector low byte back
00CF71  2  48                 PHA                     ; save functions jump vector low byte
00CF72  2  20 8F D7           JSR   LAB_GTBY          ; get byte parameter
00CF75  2  8A                 TXA                     ; copy byte parameter to A
00CF76  2  60                 RTS                     ; go do function
00CF77  2               
00CF77  2               ; process numeric expression(s) for BIN$ or HEX$
00CF77  2               
00CF77  2               LAB_BHSS
00CF77  2  20 31 CC           JSR   LAB_EVEZ          ; process expression
00CF7A  2  20 18 CC           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00CF7D  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00CF7F  2  C9 98              CMP   #$98              ; compare with exponent = 2^24
00CF81  2  B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
00CF83  2               
00CF83  2  20 5A DC           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
00CF86  2  A2 02              LDX   #$02              ; 3 bytes to do
00CF88  2               LAB_CFAC
00CF88  2  B5 AD              LDA   FAC1_1,X          ; get byte from FAC1
00CF8A  2  95 11              STA   nums_1,X          ; save byte to temp
00CF8C  2  CA                 DEX                     ; decrement index
00CF8D  2  10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
00CF8F  2               
00CF8F  2  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
00CF92  2  A2 00              LDX   #$00              ; set default to no leading "0"s
00CF94  2  C9 29              CMP   #')'              ; compare with close bracket
00CF96  2  F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
00CF98  2               
00CF98  2  20 DA D7           JSR   LAB_SCGB          ; scan for "," and get byte
00CF9B  2  20 C2 00           JSR   LAB_GBYT          ; get last byte back
00CF9E  2  C9 29              CMP   #')'              ; is next character )
00CFA0  2  D0 01              BNE   LAB_BHER          ; if not ")" go do error
00CFA2  2               
00CFA2  2               LAB_1C54
00CFA2  2  60                 RTS                     ; else do function
00CFA3  2               
00CFA3  2               LAB_BHER
00CFA3  2  4C 14 D2           JMP   LAB_FCER          ; do function call error then warm start
00CFA6  2               
00CFA6  2               ; perform EOR
00CFA6  2               
00CFA6  2               ; added operator format is the same as AND or OR, precedence is the same as OR
00CFA6  2               
00CFA6  2               ; this bit worked first time but it took a while to sort out the operator table
00CFA6  2               ; pointers and offsets afterwards!
00CFA6  2               
00CFA6  2               LAB_EOR
00CFA6  2  20 CD CF           JSR   GetFirst          ; get first integer expression (no sign check)
00CFA9  2  45 5B              EOR   XOAw_l            ; EOR with expression 1 low byte
00CFAB  2  A8                 TAY                     ; save in Y
00CFAC  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CFAE  2  45 5C              EOR   XOAw_h            ; EOR with expression 1 high byte
00CFB0  2  4C 44 D3           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00CFB3  2               
00CFB3  2               ; perform OR
00CFB3  2               
00CFB3  2               LAB_OR
00CFB3  2  20 CD CF           JSR   GetFirst          ; get first integer expression (no sign check)
00CFB6  2  05 5B              ORA   XOAw_l            ; OR with expression 1 low byte
00CFB8  2  A8                 TAY                     ; save in Y
00CFB9  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CFBB  2  05 5C              ORA   XOAw_h            ; OR with expression 1 high byte
00CFBD  2  4C 44 D3           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00CFC0  2               
00CFC0  2               ; perform AND
00CFC0  2               
00CFC0  2               LAB_AND
00CFC0  2  20 CD CF           JSR   GetFirst          ; get first integer expression (no sign check)
00CFC3  2  25 5B              AND   XOAw_l            ; AND with expression 1 low byte
00CFC5  2  A8                 TAY                     ; save in Y
00CFC6  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CFC8  2  25 5C              AND   XOAw_h            ; AND with expression 1 high byte
00CFCA  2  4C 44 D3           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00CFCD  2               
00CFCD  2               ; get first value for OR, AND or EOR
00CFCD  2               
00CFCD  2               GetFirst
00CFCD  2  20 91 D1           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
00CFD0  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CFD2  2  85 5C              STA   XOAw_h            ; save it
00CFD4  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00CFD6  2  85 5B              STA   XOAw_l            ; save it
00CFD8  2  20 CD D8           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
00CFDB  2  20 91 D1           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
00CFDE  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00CFE0  2               LAB_1C95
00CFE0  2  60                 RTS
00CFE1  2               
00CFE1  2               ; perform comparisons
00CFE1  2               
00CFE1  2               ; do < compare
00CFE1  2               
00CFE1  2               LAB_LTHAN
00CFE1  2  20 1B CC           JSR   LAB_CKTM          ; type match check, set C for string
00CFE4  2  B0 13              BCS   LAB_1CAE          ; branch if string
00CFE6  2               
00CFE6  2                                             ; do numeric < compare
00CFE6  2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
00CFE8  2  09 7F              ORA   #$7F              ; set all non sign bits
00CFEA  2  25 B4              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
00CFEC  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00CFEE  2  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
00CFF0  2  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
00CFF2  2  20 21 DC           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
00CFF5  2  AA                 TAX                     ; copy result
00CFF6  2  4C 2A D0           JMP   LAB_1CE1          ; go evaluate result
00CFF9  2               
00CFF9  2                                             ; do string < compare
00CFF9  2               LAB_1CAE
00CFF9  2  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
00CFFB  2  C6 9B              DEC   comp_f            ; clear < bit in compare function flag
00CFFD  2  20 2F D6           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
00D000  2                                             ; space returns with A = length, X=pointer low byte,
00D000  2                                             ; Y=pointer high byte
00D000  2  85 AC              STA   str_ln            ; save length
00D002  2  86 AD              STX   str_pl            ; save string pointer low byte
00D004  2  84 AE              STY   str_ph            ; save string pointer high byte
00D006  2  A5 B5              LDA   FAC2_2            ; get descriptor pointer low byte
00D008  2  A4 B6              LDY   FAC2_3            ; get descriptor pointer high byte
00D00A  2  20 33 D6           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00D00D  2                                             ; returns with A = length, X=pointer low byte,
00D00D  2                                             ; Y=pointer high byte
00D00D  2  86 B5              STX   FAC2_2            ; save string pointer low byte
00D00F  2  84 B6              STY   FAC2_3            ; save string pointer high byte
00D011  2  AA                 TAX                     ; copy length
00D012  2  38                 SEC                     ; set carry for subtract
00D013  2  E5 AC              SBC   str_ln            ; subtract string 1 length
00D015  2  F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
00D017  2               
00D017  2  A9 01              LDA   #$01              ; set str 1 length > string 2 length
00D019  2  90 04              BCC   LAB_1CD6          ; branch if so
00D01B  2               
00D01B  2  A6 AC              LDX   str_ln            ; get string 1 length
00D01D  2  A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
00D01F  2               LAB_1CD6
00D01F  2  85 B0              STA   FAC1_s            ; save length compare
00D021  2  A0 FF              LDY   #$FF              ; set index
00D023  2  E8                 INX                     ; adjust for loop
00D024  2               LAB_1CDB
00D024  2  C8                 INY                     ; increment index
00D025  2  CA                 DEX                     ; decrement count
00D026  2  D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
00D028  2               
00D028  2  A6 B0              LDX   FAC1_s            ; get length compare back
00D02A  2               LAB_1CE1
00D02A  2  30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
00D02C  2               
00D02C  2  18                 CLC                     ; flag str 1 <= str 2
00D02D  2  90 0C              BCC   LAB_1CF2          ; go evaluate result
00D02F  2               
00D02F  2               LAB_1CE6
00D02F  2  B1 B5              LDA   (FAC2_2),Y        ; get string 2 byte
00D031  2  D1 AD              CMP   (FAC1_1),Y        ; compare with string 1 byte
00D033  2  F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
00D035  2               
00D035  2  A2 FF              LDX   #$FF              ; set str 1 < string 2
00D037  2  B0 02              BCS   LAB_1CF2          ; branch if so
00D039  2               
00D039  2  A2 01              LDX   #$01              ;  set str 1 > string 2
00D03B  2               LAB_1CF2
00D03B  2  E8                 INX                     ; x = 0, 1 or 2
00D03C  2  8A                 TXA                     ; copy to A
00D03D  2  2A                 ROL                     ; *2 (1, 2 or 4)
00D03E  2  25 63              AND   Cflag             ; AND with comparison evaluation flag
00D040  2  F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
00D042  2               
00D042  2  A9 FF              LDA   #$FF              ; else set result true
00D044  2               LAB_1CFB
00D044  2  4C 04 DC           JMP   LAB_27DB          ; save A as integer byte and return
00D047  2               
00D047  2               LAB_1CFE
00D047  2  20 4D CD           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
00D04A  2               
00D04A  2               ; perform DIM
00D04A  2               
00D04A  2               LAB_DIM
00D04A  2  AA                 TAX                     ; copy "DIM" flag to X
00D04B  2  20 9A D0           JSR   LAB_1D10          ; search for variable
00D04E  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00D051  2  D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
00D053  2               
00D053  2  60                 RTS
00D054  2               
00D054  2               ; perform << (left shift)
00D054  2               
00D054  2               LAB_LSHIFT
00D054  2  20 8A D0           JSR   GetPair           ; get integer expression and byte (no sign check)
00D057  2  A5 AE              LDA   FAC1_2            ; get expression high byte
00D059  2  A6 78              LDX   TempB             ; get shift count
00D05B  2  F0 22              BEQ   NoShift           ; branch if zero
00D05D  2               
00D05D  2  E0 10              CPX   #$10              ; compare bit count with 16d
00D05F  2  B0 23              BCS   TooBig            ; branch if >=
00D061  2               
00D061  2               Ls_loop
00D061  2  06 AF              ASL   FAC1_3            ; shift low byte
00D063  2  2A                 ROL                     ; shift high byte
00D064  2  CA                 DEX                     ; decrement bit count
00D065  2  D0 FA              BNE   Ls_loop           ; loop if shift not complete
00D067  2               
00D067  2  A4 AF              LDY   FAC1_3            ; get expression low byte
00D069  2  4C 44 D3           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00D06C  2               
00D06C  2               ; perform >> (right shift)
00D06C  2               
00D06C  2               LAB_RSHIFT
00D06C  2  20 8A D0           JSR   GetPair           ; get integer expression and byte (no sign check)
00D06F  2  A5 AE              LDA   FAC1_2            ; get expression high byte
00D071  2  A6 78              LDX   TempB             ; get shift count
00D073  2  F0 0A              BEQ   NoShift           ; branch if zero
00D075  2               
00D075  2  E0 10              CPX   #$10              ; compare bit count with 16d
00D077  2  B0 0B              BCS   TooBig            ; branch if >=
00D079  2               
00D079  2               Rs_loop
00D079  2  4A                 LSR                     ; shift high byte
00D07A  2  66 AF              ROR   FAC1_3            ; shift low byte
00D07C  2  CA                 DEX                     ; decrement bit count
00D07D  2  D0 FA              BNE   Rs_loop           ; loop if shift not complete
00D07F  2               
00D07F  2               NoShift
00D07F  2  A4 AF              LDY   FAC1_3            ; get expression low byte
00D081  2  4C 44 D3           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00D084  2               
00D084  2               TooBig
00D084  2  A9 00              LDA   #$00              ; clear high byte
00D086  2  A8                 TAY                     ; copy to low byte
00D087  2  4C 44 D3           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00D08A  2               
00D08A  2               GetPair
00D08A  2  20 92 D7           JSR   LAB_EVBY          ; evaluate byte expression, result in X
00D08D  2  86 78              STX   TempB             ; save it
00D08F  2  20 CD D8           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
00D092  2  4C 91 D1           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
00D095  2               
00D095  2               ; search for variable
00D095  2               
00D095  2               ; return pointer to variable in Cvaral/Cvarah
00D095  2               
00D095  2               LAB_GVAR
00D095  2  A2 00              LDX   #$00              ; set DIM flag = $00
00D097  2  20 C2 00           JSR   LAB_GBYT          ; scan memory (1st character)
00D09A  2               LAB_1D10
00D09A  2  86 5E              STX   Defdim            ; save DIM flag
00D09C  2               LAB_1D12
00D09C  2  85 93              STA   Varnm1            ; save 1st character
00D09E  2  29 7F              AND   #$7F              ; clear FN flag bit
00D0A0  2  20 09 D1           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
00D0A3  2  B0 03              BCS   LAB_1D1F          ; branch if ok
00D0A5  2               
00D0A5  2  4C 51 CD           JMP   LAB_SNER          ; else syntax error then warm start
00D0A8  2               
00D0A8  2                                             ; was variable name so ..
00D0A8  2               LAB_1D1F
00D0A8  2  A2 00              LDX   #$00              ; clear 2nd character temp
00D0AA  2  86 5F              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
00D0AC  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
00D0AF  2  90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
00D0B1  2               
00D0B1  2                                             ; 2nd character wasn't "0" to "9" so ..
00D0B1  2  20 09 D1           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
00D0B4  2  90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
00D0B6  2               
00D0B6  2               LAB_1D2D
00D0B6  2  AA                 TAX                     ; copy 2nd character
00D0B7  2               
00D0B7  2                                             ; ignore further (valid) characters in the variable name
00D0B7  2               LAB_1D2E
00D0B7  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
00D0BA  2  90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
00D0BC  2               
00D0BC  2  20 09 D1           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
00D0BF  2  B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
00D0C1  2               
00D0C1  2                                             ; check if string variable
00D0C1  2               LAB_1D38
00D0C1  2  C9 24              CMP   #'$'              ; compare with "$"
00D0C3  2  D0 0B              BNE   LAB_1D47          ; branch if not string
00D0C5  2               
00D0C5  2               ; to introduce a new variable type (% suffix for integers say) then this branch
00D0C5  2               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
00D0C5  2               
00D0C5  2                                             ; type is string
00D0C5  2  A9 FF              LDA   #$FF              ; set data type = string
00D0C7  2  85 5F              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
00D0C9  2  8A                 TXA                     ; get 2nd character back
00D0CA  2  09 80              ORA   #$80              ; set top bit (indicate string var)
00D0CC  2  AA                 TAX                     ; copy back to 2nd character temp
00D0CD  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00D0D0  2               
00D0D0  2               ; after we have determined the variable type we need to come back here to determine
00D0D0  2               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
00D0D0  2               
00D0D0  2               
00D0D0  2               LAB_1D47                      ; gets here with character after var name in A
00D0D0  2  86 94              STX   Varnm2            ; save 2nd character
00D0D2  2  05 61              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
00D0D4  2  C9 28              CMP   #'('              ; compare with "("
00D0D6  2  D0 03              BNE   LAB_1D53          ; branch if not "("
00D0D8  2               
00D0D8  2  4C A3 D1           JMP   LAB_1E17          ; go find, or make, array
00D0DB  2               
00D0DB  2               ; either find or create var
00D0DB  2               ; var name (1st two characters only!) is in Varnm1,Varnm2
00D0DB  2               
00D0DB  2                                             ; variable name wasn't var(... so look for plain var
00D0DB  2               LAB_1D53
00D0DB  2  A9 00              LDA   #$00              ; clear A
00D0DD  2  85 61              STA   Sufnxf            ; clear subscript/FNX flag
00D0DF  2  A5 7B              LDA   Svarl             ; get start of vars low byte
00D0E1  2  A6 7C              LDX   Svarh             ; get start of vars high byte
00D0E3  2  A0 00              LDY   #$00              ; clear index
00D0E5  2               LAB_1D5D
00D0E5  2  86 AB              STX   Vrschh            ; save search address high byte
00D0E7  2               LAB_1D5F
00D0E7  2  85 AA              STA   Vrschl            ; save search address low byte
00D0E9  2  E4 7E              CPX   Sarryh            ; compare high address with var space end
00D0EB  2  D0 04              BNE   LAB_1D69          ; skip next compare if <>
00D0ED  2               
00D0ED  2                                             ; high addresses were = so compare low addresses
00D0ED  2  C5 7D              CMP   Sarryl            ; compare low address with var space end
00D0EF  2  F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
00D0F1  2               
00D0F1  2               LAB_1D69
00D0F1  2  A5 93              LDA   Varnm1            ; get 1st character of var to find
00D0F3  2  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 1st character
00D0F5  2  D0 08              BNE   LAB_1D77          ; branch if no match
00D0F7  2               
00D0F7  2                                             ; 1st characters match so compare 2nd characters
00D0F7  2  A5 94              LDA   Varnm2            ; get 2nd character of var to find
00D0F9  2  C8                 INY                     ; index to point to variable name 2nd character
00D0FA  2  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 2nd character
00D0FC  2  F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
00D0FE  2               
00D0FE  2  88                 DEY                     ; else decrement index (now = $00)
00D0FF  2               LAB_1D77
00D0FF  2  18                 CLC                     ; clear carry for add
00D100  2  A5 AA              LDA   Vrschl            ; get search address low byte
00D102  2  69 06              ADC   #$06              ; +6 (offset to next var name)
00D104  2  90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
00D106  2               
00D106  2  E8                 INX                     ; else increment high byte
00D107  2  D0 DC              BNE   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
00D109  2               
00D109  2               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
00D109  2               
00D109  2               LAB_CASC
00D109  2  C9 61              CMP   #'a'              ; compare with "a"
00D10B  2  B0 0A              BCS   LAB_1D83          ; go check <"z"+1
00D10D  2               
00D10D  2               ; check byte, return C=0 if<"A" or >"Z"
00D10D  2               
00D10D  2               LAB_1D82
00D10D  2  C9 41              CMP   #'A'              ; compare with "A"
00D10F  2  90 05              BCC   LAB_1D8A          ; exit if less
00D111  2               
00D111  2                                             ; carry is set
00D111  2  E9 5B              SBC   #$5B              ; subtract "Z"+1
00D113  2  38                 SEC                     ; set carry
00D114  2  E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
00D116  2                                             ; carry clear if byte>$5A
00D116  2               LAB_1D8A
00D116  2  60                 RTS
00D117  2               
00D117  2               LAB_1D83
00D117  2  E9 7B              SBC   #$7B              ; subtract "z"+1
00D119  2  38                 SEC                     ; set carry
00D11A  2  E9 85              SBC   #$85              ; subtract $85 (restore byte)
00D11C  2                                             ; carry clear if byte>$7A
00D11C  2  60                 RTS
00D11D  2               
00D11D  2                                             ; reached end of variable mem without match
00D11D  2                                             ; .. so create new variable
00D11D  2               LAB_1D8B
00D11D  2  68                 PLA                     ; pop return address low byte
00D11E  2  48                 PHA                     ; push return address low byte
00D11F  2               LAB_1C18p2  = LAB_1C18+2
00D11F  2  C9 26              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
00D121  2  D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
00D123  2               
00D123  2               ; This will only drop through if the call was from LAB_1C18 and is only called
00D123  2               ; from there if it is searching for a variable from the RHS of a LET a=b statement
00D123  2               ; it prevents the creation of variables not assigned a value.
00D123  2               
00D123  2               ; value returned by this is either numeric zero (exponent byte is $00) or null string
00D123  2               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
00D123  2               
00D123  2               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
00D123  2               
00D123  2               ; this is where you would put the undefined variable error call e.g.
00D123  2               
00D123  2               ;                             ; variable doesn't exist so flag error
00D123  2               ;     LDX   #$24              ; error code $24 ("undefined variable" error)
00D123  2               ;     JMP   LAB_XERR          ; do error #X then warm start
00D123  2               
00D123  2               ; the above code has been tested and works a treat! (it replaces the three code lines
00D123  2               ; below)
00D123  2               
00D123  2                                             ; else return dummy null value
00D123  2  A9 56              LDA   #<LAB_1D96        ; low byte point to $00,$00
00D125  2                                             ; (uses part of misc constants table)
00D125  2  A0 F7              LDY   #>LAB_1D96        ; high byte point to $00,$00
00D127  2  60                 RTS
00D128  2               
00D128  2                                             ; create new numeric variable
00D128  2               LAB_1D98
00D128  2  A5 7D              LDA   Sarryl            ; get var mem end low byte
00D12A  2  A4 7E              LDY   Sarryh            ; get var mem end high byte
00D12C  2  85 AA              STA   Ostrtl            ; save old block start low byte
00D12E  2  84 AB              STY   Ostrth            ; save old block start high byte
00D130  2  A5 7F              LDA   Earryl            ; get array mem end low byte
00D132  2  A4 80              LDY   Earryh            ; get array mem end high byte
00D134  2  85 A6              STA   Obendl            ; save old block end low byte
00D136  2  84 A7              STY   Obendh            ; save old block end high byte
00D138  2  18                 CLC                     ; clear carry for add
00D139  2  69 06              ADC   #$06              ; +6 (space for one var)
00D13B  2  90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
00D13D  2               
00D13D  2  C8                 INY                     ; else increment high byte
00D13E  2               LAB_1DAE
00D13E  2  85 A4              STA   Nbendl            ; set new block end low byte
00D140  2  84 A5              STY   Nbendh            ; set new block end high byte
00D142  2  20 CB C0           JSR   LAB_11CF          ; open up space in memory
00D145  2  A5 A4              LDA   Nbendl            ; get new start low byte
00D147  2  A4 A5              LDY   Nbendh            ; get new start high byte (-$100)
00D149  2  C8                 INY                     ; correct high byte
00D14A  2  85 7D              STA   Sarryl            ; save new var mem end low byte
00D14C  2  84 7E              STY   Sarryh            ; save new var mem end high byte
00D14E  2  A0 00              LDY   #$00              ; clear index
00D150  2  A5 93              LDA   Varnm1            ; get var name 1st character
00D152  2  91 AA              STA   (Vrschl),Y        ; save var name 1st character
00D154  2  C8                 INY                     ; increment index
00D155  2  A5 94              LDA   Varnm2            ; get var name 2nd character
00D157  2  91 AA              STA   (Vrschl),Y        ; save var name 2nd character
00D159  2  A9 00              LDA   #$00              ; clear A
00D15B  2  C8                 INY                     ; increment index
00D15C  2  91 AA              STA   (Vrschl),Y        ; initialise var byte
00D15E  2  C8                 INY                     ; increment index
00D15F  2  91 AA              STA   (Vrschl),Y        ; initialise var byte
00D161  2  C8                 INY                     ; increment index
00D162  2  91 AA              STA   (Vrschl),Y        ; initialise var byte
00D164  2  C8                 INY                     ; increment index
00D165  2  91 AA              STA   (Vrschl),Y        ; initialise var byte
00D167  2               
00D167  2                                             ; found a match for var ((Vrschl) = ptr)
00D167  2               LAB_1DD7
00D167  2  A5 AA              LDA   Vrschl            ; get var address low byte
00D169  2  18                 CLC                     ; clear carry for add
00D16A  2  69 02              ADC   #$02              ; +2 (offset past var name bytes)
00D16C  2  A4 AB              LDY   Vrschh            ; get var address high byte
00D16E  2  90 01              BCC   LAB_1DE1          ; branch if no overflow from add
00D170  2               
00D170  2  C8                 INY                     ; else increment high byte
00D171  2               LAB_1DE1
00D171  2  85 95              STA   Cvaral            ; save current var address low byte
00D173  2  84 96              STY   Cvarah            ; save current var address high byte
00D175  2  60                 RTS
00D176  2               
00D176  2               ; set-up array pointer (Adatal/h) to first element in array
00D176  2               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
00D176  2               
00D176  2               LAB_1DE6
00D176  2  A5 5D              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
00D178  2  0A                 ASL                     ; *2 (also clears the carry !)
00D179  2  69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
00D17B  2  65 AA              ADC   Astrtl            ; add array start pointer low byte
00D17D  2  A4 AB              LDY   Astrth            ; get array pointer high byte
00D17F  2  90 01              BCC   LAB_1DF2          ; branch if no overflow
00D181  2               
00D181  2  C8                 INY                     ; else increment high byte
00D182  2               LAB_1DF2
00D182  2  85 A4              STA   Adatal            ; save array data pointer low byte
00D184  2  84 A5              STY   Adatah            ; save array data pointer high byte
00D186  2  60                 RTS
00D187  2               
00D187  2               ; evaluate integer expression
00D187  2               
00D187  2               LAB_EVIN
00D187  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00D18A  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D18D  2                                             ; else do type mismatch
00D18D  2               
00D18D  2               ; evaluate integer expression (no check)
00D18D  2               
00D18D  2               LAB_EVPI
00D18D  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00D18F  2  30 0D              BMI   LAB_1E12          ; do function call error if -ve
00D191  2               
00D191  2               ; evaluate integer expression (no sign check)
00D191  2               
00D191  2               LAB_EVIR
00D191  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D193  2  C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
00D195  2  90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
00D197  2               
00D197  2  A9 5D              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
00D199  2  A0 F7              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
00D19B  2  20 21 DC           JSR   LAB_27F8          ; compare FAC1 with (AY)
00D19E  2               LAB_1E12
00D19E  2  D0 74              BNE   LAB_FCER          ; if <> do function call error then warm start
00D1A0  2               
00D1A0  2               LAB_1E14
00D1A0  2  4C 5A DC           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
00D1A3  2               
00D1A3  2               ; find or make array
00D1A3  2               
00D1A3  2               LAB_1E17
00D1A3  2  A5 5E              LDA   Defdim            ; get DIM flag
00D1A5  2  48                 PHA                     ; push it
00D1A6  2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
00D1A8  2  48                 PHA                     ; push it
00D1A9  2  A0 00              LDY   #$00              ; clear dimensions count
00D1AB  2               
00D1AB  2               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
00D1AB  2               
00D1AB  2               LAB_1E1F
00D1AB  2  98                 TYA                     ; copy dimensions count
00D1AC  2  48                 PHA                     ; save it
00D1AD  2  A5 94              LDA   Varnm2            ; get array name 2nd byte
00D1AF  2  48                 PHA                     ; save it
00D1B0  2  A5 93              LDA   Varnm1            ; get array name 1st byte
00D1B2  2  48                 PHA                     ; save it
00D1B3  2  20 87 D1           JSR   LAB_EVIN          ; evaluate integer expression
00D1B6  2  68                 PLA                     ; pull array name 1st byte
00D1B7  2  85 93              STA   Varnm1            ; restore array name 1st byte
00D1B9  2  68                 PLA                     ; pull array name 2nd byte
00D1BA  2  85 94              STA   Varnm2            ; restore array name 2nd byte
00D1BC  2  68                 PLA                     ; pull dimensions count
00D1BD  2  A8                 TAY                     ; restore it
00D1BE  2  BA                 TSX                     ; copy stack pointer
00D1BF  2  BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
00D1C2  2  48                 PHA                     ; push it
00D1C3  2  BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
00D1C6  2  48                 PHA                     ; push it
00D1C7  2  A5 AE              LDA   FAC1_2            ; get this dimension size high byte
00D1C9  2  9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
00D1CC  2  A5 AF              LDA   FAC1_3            ; get this dimension size low byte
00D1CE  2  9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
00D1D1  2  C8                 INY                     ; increment dimensions count
00D1D2  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00D1D5  2  C9 2C              CMP   #','              ; compare with ","
00D1D7  2  F0 D2              BEQ   LAB_1E1F          ; if found go do next dimension
00D1D9  2               
00D1D9  2  84 5D              STY   Dimcnt            ; store dimensions count
00D1DB  2  20 3E CD           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00D1DE  2  68                 PLA                     ; pull data type flag
00D1DF  2  85 5F              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
00D1E1  2  68                 PLA                     ; pull DIM flag
00D1E2  2  85 5E              STA   Defdim            ; restore DIM flag
00D1E4  2  A6 7D              LDX   Sarryl            ; get array mem start low byte
00D1E6  2  A5 7E              LDA   Sarryh            ; get array mem start high byte
00D1E8  2               
00D1E8  2               ; now check to see if we are at the end of array memory (we would be if there were
00D1E8  2               ; no arrays).
00D1E8  2               
00D1E8  2               LAB_1E5C
00D1E8  2  86 AA              STX   Astrtl            ; save as array start pointer low byte
00D1EA  2  85 AB              STA   Astrth            ; save as array start pointer high byte
00D1EC  2  C5 80              CMP   Earryh            ; compare with array mem end high byte
00D1EE  2  D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
00D1F0  2               
00D1F0  2  E4 7F              CPX   Earryl            ; else compare with array mem end low byte
00D1F2  2  F0 39              BEQ   LAB_1EA1          ; go build array if not found
00D1F4  2               
00D1F4  2                                             ; search for array
00D1F4  2               LAB_1E68
00D1F4  2  A0 00              LDY   #$00              ; clear index
00D1F6  2  B1 AA              LDA   (Astrtl),Y        ; get array name first byte
00D1F8  2  C8                 INY                     ; increment index to second name byte
00D1F9  2  C5 93              CMP   Varnm1            ; compare with this array name first byte
00D1FB  2  D0 06              BNE   LAB_1E77          ; branch if no match
00D1FD  2               
00D1FD  2  A5 94              LDA   Varnm2            ; else get this array name second byte
00D1FF  2  D1 AA              CMP   (Astrtl),Y        ; compare with array name second byte
00D201  2  F0 16              BEQ   LAB_1E8D          ; array found so branch
00D203  2               
00D203  2                                             ; no match
00D203  2               LAB_1E77
00D203  2  C8                 INY                     ; increment index
00D204  2  B1 AA              LDA   (Astrtl),Y        ; get array size low byte
00D206  2  18                 CLC                     ; clear carry for add
00D207  2  65 AA              ADC   Astrtl            ; add array start pointer low byte
00D209  2  AA                 TAX                     ; copy low byte to X
00D20A  2  C8                 INY                     ; increment index
00D20B  2  B1 AA              LDA   (Astrtl),Y        ; get array size high byte
00D20D  2  65 AB              ADC   Astrth            ; add array mem pointer high byte
00D20F  2  90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
00D211  2               
00D211  2               ; do array bounds error
00D211  2               
00D211  2               LAB_1E85
00D211  2  A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
00D213  2  2C                 .byte $2C               ; makes next bit BIT LAB_08A2
00D214  2               
00D214  2               ; do function call error
00D214  2               
00D214  2               LAB_FCER
00D214  2  A2 08              LDX   #$08              ; error code $08 ("Function call" error)
00D216  2               LAB_1E8A
00D216  2  4C 49 C1           JMP   LAB_XERR          ; do error #X, then warm start
00D219  2               
00D219  2                                             ; found array, are we trying to dimension it?
00D219  2               LAB_1E8D
00D219  2  A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
00D21B  2  A5 5E              LDA   Defdim            ; get DIM flag
00D21D  2  D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
00D21F  2                                             ; start
00D21F  2               
00D21F  2               ; found the array and we're not dimensioning it so we must find an element in it
00D21F  2               
00D21F  2  20 76 D1           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
00D222  2                                             ; (Astrtl,Astrth points to start of array)
00D222  2  A5 5D              LDA   Dimcnt            ; get dimensions count
00D224  2  A0 04              LDY   #$04              ; set index to array's # of dimensions
00D226  2  D1 AA              CMP   (Astrtl),Y        ; compare with no of dimensions
00D228  2  D0 E7              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
00D22A  2                                             ; dimensions" error here .. if we want a different
00D22A  2                                             ; error message
00D22A  2               
00D22A  2  4C B0 D2           JMP   LAB_1F28          ; found array so go get element
00D22D  2                                             ; (could jump to LAB_1F28 as all LAB_1F24 does is take
00D22D  2                                             ; Dimcnt and save it at (Astrtl),Y which is already the
00D22D  2                                             ; same or we would have taken the BNE)
00D22D  2               
00D22D  2                                             ; array not found, so build it
00D22D  2               LAB_1EA1
00D22D  2  20 76 D1           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
00D230  2                                             ; (Astrtl,Astrth points to start of array)
00D230  2  20 18 C1           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
00D233  2                                             ; addr to check is in AY (low/high)
00D233  2  A0 00              LDY   #$00              ; clear Y (don't need to clear A)
00D235  2  84 BB              STY   Aspth             ; clear array data size high byte
00D237  2  A5 93              LDA   Varnm1            ; get variable name 1st byte
00D239  2  91 AA              STA   (Astrtl),Y        ; save array name 1st byte
00D23B  2  C8                 INY                     ; increment index
00D23C  2  A5 94              LDA   Varnm2            ; get variable name 2nd byte
00D23E  2  91 AA              STA   (Astrtl),Y        ; save array name 2nd byte
00D240  2  A5 5D              LDA   Dimcnt            ; get dimensions count
00D242  2  A0 04              LDY   #$04              ; index to dimension count
00D244  2  84 BA              STY   Asptl             ; set array data size low byte (four bytes per element)
00D246  2  91 AA              STA   (Astrtl),Y        ; set array's dimensions count
00D248  2               
00D248  2                                             ; now calculate the size of the data space for the array
00D248  2  18                 CLC                     ; clear carry for add (clear on subsequent loops)
00D249  2               LAB_1EC0
00D249  2  A2 0B              LDX   #$0B              ; set default dimension value low byte
00D24B  2  A9 00              LDA   #$00              ; set default dimension value high byte
00D24D  2  24 5E              BIT   Defdim            ; test default DIM flag
00D24F  2  50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
00D251  2               
00D251  2  68                 PLA                     ; else pull dimension value low byte
00D252  2  69 01              ADC   #$01              ; +1 (allow for zeroeth element)
00D254  2  AA                 TAX                     ; copy low byte to X
00D255  2  68                 PLA                     ; pull dimension value high byte
00D256  2  69 00              ADC   #$00              ; add carry from low byte
00D258  2               
00D258  2               LAB_1ED0
00D258  2  C8                 INY                     ; index to dimension value high byte
00D259  2  91 AA              STA   (Astrtl),Y        ; save dimension value high byte
00D25B  2  C8                 INY                     ; index to dimension value high byte
00D25C  2  8A                 TXA                     ; get dimension value low byte
00D25D  2  91 AA              STA   (Astrtl),Y        ; save dimension value low byte
00D25F  2  20 FF D2           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
00D262  2  86 BA              STX   Asptl             ; save array data size low byte
00D264  2  85 BB              STA   Aspth             ; save array data size high byte
00D266  2  A4 71              LDY   ut1_pl            ; restore index (saved by subroutine)
00D268  2  C6 5D              DEC   Dimcnt            ; decrement dimensions count
00D26A  2  D0 DD              BNE   LAB_1EC0          ; loop while not = 0
00D26C  2               
00D26C  2  65 A5              ADC   Adatah            ; add size high byte to first element high byte
00D26E  2                                             ; (carry is always clear here)
00D26E  2  B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
00D270  2               
00D270  2  85 A5              STA   Adatah            ; save end of array high byte
00D272  2  A8                 TAY                     ; copy end high byte to Y
00D273  2  8A                 TXA                     ; get array size low byte
00D274  2  65 A4              ADC   Adatal            ; add array start low byte
00D276  2  90 03              BCC   LAB_1EF3          ; branch if no carry
00D278  2               
00D278  2  C8                 INY                     ; else increment end of array high byte
00D279  2  F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
00D27B  2               
00D27B  2                                             ; set-up mostly complete, now zero the array
00D27B  2               LAB_1EF3
00D27B  2  20 18 C1           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
00D27E  2                                             ; addr to check is in AY (low/high)
00D27E  2  85 7F              STA   Earryl            ; save array mem end low byte
00D280  2  84 80              STY   Earryh            ; save array mem end high byte
00D282  2  A9 00              LDA   #$00              ; clear byte for array clear
00D284  2  E6 BB              INC   Aspth             ; increment array size high byte (now block count)
00D286  2  A4 BA              LDY   Asptl             ; get array size low byte (now index to block)
00D288  2  F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
00D28A  2               
00D28A  2               LAB_1F02
00D28A  2  88                 DEY                     ; decrement index (do 0 to n-1)
00D28B  2  91 A4              STA   (Adatal),Y        ; zero byte
00D28D  2  D0 FB              BNE   LAB_1F02          ; loop until this block done
00D28F  2               
00D28F  2               LAB_1F07
00D28F  2  C6 A5              DEC   Adatah            ; decrement array pointer high byte
00D291  2  C6 BB              DEC   Aspth             ; decrement block count high byte
00D293  2  D0 F5              BNE   LAB_1F02          ; loop until all blocks done
00D295  2               
00D295  2  E6 A5              INC   Adatah            ; correct for last loop
00D297  2  38                 SEC                     ; set carry for subtract
00D298  2  A0 02              LDY   #$02              ; index to array size low byte
00D29A  2  A5 7F              LDA   Earryl            ; get array mem end low byte
00D29C  2  E5 AA              SBC   Astrtl            ; subtract array start low byte
00D29E  2  91 AA              STA   (Astrtl),Y        ; save array size low byte
00D2A0  2  C8                 INY                     ; index to array size high byte
00D2A1  2  A5 80              LDA   Earryh            ; get array mem end high byte
00D2A3  2  E5 AB              SBC   Astrth            ; subtract array start high byte
00D2A5  2  91 AA              STA   (Astrtl),Y        ; save array size high byte
00D2A7  2  A5 5E              LDA   Defdim            ; get default DIM flag
00D2A9  2  D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
00D2AB  2               
00D2AB  2                                             ; else, find element
00D2AB  2  C8                 INY                     ; index to # of dimensions
00D2AC  2               
00D2AC  2               LAB_1F24
00D2AC  2  B1 AA              LDA   (Astrtl),Y        ; get array's dimension count
00D2AE  2  85 5D              STA   Dimcnt            ; save it
00D2B0  2               
00D2B0  2               ; we have found, or built, the array. now we need to find the element
00D2B0  2               
00D2B0  2               LAB_1F28
00D2B0  2  A9 00              LDA   #$00              ; clear byte
00D2B2  2  85 BA              STA   Asptl             ; clear array data pointer low byte
00D2B4  2               LAB_1F2C
00D2B4  2  85 BB              STA   Aspth             ; save array data pointer high byte
00D2B6  2  C8                 INY                     ; increment index (point to array bound high byte)
00D2B7  2  68                 PLA                     ; pull array index low byte
00D2B8  2  AA                 TAX                     ; copy to X
00D2B9  2  85 AE              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
00D2BB  2  68                 PLA                     ; pull array index high byte
00D2BC  2  85 AF              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
00D2BE  2  D1 AA              CMP   (Astrtl),Y        ; compare with array bound high byte
00D2C0  2  90 0E              BCC   LAB_1F48          ; branch if within bounds
00D2C2  2               
00D2C2  2  D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
00D2C4  2               
00D2C4  2                                             ; else high byte was = so test low bytes
00D2C4  2  C8                 INY                     ; index to array bound low byte
00D2C5  2  8A                 TXA                     ; get array index low byte
00D2C6  2  D1 AA              CMP   (Astrtl),Y        ; compare with array bound low byte
00D2C8  2  90 07              BCC   LAB_1F49          ; branch if within bounds
00D2CA  2               
00D2CA  2               LAB_1F42
00D2CA  2  4C 11 D2           JMP   LAB_1E85          ; else do array bounds error
00D2CD  2               
00D2CD  2               LAB_1F45
00D2CD  2  4C 47 C1           JMP   LAB_OMER          ; do "Out of memory" error then warm start
00D2D0  2               
00D2D0  2               LAB_1F48
00D2D0  2  C8                 INY                     ; index to array bound low byte
00D2D1  2               LAB_1F49
00D2D1  2  A5 BB              LDA   Aspth             ; get array data pointer high byte
00D2D3  2  05 BA              ORA   Asptl             ; OR with array data pointer low byte
00D2D5  2  F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
00D2D7  2               
00D2D7  2  20 FF D2           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
00D2DA  2  8A                 TXA                     ; get result low byte
00D2DB  2  65 AE              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
00D2DD  2  AA                 TAX                     ; save result low byte
00D2DE  2  98                 TYA                     ; get result high byte
00D2DF  2  A4 71              LDY   ut1_pl            ; restore index
00D2E1  2               LAB_1F5A
00D2E1  2  65 AF              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
00D2E3  2  86 BA              STX   Asptl             ; save array data pointer low byte
00D2E5  2  C6 5D              DEC   Dimcnt            ; decrement dimensions count
00D2E7  2  D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
00D2E9  2               
00D2E9  2  06 BA              ASL   Asptl             ; array data pointer low byte * 2
00D2EB  2  2A                 ROL                     ; array data pointer high byte * 2
00D2EC  2  06 BA              ASL   Asptl             ; array data pointer low byte * 4
00D2EE  2  2A                 ROL                     ; array data pointer high byte * 4
00D2EF  2  A8                 TAY                     ; copy high byte
00D2F0  2  A5 BA              LDA   Asptl             ; get low byte
00D2F2  2  65 A4              ADC   Adatal            ; add array data start pointer low byte
00D2F4  2  85 95              STA   Cvaral            ; save as current var address low byte
00D2F6  2  98                 TYA                     ; get high byte back
00D2F7  2  65 A5              ADC   Adatah            ; add array data start pointer high byte
00D2F9  2  85 96              STA   Cvarah            ; save as current var address high byte
00D2FB  2  A8                 TAY                     ; copy high byte to Y
00D2FC  2  A5 95              LDA   Cvaral            ; get current var address low byte
00D2FE  2               LAB_1F7B
00D2FE  2  60                 RTS
00D2FF  2               
00D2FF  2               ; does XY = (Astrtl),Y * (Asptl)
00D2FF  2               
00D2FF  2               LAB_1F7C
00D2FF  2  84 71              STY   ut1_pl            ; save index
00D301  2  B1 AA              LDA   (Astrtl),Y        ; get dimension size low byte
00D303  2  85 76              STA   dims_l            ; save dimension size low byte
00D305  2  88                 DEY                     ; decrement index
00D306  2  B1 AA              LDA   (Astrtl),Y        ; get dimension size high byte
00D308  2  85 77              STA   dims_h            ; save dimension size high byte
00D30A  2               
00D30A  2  A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
00D30C  2  85 A8              STA   numbit            ; save bit count
00D30E  2  A2 00              LDX   #$00              ; clear result low byte
00D310  2  A0 00              LDY   #$00              ; clear result high byte
00D312  2               LAB_1F8F
00D312  2  8A                 TXA                     ; get result low byte
00D313  2  0A                 ASL                     ; *2
00D314  2  AA                 TAX                     ; save result low byte
00D315  2  98                 TYA                     ; get result high byte
00D316  2  2A                 ROL                     ; *2
00D317  2  A8                 TAY                     ; save result high byte
00D318  2  B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
00D31A  2               
00D31A  2  06 BA              ASL   Asptl             ; shift multiplier low byte
00D31C  2  26 BB              ROL   Aspth             ; shift multiplier high byte
00D31E  2  90 0B              BCC   LAB_1FA8          ; skip add if no carry
00D320  2               
00D320  2  18                 CLC                     ; else clear carry for add
00D321  2  8A                 TXA                     ; get result low byte
00D322  2  65 76              ADC   dims_l            ; add dimension size low byte
00D324  2  AA                 TAX                     ; save result low byte
00D325  2  98                 TYA                     ; get result high byte
00D326  2  65 77              ADC   dims_h            ; add dimension size high byte
00D328  2  A8                 TAY                     ; save result high byte
00D329  2  B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
00D32B  2               
00D32B  2               LAB_1FA8
00D32B  2  C6 A8              DEC   numbit            ; decrement bit count
00D32D  2  D0 E3              BNE   LAB_1F8F          ; loop until all done
00D32F  2               
00D32F  2  60                 RTS
00D330  2               
00D330  2               ; perform FRE()
00D330  2               
00D330  2               LAB_FRE
00D330  2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
00D332  2  10 03              BPL   LAB_1FB4          ; branch if numeric
00D334  2               
00D334  2  20 2F D6           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
00D337  2                                             ; space returns with A = length, X=$71=pointer low byte,
00D337  2                                             ; Y=$72=pointer high byte
00D337  2               
00D337  2                                             ; FRE(n) was numeric so do this
00D337  2               LAB_1FB4
00D337  2  20 CC D4           JSR   LAB_GARB          ; go do garbage collection
00D33A  2  38                 SEC                     ; set carry for subtract
00D33B  2  A5 81              LDA   Sstorl            ; get bottom of string space low byte
00D33D  2  E5 7F              SBC   Earryl            ; subtract array mem end low byte
00D33F  2  A8                 TAY                     ; copy result to Y
00D340  2  A5 82              LDA   Sstorh            ; get bottom of string space high byte
00D342  2  E5 80              SBC   Earryh            ; subtract array mem end high byte
00D344  2               
00D344  2               ; save and convert integer AY to FAC1
00D344  2               
00D344  2               LAB_AYFC
00D344  2  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
00D346  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D348  2  84 AE              STY   FAC1_2            ; save FAC1 mantissa2
00D34A  2  A2 90              LDX   #$90              ; set exponent=2^16 (integer)
00D34C  2  4C 0C DC           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
00D34F  2               
00D34F  2               ; perform POS()
00D34F  2               
00D34F  2               LAB_POS
00D34F  2  A4 0E              LDY   TPos              ; get terminal position
00D351  2               
00D351  2               ; convert Y to byte in FAC1
00D351  2               
00D351  2               LAB_1FD0
00D351  2  A9 00              LDA   #$00              ; clear high byte
00D353  2  F0 EF              BEQ   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
00D355  2               
00D355  2               ; check not Direct (used by DEF and INPUT)
00D355  2               
00D355  2               LAB_CKRN
00D355  2  A6 88              LDX   Clineh            ; get current line high byte
00D357  2  E8                 INX                     ; increment it
00D358  2  D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
00D35A  2               
00D35A  2                                             ; else do illegal direct error
00D35A  2               LAB_1FD9
00D35A  2  A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
00D35C  2               LAB_1FDB
00D35C  2  4C 49 C1           JMP   LAB_XERR          ; go do error #X, then warm start
00D35F  2               
00D35F  2               ; perform DEF
00D35F  2               
00D35F  2               LAB_DEF
00D35F  2  20 90 D3           JSR   LAB_200B          ; check FNx syntax
00D362  2  85 9C              STA   func_l            ; save function pointer low byte
00D364  2  84 9D              STY   func_h            ; save function pointer high byte
00D366  2  20 55 D3           JSR   LAB_CKRN          ; check not Direct (back here if ok)
00D369  2  20 49 CD           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
00D36C  2  A9 80              LDA   #$80              ; set flag for FNx
00D36E  2  85 61              STA   Sufnxf            ; save subscript/FNx flag
00D370  2  20 95 D0           JSR   LAB_GVAR          ; get (var) address
00D373  2  20 18 CC           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00D376  2  20 3E CD           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00D379  2  A9 D7              LDA   #TK_EQUAL         ; get = token
00D37B  2  20 40 CD           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00D37E  2  A5 96              LDA   Cvarah            ; get current var address high byte
00D380  2  48                 PHA                     ; push it
00D381  2  A5 95              LDA   Cvaral            ; get current var address low byte
00D383  2  48                 PHA                     ; push it
00D384  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00D386  2  48                 PHA                     ; push it
00D387  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00D389  2  48                 PHA                     ; push it
00D38A  2  20 E0 C7           JSR   LAB_DATA          ; go perform DATA
00D38D  2  4C FF D3           JMP   LAB_207A          ; put execute pointer and variable pointer into function
00D390  2                                             ; and return
00D390  2               
00D390  2               ; check FNx syntax
00D390  2               
00D390  2               LAB_200B
00D390  2  A9 C4              LDA   #TK_FN            ; get FN" token
00D392  2  20 40 CD           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
00D395  2                                             ; return character after A
00D395  2  09 80              ORA   #$80              ; set FN flag bit
00D397  2  85 61              STA   Sufnxf            ; save FN flag so array variable test fails
00D399  2  20 9C D0           JSR   LAB_1D12          ; search for FN variable
00D39C  2  4C 18 CC           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
00D39F  2                                             ; mismatch
00D39F  2               
00D39F  2                                             ; Evaluate FNx
00D39F  2               LAB_201E
00D39F  2  20 90 D3           JSR   LAB_200B          ; check FNx syntax
00D3A2  2  48                 PHA                     ; push function pointer low byte
00D3A3  2  98                 TYA                     ; copy function pointer high byte
00D3A4  2  48                 PHA                     ; push function pointer high byte
00D3A5  2  20 49 CD           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
00D3A8  2  20 29 CC           JSR   LAB_EVEX          ; evaluate expression
00D3AB  2  20 3E CD           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
00D3AE  2  20 18 CC           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00D3B1  2  68                 PLA                     ; pop function pointer high byte
00D3B2  2  85 9D              STA   func_h            ; restore it
00D3B4  2  68                 PLA                     ; pop function pointer low byte
00D3B5  2  85 9C              STA   func_l            ; restore it
00D3B7  2  A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
00D3B9  2  A0 03              LDY   #$03              ; index to variable pointer high byte
00D3BB  2  B1 9C              LDA   (func_l),Y        ; get variable pointer high byte
00D3BD  2  F0 9D              BEQ   LAB_1FDB          ; if zero go do undefined function error
00D3BF  2               
00D3BF  2  85 96              STA   Cvarah            ; save variable address high byte
00D3C1  2  88                 DEY                     ; index to variable address low byte
00D3C2  2  B1 9C              LDA   (func_l),Y        ; get variable address low byte
00D3C4  2  85 95              STA   Cvaral            ; save variable address low byte
00D3C6  2  AA                 TAX                     ; copy address low byte
00D3C7  2               
00D3C7  2                                             ; now stack the function variable value before use
00D3C7  2  C8                 INY                     ; index to mantissa_3
00D3C8  2               LAB_2043
00D3C8  2  B1 95              LDA   (Cvaral),Y        ; get byte from variable
00D3CA  2  48                 PHA                     ; stack it
00D3CB  2  88                 DEY                     ; decrement index
00D3CC  2  10 FA              BPL   LAB_2043          ; loop until variable stacked
00D3CE  2               
00D3CE  2  A4 96              LDY   Cvarah            ; get variable address high byte
00D3D0  2  20 B1 DB           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
00D3D3  2                                             ; (function variable), return Y=0, always
00D3D3  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00D3D5  2  48                 PHA                     ; push it
00D3D6  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00D3D8  2  48                 PHA                     ; push it
00D3D9  2  B1 9C              LDA   (func_l),Y        ; get function execute pointer low byte
00D3DB  2  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
00D3DD  2  C8                 INY                     ; index to high byte
00D3DE  2  B1 9C              LDA   (func_l),Y        ; get function execute pointer high byte
00D3E0  2  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
00D3E2  2  A5 96              LDA   Cvarah            ; get variable address high byte
00D3E4  2  48                 PHA                     ; push it
00D3E5  2  A5 95              LDA   Cvaral            ; get variable address low byte
00D3E7  2  48                 PHA                     ; push it
00D3E8  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D3EB  2                                             ; else do type mismatch
00D3EB  2  68                 PLA                     ; pull variable address low byte
00D3EC  2  85 9C              STA   func_l            ; save variable address low byte
00D3EE  2  68                 PLA                     ; pull variable address high byte
00D3EF  2  85 9D              STA   func_h            ; save variable address high byte
00D3F1  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00D3F4  2  F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
00D3F6  2               
00D3F6  2  4C 51 CD           JMP   LAB_SNER          ; else syntax error then warm start
00D3F9  2               
00D3F9  2               ; restore Bpntrl,Bpntrh and function variable from stack
00D3F9  2               
00D3F9  2               LAB_2074
00D3F9  2  68                 PLA                     ; pull BASIC execute pointer low byte
00D3FA  2  85 C3              STA   Bpntrl            ; restore BASIC execute pointer low byte
00D3FC  2  68                 PLA                     ; pull BASIC execute pointer high byte
00D3FD  2  85 C4              STA   Bpntrh            ; restore BASIC execute pointer high byte
00D3FF  2               
00D3FF  2               ; put execute pointer and variable pointer into function
00D3FF  2               
00D3FF  2               LAB_207A
00D3FF  2  A0 00              LDY   #$00              ; clear index
00D401  2  68                 PLA                     ; pull BASIC execute pointer low byte
00D402  2  91 9C              STA   (func_l),Y        ; save to function
00D404  2  C8                 INY                     ; increment index
00D405  2  68                 PLA                     ; pull BASIC execute pointer high byte
00D406  2  91 9C              STA   (func_l),Y        ; save to function
00D408  2  C8                 INY                     ; increment index
00D409  2  68                 PLA                     ; pull current var address low byte
00D40A  2  91 9C              STA   (func_l),Y        ; save to function
00D40C  2  C8                 INY                     ; increment index
00D40D  2  68                 PLA                     ; pull current var address high byte
00D40E  2  91 9C              STA   (func_l),Y        ; save to function
00D410  2  60                 RTS
00D411  2               
00D411  2               ; perform STR$()
00D411  2               
00D411  2               LAB_STRS
00D411  2  20 18 CC           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00D414  2  20 9F DD           JSR   LAB_296E          ; convert FAC1 to string
00D417  2  A9 F0              LDA   #<Decssp1         ; set result string low pointer
00D419  2  A0 00              LDY   #>Decssp1         ; set result string high pointer
00D41B  2  F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
00D41D  2               
00D41D  2               ; Do string vector
00D41D  2               ; copy des_pl/h to des_2l/h and make string space A bytes long
00D41D  2               
00D41D  2               LAB_209C
00D41D  2  A6 AE              LDX   des_pl            ; get descriptor pointer low byte
00D41F  2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
00D421  2  86 9E              STX   des_2l            ; save descriptor pointer low byte
00D423  2  84 9F              STY   des_2h            ; save descriptor pointer high byte
00D425  2               
00D425  2               ; make string space A bytes long
00D425  2               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D425  2               
00D425  2               LAB_MSSP
00D425  2  20 9A D4           JSR   LAB_2115          ; make space in string memory for string A long
00D428  2                                             ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D428  2  86 AD              STX   str_pl            ; save string pointer low byte
00D42A  2  84 AE              STY   str_ph            ; save string pointer high byte
00D42C  2  85 AC              STA   str_ln            ; save length
00D42E  2  60                 RTS
00D42F  2               
00D42F  2               ; Scan, set up string
00D42F  2               ; print " terminated string to Sutill/Sutilh
00D42F  2               
00D42F  2               LAB_20AE
00D42F  2  A2 22              LDX   #$22              ; set terminator to "
00D431  2  86 5B              STX   Srchc             ; set search character (terminator 1)
00D433  2  86 5C              STX   Asrch             ; set terminator 2
00D435  2               
00D435  2               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
00D435  2               ; source is AY
00D435  2               
00D435  2               LAB_20B4
00D435  2  85 B8              STA   ssptr_l           ; store string start low byte
00D437  2  84 B9              STY   ssptr_h           ; store string start high byte
00D439  2  85 AD              STA   str_pl            ; save string pointer low byte
00D43B  2  84 AE              STY   str_ph            ; save string pointer high byte
00D43D  2  A0 FF              LDY   #$FF              ; set length to -1
00D43F  2               LAB_20BE
00D43F  2  C8                 INY                     ; increment length
00D440  2  B1 B8              LDA   (ssptr_l),Y       ; get byte from string
00D442  2  F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
00D444  2               
00D444  2  C5 5B              CMP   Srchc             ; compare with search character (terminator 1)
00D446  2  F0 04              BEQ   LAB_20CB          ; branch if terminator
00D448  2               
00D448  2  C5 5C              CMP   Asrch             ; compare with terminator 2
00D44A  2  D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
00D44C  2               
00D44C  2               LAB_20CB
00D44C  2  C9 22              CMP   #$22              ; compare with "
00D44E  2  F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
00D450  2               
00D450  2               LAB_20CF
00D450  2  18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
00D451  2               LAB_20D0
00D451  2  84 AC              STY   str_ln            ; save length in FAC1 exponent
00D453  2  98                 TYA                     ; copy length to A
00D454  2  65 B8              ADC   ssptr_l           ; add string start low byte
00D456  2  85 BA              STA   Sendl             ; save string end low byte
00D458  2  A6 B9              LDX   ssptr_h           ; get string start high byte
00D45A  2  90 01              BCC   LAB_20DC          ; branch if no low byte overflow
00D45C  2               
00D45C  2  E8                 INX                     ; else increment high byte
00D45D  2               LAB_20DC
00D45D  2  86 BB              STX   Sendh             ; save string end high byte
00D45F  2  A5 B9              LDA   ssptr_h           ; get string start high byte
00D461  2               ; *** begin RAM above code / Ibuff above EhBASIC patch V2 ***
00D461  2               ; *** replace
00D461  2               ;      CMP   #>Ram_base        ; compare with start of program memory
00D461  2               ;      BCS   LAB_RTST          ; branch if not in utility area
00D461  2               ; *** with
00D461  2  F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
00D463  2  C9 02              CMP   #>Ibuffs          ; compare with location of input buffer page
00D465  2  D0 0B              BNE   LAB_RTST          ; branch if not in utility area
00D467  2               LAB_MVST
00D467  2               ; *** end   RAM above code / Ibuff above EhBASIC patch V2 ***
00D467  2               
00D467  2                                             ; string in utility area, move to string memory
00D467  2  98                 TYA                     ; copy length to A
00D468  2  20 1D D4           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
00D46B  2                                             ; long
00D46B  2  A6 B8              LDX   ssptr_l           ; get string start low byte
00D46D  2  A4 B9              LDY   ssptr_h           ; get string start high byte
00D46F  2  20 10 D6           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
00D472  2               
00D472  2               ; check for space on descriptor stack then ..
00D472  2               ; put string address and length on descriptor stack and update stack pointers
00D472  2               
00D472  2               LAB_RTST
00D472  2  A6 65              LDX   next_s            ; get string stack pointer
00D474  2  E0 71              CPX   #des_sk+$09       ; compare with max+1
00D476  2  D0 05              BNE   LAB_20F8          ; branch if space on string stack
00D478  2               
00D478  2                                             ; else do string too complex error
00D478  2  A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
00D47A  2               LAB_20F5
00D47A  2  4C 49 C1           JMP   LAB_XERR          ; do error #X, then warm start
00D47D  2               
00D47D  2               ; put string address and length on descriptor stack and update stack pointers
00D47D  2               
00D47D  2               LAB_20F8
00D47D  2  A5 AC              LDA   str_ln            ; get string length
00D47F  2  95 00              STA   PLUS_0,X          ; put on string stack
00D481  2  A5 AD              LDA   str_pl            ; get string pointer low byte
00D483  2  95 01              STA   PLUS_1,X          ; put on string stack
00D485  2  A5 AE              LDA   str_ph            ; get string pointer high byte
00D487  2  95 02              STA   PLUS_2,X          ; put on string stack
00D489  2  A0 00              LDY   #$00              ; clear Y
00D48B  2  86 AE              STX   des_pl            ; save string descriptor pointer low byte
00D48D  2  84 AF              STY   des_ph            ; save string descriptor pointer high byte (always $00)
00D48F  2  88                 DEY                     ; Y = $FF
00D490  2  84 5F              STY   Dtypef            ; save data type flag, $FF=string
00D492  2  86 66              STX   last_sl           ; save old stack pointer (current top item)
00D494  2  E8                 INX                     ; update stack pointer
00D495  2  E8                 INX                     ; update stack pointer
00D496  2  E8                 INX                     ; update stack pointer
00D497  2  86 65              STX   next_s            ; save new top item value
00D499  2  60                 RTS
00D49A  2               
00D49A  2               ; Build descriptor
00D49A  2               ; make space in string memory for string A long
00D49A  2               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
00D49A  2               
00D49A  2               LAB_2115
00D49A  2  46 60              LSR   Gclctd            ; clear garbage collected flag (b7)
00D49C  2               
00D49C  2                                             ; make space for string A long
00D49C  2               LAB_2117
00D49C  2  48                 PHA                     ; save string length
00D49D  2  49 FF              EOR   #$FF              ; complement it
00D49F  2  38                 SEC                     ; set carry for subtract (twos comp add)
00D4A0  2  65 81              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
00D4A2  2  A4 82              LDY   Sstorh            ; get bottom of string space high byte
00D4A4  2  B0 01              BCS   LAB_2122          ; skip decrement if no underflow
00D4A6  2               
00D4A6  2  88                 DEY                     ; decrement bottom of string space high byte
00D4A7  2               LAB_2122
00D4A7  2  C4 80              CPY   Earryh            ; compare with array mem end high byte
00D4A9  2  90 11              BCC   LAB_2137          ; do out of memory error if less
00D4AB  2               
00D4AB  2  D0 04              BNE   LAB_212C          ; if not = skip next test
00D4AD  2               
00D4AD  2  C5 7F              CMP   Earryl            ; compare with array mem end low byte
00D4AF  2  90 0B              BCC   LAB_2137          ; do out of memory error if less
00D4B1  2               
00D4B1  2               LAB_212C
00D4B1  2  85 81              STA   Sstorl            ; save bottom of string space low byte
00D4B3  2  84 82              STY   Sstorh            ; save bottom of string space high byte
00D4B5  2  85 83              STA   Sutill            ; save string utility ptr low byte
00D4B7  2  84 84              STY   Sutilh            ; save string utility ptr high byte
00D4B9  2  AA                 TAX                     ; copy low byte to X
00D4BA  2  68                 PLA                     ; get string length back
00D4BB  2  60                 RTS
00D4BC  2               
00D4BC  2               LAB_2137
00D4BC  2  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
00D4BE  2  A5 60              LDA   Gclctd            ; get garbage collected flag
00D4C0  2  30 B8              BMI   LAB_20F5          ; if set then do error code X
00D4C2  2               
00D4C2  2  20 CC D4           JSR   LAB_GARB          ; else go do garbage collection
00D4C5  2  A9 80              LDA   #$80              ; flag for garbage collected
00D4C7  2  85 60              STA   Gclctd            ; set garbage collected flag
00D4C9  2  68                 PLA                     ; pull length
00D4CA  2  D0 D0              BNE   LAB_2117          ; go try again (loop always, length should never be = $00)
00D4CC  2               
00D4CC  2               ; garbage collection routine
00D4CC  2               
00D4CC  2               LAB_GARB
00D4CC  2  A6 85              LDX   Ememl             ; get end of mem low byte
00D4CE  2  A5 86              LDA   Ememh             ; get end of mem high byte
00D4D0  2               
00D4D0  2               ; re-run routine from last ending
00D4D0  2               
00D4D0  2               LAB_214B
00D4D0  2  86 81              STX   Sstorl            ; set string storage low byte
00D4D2  2  85 82              STA   Sstorh            ; set string storage high byte
00D4D4  2  A0 00              LDY   #$00              ; clear index
00D4D6  2  84 9D              STY   garb_h            ; clear working pointer high byte (flag no strings to move)
00D4D8  2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
00D4D8  2               ; *** add
00D4D8  2  84 9C              STY   garb_l            ; clear working pointer low byte (flag no strings to move)
00D4DA  2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
00D4DA  2  A5 7F              LDA   Earryl            ; get array mem end low byte
00D4DC  2  A6 80              LDX   Earryh            ; get array mem end high byte
00D4DE  2  85 AA              STA   Histrl            ; save as highest string low byte
00D4E0  2  86 AB              STX   Histrh            ; save as highest string high byte
00D4E2  2  A9 68              LDA   #des_sk           ; set descriptor stack pointer
00D4E4  2  85 71              STA   ut1_pl            ; save descriptor stack pointer low byte
00D4E6  2  84 72              STY   ut1_ph            ; save descriptor stack pointer high byte ($00)
00D4E8  2               LAB_2161
00D4E8  2  C5 65              CMP   next_s            ; compare with descriptor stack pointer
00D4EA  2  F0 05              BEQ   LAB_216A          ; branch if =
00D4EC  2               
00D4EC  2  20 52 D5           JSR   LAB_21D7          ; go garbage collect descriptor stack
00D4EF  2  F0 F7              BEQ   LAB_2161          ; loop always
00D4F1  2               
00D4F1  2                                             ; done stacked strings, now do string vars
00D4F1  2               LAB_216A
00D4F1  2  06 A0              ASL   g_step            ; set step size = $06
00D4F3  2  A5 7B              LDA   Svarl             ; get start of vars low byte
00D4F5  2  A6 7C              LDX   Svarh             ; get start of vars high byte
00D4F7  2  85 71              STA   ut1_pl            ; save as pointer low byte
00D4F9  2  86 72              STX   ut1_ph            ; save as pointer high byte
00D4FB  2               LAB_2176
00D4FB  2  E4 7E              CPX   Sarryh            ; compare start of arrays high byte
00D4FD  2  D0 04              BNE   LAB_217E          ; branch if no high byte match
00D4FF  2               
00D4FF  2  C5 7D              CMP   Sarryl            ; else compare start of arrays low byte
00D501  2  F0 05              BEQ   LAB_2183          ; branch if = var mem end
00D503  2               
00D503  2               LAB_217E
00D503  2  20 4C D5           JSR   LAB_21D1          ; go garbage collect strings
00D506  2  F0 F3              BEQ   LAB_2176          ; loop always
00D508  2               
00D508  2                                             ; done string vars, now do string arrays
00D508  2               LAB_2183
00D508  2  85 A4              STA   Nbendl            ; save start of arrays low byte as working pointer
00D50A  2  86 A5              STX   Nbendh            ; save start of arrays high byte as working pointer
00D50C  2  A9 04              LDA   #$04              ; set step size
00D50E  2  85 A0              STA   g_step            ; save step size
00D510  2               LAB_218B
00D510  2  A5 A4              LDA   Nbendl            ; get pointer low byte
00D512  2  A6 A5              LDX   Nbendh            ; get pointer high byte
00D514  2               LAB_218F
00D514  2  E4 80              CPX   Earryh            ; compare with array mem end high byte
00D516  2  D0 04              BNE   LAB_219A          ; branch if not at end
00D518  2               
00D518  2  C5 7F              CMP   Earryl            ; else compare with array mem end low byte
00D51A  2  F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
00D51C  2               
00D51C  2               LAB_219A
00D51C  2  85 71              STA   ut1_pl            ; save pointer low byte
00D51E  2  86 72              STX   ut1_ph            ; save pointer high byte
00D520  2  A0 02              LDY   #$02              ; set index
00D522  2  B1 71              LDA   (ut1_pl),Y        ; get array size low byte
00D524  2  65 A4              ADC   Nbendl            ; add start of this array low byte
00D526  2  85 A4              STA   Nbendl            ; save start of next array low byte
00D528  2  C8                 INY                     ; increment index
00D529  2  B1 71              LDA   (ut1_pl),Y        ; get array size high byte
00D52B  2  65 A5              ADC   Nbendh            ; add start of this array high byte
00D52D  2  85 A5              STA   Nbendh            ; save start of next array high byte
00D52F  2  A0 01              LDY   #$01              ; set index
00D531  2  B1 71              LDA   (ut1_pl),Y        ; get name second byte
00D533  2  10 DB              BPL   LAB_218B          ; skip if not string array
00D535  2               
00D535  2               ; was string array so ..
00D535  2               
00D535  2  A0 04              LDY   #$04              ; set index
00D537  2  B1 71              LDA   (ut1_pl),Y        ; get # of dimensions
00D539  2  0A                 ASL                     ; *2
00D53A  2  69 05              ADC   #$05              ; +5 (array header size)
00D53C  2  20 84 D5           JSR   LAB_2208          ; go set up for first element
00D53F  2               LAB_21C4
00D53F  2  E4 A5              CPX   Nbendh            ; compare with start of next array high byte
00D541  2  D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
00D543  2               
00D543  2  C5 A4              CMP   Nbendl            ; else compare element pointer low byte with next array
00D545  2                                             ; low byte
00D545  2  F0 CD              BEQ   LAB_218F          ; if equal then go do next array
00D547  2               
00D547  2               LAB_21CC
00D547  2  20 52 D5           JSR   LAB_21D7          ; go defrag array strings
00D54A  2  F0 F3              BEQ   LAB_21C4          ; go do next array string (loop always)
00D54C  2               
00D54C  2               ; defrag string variables
00D54C  2               ; enter with XA = variable pointer
00D54C  2               ; return with XA = next variable pointer
00D54C  2               
00D54C  2               LAB_21D1
00D54C  2  C8                 INY                     ; increment index (Y was $00)
00D54D  2  B1 71              LDA   (ut1_pl),Y        ; get var name byte 2
00D54F  2  10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
00D551  2               
00D551  2  C8                 INY                     ; else increment index
00D552  2               LAB_21D7
00D552  2  B1 71              LDA   (ut1_pl),Y        ; get string length
00D554  2  F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
00D556  2               
00D556  2  C8                 INY                     ; else increment index
00D557  2  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte
00D559  2  AA                 TAX                     ; copy to X
00D55A  2  C8                 INY                     ; increment index
00D55B  2  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte
00D55D  2  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
00D55F  2  90 06              BCC   LAB_21EC          ; branch if less
00D561  2               
00D561  2  D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
00D563  2               
00D563  2                                             ; high bytes were = so compare low bytes
00D563  2  E4 81              CPX   Sstorl            ; compare bottom of string space low byte
00D565  2  B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
00D567  2               
00D567  2                                             ; string pointer is < string storage pointer (pos in mem)
00D567  2               LAB_21EC
00D567  2  C5 AB              CMP   Histrh            ; compare to highest string high byte
00D569  2  90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
00D56B  2               
00D56B  2  D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
00D56D  2               
00D56D  2                                             ; high bytes were = so compare low bytes
00D56D  2  E4 AA              CPX   Histrl            ; compare to highest string low byte
00D56F  2  90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
00D571  2               
00D571  2                                             ; string is in string memory space
00D571  2               LAB_21F6
00D571  2  86 AA              STX   Histrl            ; save as new highest string low byte
00D573  2  85 AB              STA   Histrh            ; save as new highest string high byte
00D575  2  A5 71              LDA   ut1_pl            ; get start of vars(descriptors) low byte
00D577  2  A6 72              LDX   ut1_ph            ; get start of vars(descriptors) high byte
00D579  2  85 9C              STA   garb_l            ; save as working pointer low byte
00D57B  2  86 9D              STX   garb_h            ; save as working pointer high byte
00D57D  2  88                 DEY                     ; decrement index DIFFERS
00D57E  2  88                 DEY                     ; decrement index (should point to descriptor start)
00D57F  2  84 A2              STY   g_indx            ; save index pointer
00D581  2               
00D581  2                                             ; step pointer to next string
00D581  2               LAB_2206
00D581  2  18                 CLC                     ; clear carry for add
00D582  2               LAB_2207
00D582  2  A5 A0              LDA   g_step            ; get step size
00D584  2               LAB_2208
00D584  2  65 71              ADC   ut1_pl            ; add pointer low byte
00D586  2  85 71              STA   ut1_pl            ; save pointer low byte
00D588  2  90 02              BCC   LAB_2211          ; branch if no overflow
00D58A  2               
00D58A  2  E6 72              INC   ut1_ph            ; else increment high byte
00D58C  2               LAB_2211
00D58C  2  A6 72              LDX   ut1_ph            ; get pointer high byte
00D58E  2  A0 00              LDY   #$00              ; clear Y
00D590  2  60                 RTS
00D591  2               
00D591  2               ; search complete, now either exit or set-up and move string
00D591  2               
00D591  2               LAB_2216
00D591  2  C6 A0              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
00D593  2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
00D593  2               ; *** replace
00D593  2               ;      LDX   garb_h            ; get string to move high byte
00D593  2               ; *** with
00D593  2  A5 9D              LDA   garb_h            ; any string to move?
00D595  2  05 9C              ORA   garb_l
00D597  2               ; *** end   patch  2.22p5.5  garbage collection may overlap temporary strings
00D597  2  F0 F3              BEQ   LAB_2211          ; exit if nothing to move
00D599  2               
00D599  2  A4 A2              LDY   g_indx            ; get index byte back (points to descriptor)
00D59B  2  18                 CLC                     ; clear carry for add
00D59C  2  B1 9C              LDA   (garb_l),Y        ; get string length
00D59E  2  65 AA              ADC   Histrl            ; add highest string low byte
00D5A0  2  85 A6              STA   Obendl            ; save old block end low pointer
00D5A2  2  A5 AB              LDA   Histrh            ; get highest string high byte
00D5A4  2  69 00              ADC   #$00              ; add any carry
00D5A6  2  85 A7              STA   Obendh            ; save old block end high byte
00D5A8  2  A5 81              LDA   Sstorl            ; get bottom of string space low byte
00D5AA  2  A6 82              LDX   Sstorh            ; get bottom of string space high byte
00D5AC  2  85 A4              STA   Nbendl            ; save new block end low byte
00D5AE  2  86 A5              STX   Nbendh            ; save new block end high byte
00D5B0  2  20 D2 C0           JSR   LAB_11D6          ; open up space in memory, don't set array end
00D5B3  2  A4 A2              LDY   g_indx            ; get index byte
00D5B5  2  C8                 INY                     ; point to descriptor low byte
00D5B6  2  A5 A4              LDA   Nbendl            ; get string pointer low byte
00D5B8  2  91 9C              STA   (garb_l),Y        ; save new string pointer low byte
00D5BA  2  AA                 TAX                     ; copy string pointer low byte
00D5BB  2  E6 A5              INC   Nbendh            ; correct high byte (move sets high byte -1)
00D5BD  2  A5 A5              LDA   Nbendh            ; get new string pointer high byte
00D5BF  2  C8                 INY                     ; point to descriptor high byte
00D5C0  2  91 9C              STA   (garb_l),Y        ; save new string pointer high byte
00D5C2  2  4C D0 D4           JMP   LAB_214B          ; re-run routine from last ending
00D5C5  2                                             ; (but don't collect this string)
00D5C5  2               
00D5C5  2               ; concatenate
00D5C5  2               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
00D5C5  2               
00D5C5  2               LAB_224D
00D5C5  2  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
00D5C7  2  48                 PHA                     ; put on stack
00D5C8  2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
00D5CA  2  48                 PHA                     ; put on stack
00D5CB  2               ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00D5CB  2               ; *** add extra label to verify originating function
00D5CB  2               LAB_224Da
00D5CB  2               ; *** end patch    2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00D5CB  2  20 15 CD           JSR   LAB_GVAL          ; get value from line
00D5CE  2  20 1A CC           JSR   LAB_CTST          ; check if source is string, else do type mismatch
00D5D1  2  68                 PLA                     ; get descriptor pointer low byte back
00D5D2  2  85 B8              STA   ssptr_l           ; set pointer low byte
00D5D4  2  68                 PLA                     ; get descriptor pointer high byte back
00D5D5  2  85 B9              STA   ssptr_h           ; set pointer high byte
00D5D7  2  A0 00              LDY   #$00              ; clear index
00D5D9  2  B1 B8              LDA   (ssptr_l),Y       ; get length_1 from descriptor
00D5DB  2  18                 CLC                     ; clear carry for add
00D5DC  2  71 AE              ADC   (des_pl),Y        ; add length_2
00D5DE  2  90 05              BCC   LAB_226D          ; branch if no overflow
00D5E0  2               
00D5E0  2  A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
00D5E2  2  4C 49 C1           JMP   LAB_XERR          ; do error #X, then warm start
00D5E5  2               
00D5E5  2               LAB_226D
00D5E5  2  20 1D D4           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
00D5E8  2                                             ; long
00D5E8  2  20 02 D6           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
00D5EB  2  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
00D5ED  2  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
00D5EF  2  20 33 D6           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00D5F2  2                                             ; returns with A = length, ut1_pl = pointer low byte,
00D5F2  2                                             ; ut1_ph = pointer high byte
00D5F2  2  20 14 D6           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
00D5F5  2  A5 B8              LDA   ssptr_l           ;.set descriptor pointer low byte
00D5F7  2  A4 B9              LDY   ssptr_h           ;.set descriptor pointer high byte
00D5F9  2  20 33 D6           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00D5FC  2                                             ; returns with A = length, X=ut1_pl=pointer low byte,
00D5FC  2                                             ; Y=ut1_ph=pointer high byte
00D5FC  2  20 72 D4           JSR   LAB_RTST          ; check for space on descriptor stack then put string
00D5FF  2                                             ; address and length on descriptor stack and update stack
00D5FF  2                                             ; pointers
00D5FF  2  4C 40 CC           JMP   LAB_1ADB          ;.continue evaluation
00D602  2               
00D602  2               ; copy string from descriptor (sdescr) to (Sutill)
00D602  2               
00D602  2               LAB_228A
00D602  2  A0 00              LDY   #$00              ; clear index
00D604  2  B1 B8              LDA   (sdescr),Y        ; get string length
00D606  2  48                 PHA                     ; save on stack
00D607  2  C8                 INY                     ; increment index
00D608  2  B1 B8              LDA   (sdescr),Y        ; get source string pointer low byte
00D60A  2  AA                 TAX                     ; copy to X
00D60B  2  C8                 INY                     ; increment index
00D60C  2  B1 B8              LDA   (sdescr),Y        ; get source string pointer high byte
00D60E  2  A8                 TAY                     ; copy to Y
00D60F  2  68                 PLA                     ; get length back
00D610  2               
00D610  2               ; store string A bytes long from YX to (Sutill)
00D610  2               
00D610  2               LAB_2298
00D610  2  86 71              STX   ut1_pl            ; save source string pointer low byte
00D612  2  84 72              STY   ut1_ph            ; save source string pointer high byte
00D614  2               
00D614  2               ; store string A bytes long from (ut1_pl) to (Sutill)
00D614  2               
00D614  2               LAB_229C
00D614  2  AA                 TAX                     ; copy length to index (don't count with Y)
00D615  2  F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
00D617  2               
00D617  2  A0 00              LDY   #$00              ; zero pointer (copy forward)
00D619  2               LAB_22A0
00D619  2  B1 71              LDA   (ut1_pl),Y        ; get source byte
00D61B  2  91 83              STA   (Sutill),Y        ; save destination byte
00D61D  2               
00D61D  2  C8                 INY                     ; increment index
00D61E  2  CA                 DEX                     ; decrement counter
00D61F  2  D0 F8              BNE   LAB_22A0          ; loop while <> 0
00D621  2               
00D621  2  98                 TYA                     ; restore length from Y
00D622  2               LAB_22A9
00D622  2  18                 CLC                     ; clear carry for add
00D623  2  65 83              ADC   Sutill            ; add string utility ptr low byte
00D625  2  85 83              STA   Sutill            ; save string utility ptr low byte
00D627  2  90 02              BCC   LAB_22B2          ; branch if no carry
00D629  2               
00D629  2  E6 84              INC   Sutilh            ; else increment string utility ptr high byte
00D62B  2               LAB_22B2
00D62B  2  60                 RTS
00D62C  2               
00D62C  2               ; evaluate string
00D62C  2               
00D62C  2               LAB_EVST
00D62C  2  20 1A CC           JSR   LAB_CTST          ; check if source is string, else do type mismatch
00D62F  2               
00D62F  2               ; pop string off descriptor stack, or from top of string space
00D62F  2               ; returns with A = length, X=pointer low byte, Y=pointer high byte
00D62F  2               
00D62F  2               LAB_22B6
00D62F  2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
00D631  2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
00D633  2               
00D633  2               ; pop (YA) descriptor off stack or from top of string space
00D633  2               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
00D633  2               
00D633  2               LAB_22BA
00D633  2  85 71              STA   ut1_pl            ; save descriptor pointer low byte
00D635  2  84 72              STY   ut1_ph            ; save descriptor pointer high byte
00D637  2  20 64 D6           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
00D63A  2  08                 PHP                     ; save status flags
00D63B  2  A0 00              LDY   #$00              ; clear index
00D63D  2  B1 71              LDA   (ut1_pl),Y        ; get length from string descriptor
00D63F  2  48                 PHA                     ; put on stack
00D640  2  C8                 INY                     ; increment index
00D641  2  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
00D643  2  AA                 TAX                     ; copy to X
00D644  2  C8                 INY                     ; increment index
00D645  2  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
00D647  2  A8                 TAY                     ; copy to Y
00D648  2  68                 PLA                     ; get string length back
00D649  2  28                 PLP                     ; restore status
00D64A  2  D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
00D64C  2               
00D64C  2  C4 82              CPY   Sstorh            ; compare bottom of string space high byte
00D64E  2  D0 0F              BNE   LAB_22E6          ; branch if <>
00D650  2               
00D650  2  E4 81              CPX   Sstorl            ; else compare bottom of string space low byte
00D652  2  D0 0B              BNE   LAB_22E6          ; branch if <>
00D654  2               
00D654  2  48                 PHA                     ; save string length
00D655  2  18                 CLC                     ; clear carry for add
00D656  2  65 81              ADC   Sstorl            ; add bottom of string space low byte
00D658  2  85 81              STA   Sstorl            ; save bottom of string space low byte
00D65A  2  90 02              BCC   LAB_22E5          ; skip increment if no overflow
00D65C  2               
00D65C  2  E6 82              INC   Sstorh            ; increment bottom of string space high byte
00D65E  2               LAB_22E5
00D65E  2  68                 PLA                     ; restore string length
00D65F  2               LAB_22E6
00D65F  2  86 71              STX   ut1_pl            ; save string pointer low byte
00D661  2  84 72              STY   ut1_ph            ; save string pointer high byte
00D663  2  60                 RTS
00D664  2               
00D664  2               ; clean descriptor stack, YA = pointer
00D664  2               ; checks if AY is on the descriptor stack, if so does a stack discard
00D664  2               
00D664  2               LAB_22EB
00D664  2  C4 67              CPY   last_sh           ; compare pointer high byte
00D666  2  D0 0C              BNE   LAB_22FB          ; exit if <>
00D668  2               
00D668  2  C5 66              CMP   last_sl           ; compare pointer low byte
00D66A  2  D0 08              BNE   LAB_22FB          ; exit if <>
00D66C  2               
00D66C  2  85 65              STA   next_s            ; save descriptor stack pointer
00D66E  2  E9 03              SBC   #$03              ; -3
00D670  2  85 66              STA   last_sl           ; save low byte -3
00D672  2  A0 00              LDY   #$00              ; clear high byte
00D674  2               LAB_22FB
00D674  2  60                 RTS
00D675  2               
00D675  2               ; perform CHR$()
00D675  2               
00D675  2               LAB_CHRS
00D675  2  20 92 D7           JSR   LAB_EVBY          ; evaluate byte expression, result in X
00D678  2  8A                 TXA                     ; copy to A
00D679  2  48                 PHA                     ; save character
00D67A  2  A9 01              LDA   #$01              ; string is single byte
00D67C  2  20 25 D4           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
00D67F  2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00D67F  2  68                 PLA                     ; get character back
00D680  2  A0 00              LDY   #$00              ; clear index
00D682  2  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
00D684  2  4C 72 D4           JMP   LAB_RTST          ; check for space on descriptor stack then put string
00D687  2                                             ; address and length on descriptor stack and update stack
00D687  2                                             ; pointers
00D687  2               
00D687  2               ; perform LEFT$()
00D687  2               
00D687  2               LAB_LEFT
00D687  2  48                 PHA                     ; push byte parameter
00D688  2  20 E8 D6           JSR   LAB_236F          ; pull string data and byte parameter from stack
00D68B  2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00D68B  2  D1 9E              CMP   (des_2l),Y        ; compare byte parameter with string length
00D68D  2  98                 TYA                     ; clear A
00D68E  2  F0 09              BEQ   LAB_2316          ; go do string copy (branch always)
00D690  2               
00D690  2               ; perform RIGHT$()
00D690  2               
00D690  2               LAB_RIGHT
00D690  2  48                 PHA                     ; push byte parameter
00D691  2  20 E8 D6           JSR   LAB_236F          ; pull string data and byte parameter from stack
00D694  2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00D694  2  18                 CLC                     ; clear carry for add-1
00D695  2  F1 9E              SBC   (des_2l),Y        ; subtract string length
00D697  2  49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
00D699  2               
00D699  2               LAB_2316
00D699  2  90 04              BCC   LAB_231C          ; branch if string length > byte parameter
00D69B  2               
00D69B  2  B1 9E              LDA   (des_2l),Y        ; else make parameter = length
00D69D  2  AA                 TAX                     ; copy to byte parameter copy
00D69E  2  98                 TYA                     ; clear string start offset
00D69F  2               LAB_231C
00D69F  2  48                 PHA                     ; save string start offset
00D6A0  2               LAB_231D
00D6A0  2  8A                 TXA                     ; copy byte parameter (or string length if <)
00D6A1  2               LAB_231E
00D6A1  2  48                 PHA                     ; save string length
00D6A2  2  20 25 D4           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
00D6A5  2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00D6A5  2  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
00D6A7  2  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
00D6A9  2  20 33 D6           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00D6AC  2                                             ; returns with A = length, X=ut1_pl=pointer low byte,
00D6AC  2                                             ; Y=ut1_ph=pointer high byte
00D6AC  2  68                 PLA                     ; get string length back
00D6AD  2  A8                 TAY                     ; copy length to Y
00D6AE  2  68                 PLA                     ; get string start offset back
00D6AF  2  18                 CLC                     ; clear carry for add
00D6B0  2  65 71              ADC   ut1_pl            ; add start offset to string start pointer low byte
00D6B2  2  85 71              STA   ut1_pl            ; save string start pointer low byte
00D6B4  2  90 02              BCC   LAB_2335          ; branch if no overflow
00D6B6  2               
00D6B6  2  E6 72              INC   ut1_ph            ; else increment string start pointer high byte
00D6B8  2               LAB_2335
00D6B8  2  98                 TYA                     ; copy length to A
00D6B9  2  20 14 D6           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
00D6BC  2  4C 72 D4           JMP   LAB_RTST          ; check for space on descriptor stack then put string
00D6BF  2                                             ; address and length on descriptor stack and update stack
00D6BF  2                                             ; pointers
00D6BF  2               
00D6BF  2               ; perform MID$()
00D6BF  2               
00D6BF  2               LAB_MIDS
00D6BF  2  48                 PHA                     ; push byte parameter
00D6C0  2  A9 FF              LDA   #$FF              ; set default length = 255
00D6C2  2  85 AF              STA   mids_l            ; save default length
00D6C4  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00D6C7  2  C9 29              CMP   #')'              ; compare with ")"
00D6C9  2  F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
00D6CB  2               
00D6CB  2  20 4D CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
00D6CE  2  20 8F D7           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
00D6D1  2               LAB_2358
00D6D1  2  20 E8 D6           JSR   LAB_236F          ; pull string data and byte parameter from stack
00D6D4  2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00D6D4  2  CA                 DEX                     ; decrement start index
00D6D5  2  8A                 TXA                     ; copy to A
00D6D6  2  48                 PHA                     ; save string start offset
00D6D7  2  18                 CLC                     ; clear carry for sub-1
00D6D8  2  A2 00              LDX   #$00              ; clear output string length
00D6DA  2  F1 9E              SBC   (des_2l),Y        ; subtract string length
00D6DC  2  B0 C2              BCS   LAB_231D          ; if start>string length go do null string
00D6DE  2               
00D6DE  2  49 FF              EOR   #$FF              ; complement -length
00D6E0  2  C5 AF              CMP   mids_l            ; compare byte parameter
00D6E2  2  90 BD              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
00D6E4  2               
00D6E4  2  A5 AF              LDA   mids_l            ; get length byte
00D6E6  2  B0 B9              BCS   LAB_231E          ; go do string copy (branch always)
00D6E8  2               
00D6E8  2               ; pull string data and byte parameter from stack
00D6E8  2               ; return pointer in des_2l/h, byte in A (and X), Y=0
00D6E8  2               
00D6E8  2               LAB_236F
00D6E8  2  20 3E CD           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00D6EB  2  68                 PLA                     ; pull return address low byte (return address)
00D6EC  2  85 A2              STA   Fnxjpl            ; save functions jump vector low byte
00D6EE  2  68                 PLA                     ; pull return address high byte (return address)
00D6EF  2  85 A3              STA   Fnxjph            ; save functions jump vector high byte
00D6F1  2  68                 PLA                     ; pull byte parameter
00D6F2  2  AA                 TAX                     ; copy byte parameter to X
00D6F3  2  68                 PLA                     ; pull string pointer low byte
00D6F4  2  85 9E              STA   des_2l            ; save it
00D6F6  2  68                 PLA                     ; pull string pointer high byte
00D6F7  2  85 9F              STA   des_2h            ; save it
00D6F9  2  A0 00              LDY   #$00              ; clear index
00D6FB  2  8A                 TXA                     ; copy byte parameter
00D6FC  2  F0 79              BEQ   LAB_23A8          ; if null do function call error then warm start
00D6FE  2               
00D6FE  2  E6 A2              INC   Fnxjpl            ; increment function jump vector low byte
00D700  2                                             ; (JSR pushes return addr-1. this is all very nice
00D700  2                                             ; but will go tits up if either call is on a page
00D700  2                                             ; boundary!)
00D700  2  6C A2 00           JMP   (Fnxjpl)          ; in effect, RTS
00D703  2               
00D703  2               ; perform LCASE$()
00D703  2               
00D703  2               LAB_LCASE
00D703  2  20 2C D6           JSR   LAB_EVST          ; evaluate string
00D706  2  85 AC              STA   str_ln            ; set string length
00D708  2  A8                 TAY                     ; copy length to Y
00D709  2  F0 38              BEQ   NoString          ; branch if null string
00D70B  2               
00D70B  2  20 25 D4           JSR   LAB_MSSP          ; make string space A bytes long A=length,
00D70E  2                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D70E  2  86 AD              STX   str_pl            ; save string pointer low byte
00D710  2  84 AE              STY   str_ph            ; save string pointer high byte
00D712  2  A8                 TAY                     ; get string length back
00D713  2               
00D713  2               LC_loop
00D713  2  88                 DEY                     ; decrement index
00D714  2  B1 71              LDA   (ut1_pl),Y        ; get byte from string
00D716  2  20 0D D1           JSR   LAB_1D82          ; is character "A" to "Z"
00D719  2  90 02              BCC   NoUcase           ; branch if not upper case alpha
00D71B  2               
00D71B  2  09 20              ORA   #$20              ; convert upper to lower case
00D71D  2               NoUcase
00D71D  2  91 83              STA   (Sutill),Y        ; save byte back to string
00D71F  2  98                 TYA                     ; test index
00D720  2  D0 F1              BNE   LC_loop           ; loop if not all done
00D722  2               
00D722  2  F0 1F              BEQ   NoString          ; tidy up and exit, branch always
00D724  2               
00D724  2               ; perform UCASE$()
00D724  2               
00D724  2               LAB_UCASE
00D724  2  20 2C D6           JSR   LAB_EVST          ; evaluate string
00D727  2  85 AC              STA   str_ln            ; set string length
00D729  2  A8                 TAY                     ; copy length to Y
00D72A  2  F0 17              BEQ   NoString          ; branch if null string
00D72C  2               
00D72C  2  20 25 D4           JSR   LAB_MSSP          ; make string space A bytes long A=length,
00D72F  2                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D72F  2  86 AD              STX   str_pl            ; save string pointer low byte
00D731  2  84 AE              STY   str_ph            ; save string pointer high byte
00D733  2  A8                 TAY                     ; get string length back
00D734  2               
00D734  2               UC_loop
00D734  2  88                 DEY                     ; decrement index
00D735  2  B1 71              LDA   (ut1_pl),Y        ; get byte from string
00D737  2  20 09 D1           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
00D73A  2  90 02              BCC   NoLcase           ; branch if not alpha
00D73C  2               
00D73C  2  29 DF              AND   #$DF              ; convert lower to upper case
00D73E  2               NoLcase
00D73E  2  91 83              STA   (Sutill),Y        ; save byte back to string
00D740  2  98                 TYA                     ; test index
00D741  2  D0 F1              BNE   UC_loop           ; loop if not all done
00D743  2               
00D743  2               NoString
00D743  2  4C 72 D4           JMP   LAB_RTST          ; check for space on descriptor stack then put string
00D746  2                                             ; address and length on descriptor stack and update stack
00D746  2                                             ; pointers
00D746  2               
00D746  2               ; perform SADD()
00D746  2               
00D746  2               LAB_SADD
00D746  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00D749  2  20 95 D0           JSR   LAB_GVAR          ; get var address
00D74C  2               
00D74C  2  20 3E CD           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
00D74F  2  20 1A CC           JSR   LAB_CTST          ; check if source is string, else do type mismatch
00D752  2               
00D752  2  A0 02              LDY   #$02              ; index to string pointer high byte
00D754  2  B1 95              LDA   (Cvaral),Y        ; get string pointer high byte
00D756  2  AA                 TAX                     ; copy string pointer high byte to X
00D757  2  88                 DEY                     ; index to string pointer low byte
00D758  2  B1 95              LDA   (Cvaral),Y        ; get string pointer low byte
00D75A  2  A8                 TAY                     ; copy string pointer low byte to Y
00D75B  2  8A                 TXA                     ; copy string pointer high byte to A
00D75C  2  4C 44 D3           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00D75F  2               
00D75F  2               ; perform LEN()
00D75F  2               
00D75F  2               LAB_LENS
00D75F  2  20 65 D7           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
00D762  2  4C 51 D3           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00D765  2               
00D765  2               ; evaluate string, get length in Y
00D765  2               
00D765  2               LAB_ESGL
00D765  2  20 2C D6           JSR   LAB_EVST          ; evaluate string
00D768  2  A8                 TAY                     ; copy length to Y
00D769  2  60                 RTS
00D76A  2               
00D76A  2               ; perform ASC()
00D76A  2               
00D76A  2               LAB_ASC
00D76A  2  20 65 D7           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
00D76D  2  F0 08              BEQ   LAB_23A8          ; if null do function call error then warm start
00D76F  2               
00D76F  2  A0 00              LDY   #$00              ; set index to first character
00D771  2  B1 71              LDA   (ut1_pl),Y        ; get byte
00D773  2  A8                 TAY                     ; copy to Y
00D774  2  4C 51 D3           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00D777  2               
00D777  2               ; do function call error then warm start
00D777  2               
00D777  2               LAB_23A8
00D777  2  4C 14 D2           JMP   LAB_FCER          ; do function call error then warm start
00D77A  2               
00D77A  2               ; scan and get byte parameter
00D77A  2               
00D77A  2               LAB_SGBY
00D77A  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00D77D  2               
00D77D  2               ; get word (16-bit unsigned) parameter
00D77D  2               ; Result in FAC1_3 (low) and FAC1_2 (high)
00D77D  2               
00D77D  2               LAB_GTWRD
00D77D  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric
00D780  2  20 8D D1           JSR   LAB_EVPI          ; convert to unsigned integer (0-65535)
00D783  2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
00D786  2               
00D786  2               ; get word (16-bit signed) parameter
00D786  2               ; Result in FAC1_3 (low) and FAC1_2 (high)
00D786  2               
00D786  2               LAB_GTSW
00D786  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric
00D789  2  20 91 D1           JSR   LAB_EVIR          ; convert to signed integer (-32768..32767)
00D78C  2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
00D78F  2               
00D78F  2               ; get byte parameter
00D78F  2               
00D78F  2               LAB_GTBY
00D78F  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D792  2                                             ; else do type mismatch
00D792  2               
00D792  2               ; evaluate byte expression, result in X
00D792  2               
00D792  2               LAB_EVBY
00D792  2  20 8D D1           JSR   LAB_EVPI          ; evaluate integer expression (no check)
00D795  2               
00D795  2  A4 AE              LDY   FAC1_2            ; get FAC1 mantissa2
00D797  2  D0 DE              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
00D799  2               
00D799  2  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
00D79B  2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
00D79E  2               
00D79E  2               ; perform VAL()
00D79E  2               
00D79E  2               LAB_VAL
00D79E  2  20 65 D7           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
00D7A1  2  D0 03              BNE   LAB_23C5          ; branch if not null string
00D7A3  2               
00D7A3  2                                             ; string was null so set result = $00
00D7A3  2  4C 5A D9           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
00D7A6  2               
00D7A6  2               LAB_23C5
00D7A6  2               ; *** begin patch  2.22p5.7  VAL() may cause string variables to be trashed
00D7A6  2               ; *** replace
00D7A6  2               ;      LDX   Bpntrl            ; get BASIC execute pointer low byte
00D7A6  2               ;      LDY   Bpntrh            ; get BASIC execute pointer high byte
00D7A6  2               ;      STX   Btmpl             ; save BASIC execute pointer low byte
00D7A6  2               ;      STY   Btmph             ; save BASIC execute pointer high byte
00D7A6  2               ;      LDX   ut1_pl            ; get string pointer low byte
00D7A6  2               ;      STX   Bpntrl            ; save as BASIC execute pointer low byte
00D7A6  2               ;      CLC                     ; clear carry
00D7A6  2               ;      ADC   ut1_pl            ; add string length
00D7A6  2               ;      STA   ut2_pl            ; save string end low byte
00D7A6  2               ;      LDA   ut1_ph            ; get string pointer high byte
00D7A6  2               ;      STA   Bpntrh            ; save as BASIC execute pointer high byte
00D7A6  2               ;      ADC   #$00              ; add carry to high byte
00D7A6  2               ;      STA   ut2_ph            ; save string end high byte
00D7A6  2               ;      LDY   #$00              ; set index to $00
00D7A6  2               ;      LDA   (ut2_pl),Y        ; get string end +1 byte
00D7A6  2               ;      PHA                     ; push it
00D7A6  2               ;      TYA                     ; clear A
00D7A6  2               ;      STA   (ut2_pl),Y        ; terminate string with $00
00D7A6  2               ;      JSR   LAB_GBYT          ; scan memory
00D7A6  2               ;      JSR   LAB_2887          ; get FAC1 from string
00D7A6  2               ;      PLA                     ; restore string end +1 byte
00D7A6  2               ;      LDY   #$00              ; set index to zero
00D7A6  2               ;      STA   (ut2_pl),Y        ; put string end byte back
00D7A6  2               ; *** with
00D7A6  2  48                 PHA                     ; save length
00D7A7  2  C8                 INY                     ; string length +1
00D7A8  2  98                 TYA
00D7A9  2  20 25 D4           JSR   LAB_MSSP          ; allocate temp string +1 bytes long
00D7AC  2  68                 PLA                     ; get length back
00D7AD  2  20 14 D6           JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
00D7B0  2  A9 00              LDA   #0                ; add delimiter to end of string
00D7B2  2  A8                 TAY
00D7B3  2  91 83              STA   (Sutill),Y
00D7B5  2  A6 C3              LDX   Bpntrl            ; save BASIC execute pointer low byte
00D7B7  2  A4 C4              LDY   Bpntrh
00D7B9  2  86 BA              STX   Btmpl
00D7BB  2  84 BB              STY   Btmph
00D7BD  2  A6 AD              LDX   str_pl            ; point to temporary string
00D7BF  2  A4 AE              LDY   str_ph
00D7C1  2  86 C3              STX   Bpntrl
00D7C3  2  84 C4              STY   Bpntrh
00D7C5  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00D7C8  2  20 B0 DC           JSR   LAB_2887          ; get FAC1 from string
00D7CB  2               ; *** end patch    2.22p5.7  VAL() may cause string variables to be trashed
00D7CB  2               
00D7CB  2               ; restore BASIC execute pointer from temp (Btmpl/Btmph)
00D7CB  2               
00D7CB  2               LAB_23F3
00D7CB  2  A6 BA              LDX   Btmpl             ; get BASIC execute pointer low byte back
00D7CD  2  A4 BB              LDY   Btmph             ; get BASIC execute pointer high byte back
00D7CF  2  86 C3              STX   Bpntrl            ; save BASIC execute pointer low byte
00D7D1  2  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
00D7D3  2  60                 RTS
00D7D4  2               
00D7D4  2               ; get two parameters for POKE or WAIT
00D7D4  2               
00D7D4  2               LAB_GADB
00D7D4  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D7D7  2                                             ; else do type mismatch
00D7D7  2  20 ED D7           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
00D7DA  2               
00D7DA  2               ; scan for "," and get byte, else do Syntax error then warm start
00D7DA  2               
00D7DA  2               LAB_SCGB
00D7DA  2  20 4D CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
00D7DD  2  A5 12              LDA   Itemph            ; save temporary integer high byte
00D7DF  2  48                 PHA                     ; on stack
00D7E0  2  A5 11              LDA   Itempl            ; save temporary integer low byte
00D7E2  2  48                 PHA                     ; on stack
00D7E3  2  20 8F D7           JSR   LAB_GTBY          ; get byte parameter
00D7E6  2  68                 PLA                     ; pull low byte
00D7E7  2  85 11              STA   Itempl            ; restore temporary integer low byte
00D7E9  2  68                 PLA                     ; pull high byte
00D7EA  2  85 12              STA   Itemph            ; restore temporary integer high byte
00D7EC  2  60                 RTS
00D7ED  2               
00D7ED  2               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
00D7ED  2               ; -ve and converts it into a right truncated integer in Itempl and Itemph
00D7ED  2               
00D7ED  2               ; save unsigned 16 bit integer part of FAC1 in temporary integer
00D7ED  2               
00D7ED  2               LAB_F2FX
00D7ED  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D7EF  2  C9 98              CMP   #$98              ; compare with exponent = 2^24
00D7F1  2  B0 84              BCS   LAB_23A8          ; if >= do function call error then warm start
00D7F3  2               
00D7F3  2               LAB_F2FU
00D7F3  2  20 5A DC           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
00D7F6  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00D7F8  2  A4 AF              LDY   FAC1_3            ; get FAC1 mantissa3
00D7FA  2  84 11              STY   Itempl            ; save temporary integer low byte
00D7FC  2  85 12              STA   Itemph            ; save temporary integer high byte
00D7FE  2  60                 RTS
00D7FF  2               
00D7FF  2               ; perform PEEK()
00D7FF  2               
00D7FF  2               LAB_PEEK
00D7FF  2  20 ED D7           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
00D802  2  A2 00              LDX   #$00              ; clear index
00D804  2  A1 11              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
00D806  2  A8                 TAY                     ; copy byte to Y
00D807  2  4C 51 D3           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00D80A  2               
00D80A  2               ; perform POKE
00D80A  2               
00D80A  2               LAB_POKE
00D80A  2  20 D4 D7           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00D80D  2  8A                 TXA                     ; copy byte argument to A
00D80E  2  A2 00              LDX   #$00              ; clear index
00D810  2  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
00D812  2  60                 RTS
00D813  2               
00D813  2               ; perform DEEK()
00D813  2               
00D813  2               LAB_DEEK
00D813  2  20 ED D7           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
00D816  2  A2 00              LDX   #$00              ; clear index
00D818  2  A1 11              LDA   (Itempl,X)        ; PEEK low byte
00D81A  2  A8                 TAY                     ; copy to Y
00D81B  2  E6 11              INC   Itempl            ; increment pointer low byte
00D81D  2  D0 02              BNE   Deekh             ; skip high increment if no rollover
00D81F  2               
00D81F  2  E6 12              INC   Itemph            ; increment pointer high byte
00D821  2               Deekh
00D821  2  A1 11              LDA   (Itempl,X)        ; PEEK high byte
00D823  2  4C 44 D3           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00D826  2               
00D826  2               ; perform DOKE
00D826  2               
00D826  2               LAB_DOKE
00D826  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D829  2                                             ; else do type mismatch
00D829  2  20 ED D7           JSR   LAB_F2FX          ; convert floating-to-fixed
00D82C  2               
00D82C  2  84 97              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
00D82E  2  85 98              STA   Frnxth            ; save pointer high byte
00D830  2               
00D830  2  20 4D CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
00D833  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D836  2                                             ; else do type mismatch
00D836  2  20 ED D7           JSR   LAB_F2FX          ; convert floating-to-fixed
00D839  2               
00D839  2  98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
00D83A  2  A2 00              LDX   #$00              ; clear index
00D83C  2  81 97              STA   (Frnxtl,X)        ; POKE low byte
00D83E  2  E6 97              INC   Frnxtl            ; increment pointer low byte
00D840  2  D0 02              BNE   Dokeh             ; skip high increment if no rollover
00D842  2               
00D842  2  E6 98              INC   Frnxth            ; increment pointer high byte
00D844  2               Dokeh
00D844  2  A5 12              LDA   Itemph            ; get value high byte
00D846  2  81 97              STA   (Frnxtl,X)        ; POKE high byte
00D848  2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
00D84B  2               
00D84B  2               ; perform SWAP
00D84B  2               
00D84B  2               LAB_SWAP
00D84B  2  20 95 D0           JSR   LAB_GVAR          ; get var1 address
00D84E  2  85 97              STA   Lvarpl            ; save var1 address low byte
00D850  2  84 98              STY   Lvarph            ; save var1 address high byte
00D852  2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
00D854  2  48                 PHA                     ; save data type flag
00D855  2               
00D855  2  20 4D CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
00D858  2  20 95 D0           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
00D85B  2  68                 PLA                     ; pull var1 data type flag
00D85C  2  45 5F              EOR   Dtypef            ; compare with var2 data type
00D85E  2  10 10              BPL   SwapErr           ; exit if not both the same type
00D860  2               
00D860  2  A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
00D862  2               SwapLp
00D862  2  B1 97              LDA   (Lvarpl),Y        ; get byte from var1
00D864  2  AA                 TAX                     ; save var1 byte
00D865  2  B1 95              LDA   (Cvaral),Y        ; get byte from var2
00D867  2  91 97              STA   (Lvarpl),Y        ; save byte to var1
00D869  2  8A                 TXA                     ; restore var1 byte
00D86A  2  91 95              STA   (Cvaral),Y        ; save byte to var2
00D86C  2  88                 DEY                     ; decrement index
00D86D  2  10 F3              BPL   SwapLp            ; loop until done
00D86F  2               
00D86F  2  60                 RTS
00D870  2               
00D870  2               SwapErr
00D870  2  4C 24 CC           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
00D873  2               
00D873  2               ; perform CALL
00D873  2               
00D873  2               LAB_CALL
00D873  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D876  2                                             ; else do type mismatch
00D876  2  20 ED D7           JSR   LAB_F2FX          ; convert floating-to-fixed
00D879  2  A9 D8              LDA   #>CallExit        ; set return address high byte
00D87B  2  48                 PHA                     ; put on stack
00D87C  2  A9 81              LDA   #<CallExit-1      ; set return address low byte
00D87E  2  48                 PHA                     ; put on stack
00D87F  2  6C 11 00           JMP   (Itempl)          ; do indirect jump to user routine
00D882  2               
00D882  2               ; if the called routine exits correctly then it will return to here. this will then get
00D882  2               ; the next byte for the interpreter and return
00D882  2               
00D882  2               CallExit
00D882  2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
00D885  2               
00D885  2               ; cursor helpers — placed after all #<label-1 forward refs to avoid
00D885  2               ; page-boundary issues in the ca65 assembler.
00D885  2               
00D885  2               LAB_CURS_ON
00D885  2  A9 01              LDA   #$01
00D887  2  8D 0A A0           STA   $A00A             ; VGC cursor enable register
00D88A  2  60                 RTS
00D88B  2               
00D88B  2               LAB_CURS_OFF_CR
00D88B  2  A9 00              LDA   #$00
00D88D  2  8D 0A A0           STA   $A00A             ; VGC cursor enable register
00D890  2  4C E0 C9           JMP   LAB_1866          ; do CR/LF exit to BASIC
00D893  2               
00D893  2               ; perform WAIT
00D893  2               
00D893  2               LAB_WAIT
00D893  2  20 D4 D7           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00D896  2  86 97              STX   Frnxtl            ; save byte
00D898  2  A2 00              LDX   #$00              ; clear mask
00D89A  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00D89D  2  F0 03              BEQ   LAB_2441          ; skip if no third argument
00D89F  2               
00D89F  2  20 DA D7           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
00D8A2  2               LAB_2441
00D8A2  2  86 98              STX   Frnxth            ; save EOR argument
00D8A4  2               LAB_2445
00D8A4  2  B1 11              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
00D8A6  2  45 98              EOR   Frnxth            ; EOR with second argument (mask)
00D8A8  2  25 97              AND   Frnxtl            ; AND with first argument (byte)
00D8AA  2  F0 F8              BEQ   LAB_2445          ; loop if result is zero
00D8AC  2               
00D8AC  2               LAB_244D
00D8AC  2  60                 RTS
00D8AD  2               
00D8AD  2               ; perform subtraction, FAC1 from (AY)
00D8AD  2               
00D8AD  2               LAB_2455
00D8AD  2  20 95 DA           JSR   LAB_264D          ; unpack memory (AY) into FAC2
00D8B0  2               
00D8B0  2               ; perform subtraction, FAC1 from FAC2
00D8B0  2               
00D8B0  2               LAB_SUBTRACT
00D8B0  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00D8B2  2  49 FF              EOR   #$FF              ; complement it
00D8B4  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00D8B6  2  45 B7              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
00D8B8  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00D8BA  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D8BC  2  4C CB D8           JMP   LAB_ADD           ; go add FAC2 to FAC1
00D8BF  2               
00D8BF  2               ; perform addition
00D8BF  2               
00D8BF  2               LAB_2467
00D8BF  2  20 E4 D9           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
00D8C2  2  90 4D              BCC   LAB_24A8          ;.go subtract mantissas
00D8C4  2               
00D8C4  2               ; add 0.5 to FAC1
00D8C4  2               
00D8C4  2               LAB_244E
00D8C4  2  A9 5E              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
00D8C6  2  A0 F7              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
00D8C8  2               
00D8C8  2               ; add (AY) to FAC1
00D8C8  2               
00D8C8  2               LAB_246C
00D8C8  2  20 95 DA           JSR   LAB_264D          ; unpack memory (AY) into FAC2
00D8CB  2               
00D8CB  2               ; add FAC2 to FAC1
00D8CB  2               
00D8CB  2               LAB_ADD
00D8CB  2  D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
00D8CD  2               
00D8CD  2               ; copy FAC2 to FAC1
00D8CD  2               
00D8CD  2               LAB_279B
00D8CD  2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
00D8CF  2               
00D8CF  2               ; save FAC1 sign and copy ABS(FAC2) to FAC1
00D8CF  2               
00D8CF  2               LAB_279D
00D8CF  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00D8D1  2  A2 04              LDX   #$04              ; 4 bytes to copy
00D8D3  2               LAB_27A1
00D8D3  2  B5 B2              LDA   FAC1_o,X          ; get byte from FAC2,X
00D8D5  2  95 AB              STA   FAC1_e-1,X        ; save byte at FAC1,X
00D8D7  2  CA                 DEX                     ; decrement count
00D8D8  2  D0 F9              BNE   LAB_27A1          ; loop if not all done
00D8DA  2               
00D8DA  2  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
00D8DC  2  60                 RTS
00D8DD  2               
00D8DD  2                                             ; FAC1 is non zero
00D8DD  2               LAB_2474
00D8DD  2  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
00D8DF  2  86 A3              STX   FAC2_r            ; save as FAC2 rounding byte
00D8E1  2  A2 B3              LDX   #FAC2_e           ; set index to FAC2 exponent addr
00D8E3  2  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
00D8E5  2               LAB_247C
00D8E5  2  A8                 TAY                     ; copy exponent
00D8E6  2  F0 C4              BEQ   LAB_244D          ; exit if zero
00D8E8  2               
00D8E8  2  38                 SEC                     ; set carry for subtract
00D8E9  2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
00D8EB  2  F0 24              BEQ   LAB_24A8          ; branch if = (go add mantissa)
00D8ED  2               
00D8ED  2  90 12              BCC   LAB_2498          ; branch if <
00D8EF  2               
00D8EF  2                                             ; FAC2>FAC1
00D8EF  2  84 AC              STY   FAC1_e            ; save FAC1 exponent
00D8F1  2  A4 B7              LDY   FAC2_s            ; get FAC2 sign (b7)
00D8F3  2  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
00D8F5  2  49 FF              EOR   #$FF              ; complement A
00D8F7  2  69 00              ADC   #$00              ; +1 (twos complement, carry is set)
00D8F9  2  A0 00              LDY   #$00              ; clear Y
00D8FB  2  84 A3              STY   FAC2_r            ; clear FAC2 rounding byte
00D8FD  2  A2 AC              LDX   #FAC1_e           ; set index to FAC1 exponent addr
00D8FF  2  D0 04              BNE   LAB_249C          ; branch always
00D901  2               
00D901  2               LAB_2498
00D901  2  A0 00              LDY   #$00              ; clear Y
00D903  2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
00D905  2               LAB_249C
00D905  2  C9 F9              CMP   #$F9              ; compare exponent diff with $F9
00D907  2  30 B6              BMI   LAB_2467          ; branch if range $79-$F8
00D909  2               
00D909  2  A8                 TAY                     ; copy exponent difference to Y
00D90A  2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00D90C  2  56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
00D90E  2  20 FB D9           JSR   LAB_2592          ; shift FACX Y times right
00D911  2               
00D911  2                                             ; exponents are equal now do mantissa subtract
00D911  2               LAB_24A8
00D911  2  24 B8              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
00D913  2  10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
00D915  2               
00D915  2  A0 AC              LDY   #FAC1_e           ; set index to FAC1 exponent addr
00D917  2  E0 B3              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
00D919  2  F0 02              BEQ   LAB_24B4          ; branch if =
00D91B  2               
00D91B  2  A0 B3              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
00D91D  2               
00D91D  2                                             ; subtract smaller from bigger (take sign of bigger)
00D91D  2               LAB_24B4
00D91D  2  38                 SEC                     ; set carry for subtract
00D91E  2  49 FF              EOR   #$FF              ; ones complement A
00D920  2  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
00D922  2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
00D924  2  B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
00D927  2  F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
00D929  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00D92B  2  B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
00D92E  2  F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
00D930  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00D932  2  B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
00D935  2  F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
00D937  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D939  2               
00D939  2               ; do ABS and normalise FAC1
00D939  2               
00D939  2               LAB_24D0
00D939  2  B0 03              BCS   LAB_24D5          ; branch if number is +ve
00D93B  2               
00D93B  2  20 A0 D9           JSR   LAB_2537          ; negate FAC1
00D93E  2               
00D93E  2               ; normalise FAC1
00D93E  2               
00D93E  2               LAB_24D5
00D93E  2  A0 00              LDY   #$00              ; clear Y
00D940  2  98                 TYA                     ; clear A
00D941  2  18                 CLC                     ; clear carry for add
00D942  2               LAB_24D9
00D942  2  A6 AD              LDX   FAC1_1            ; get FAC1 mantissa1
00D944  2  D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
00D946  2               
00D946  2  A6 AE              LDX   FAC1_2            ; get FAC1 mantissa2
00D948  2  86 AD              STX   FAC1_1            ; save FAC1 mantissa1
00D94A  2  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
00D94C  2  86 AE              STX   FAC1_2            ; save FAC1 mantissa2
00D94E  2  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
00D950  2  86 AF              STX   FAC1_3            ; save FAC1 mantissa3
00D952  2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
00D954  2  69 08              ADC   #$08              ; add x to exponent offset
00D956  2  C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
00D958  2  D0 E8              BNE   LAB_24D9          ; loop if not max
00D95A  2               
00D95A  2               ; clear FAC1 exponent and sign
00D95A  2               
00D95A  2               LAB_24F1
00D95A  2  A9 00              LDA   #$00              ; clear A
00D95C  2               LAB_24F3
00D95C  2  85 AC              STA   FAC1_e            ; set FAC1 exponent
00D95E  2               
00D95E  2               ; save FAC1 sign
00D95E  2               
00D95E  2               LAB_24F5
00D95E  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00D960  2  60                 RTS
00D961  2               
00D961  2               ; add FAC2 mantissa to FAC1 mantissa
00D961  2               
00D961  2               LAB_24F8
00D961  2  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
00D963  2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
00D965  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00D967  2  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
00D969  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00D96B  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00D96D  2  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
00D96F  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00D971  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00D973  2  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
00D975  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D977  2  B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
00D979  2               
00D979  2  60                 RTS                     ; else just exit
00D97A  2               
00D97A  2               LAB_2511
00D97A  2  69 01              ADC   #$01              ; add 1 to exponent offset
00D97C  2  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
00D97E  2  26 AF              ROL   FAC1_3            ; shift FAC1 mantissa3
00D980  2  26 AE              ROL   FAC1_2            ; shift FAC1 mantissa2
00D982  2  26 AD              ROL   FAC1_1            ; shift FAC1 mantissa1
00D984  2               
00D984  2               ; normalise FAC1
00D984  2               
00D984  2               LAB_251B
00D984  2  10 F4              BPL   LAB_2511          ; loop if not normalised
00D986  2               
00D986  2  38                 SEC                     ; set carry for subtract
00D987  2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
00D989  2  B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
00D98B  2               
00D98B  2  49 FF              EOR   #$FF              ; complement exponent
00D98D  2  69 01              ADC   #$01              ; +1 (twos complement)
00D98F  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00D991  2               
00D991  2               ; test and normalise FAC1 for C=0/1
00D991  2               
00D991  2               LAB_2528
00D991  2  90 0C              BCC   LAB_2536          ; exit if no overflow
00D993  2               
00D993  2               ; normalise FAC1 for C=1
00D993  2               
00D993  2               LAB_252A
00D993  2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
00D995  2  F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
00D997  2               
00D997  2  66 AD              ROR   FAC1_1            ; shift FAC1 mantissa1
00D999  2  66 AE              ROR   FAC1_2            ; shift FAC1 mantissa2
00D99B  2  66 AF              ROR   FAC1_3            ; shift FAC1 mantissa3
00D99D  2  66 B9              ROR   FAC1_r            ; shift FAC1 rounding byte
00D99F  2               LAB_2536
00D99F  2  60                 RTS
00D9A0  2               
00D9A0  2               ; negate FAC1
00D9A0  2               
00D9A0  2               LAB_2537
00D9A0  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00D9A2  2  49 FF              EOR   #$FF              ; complement it
00D9A4  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00D9A6  2               
00D9A6  2               ; twos complement FAC1 mantissa
00D9A6  2               
00D9A6  2               LAB_253D
00D9A6  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00D9A8  2  49 FF              EOR   #$FF              ; complement it
00D9AA  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D9AC  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00D9AE  2  49 FF              EOR   #$FF              ; complement it
00D9B0  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00D9B2  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00D9B4  2  49 FF              EOR   #$FF              ; complement it
00D9B6  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00D9B8  2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00D9BA  2  49 FF              EOR   #$FF              ; complement it
00D9BC  2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
00D9BE  2  E6 B9              INC   FAC1_r            ; increment FAC1 rounding byte
00D9C0  2  D0 0A              BNE   LAB_2563          ; exit if no overflow
00D9C2  2               
00D9C2  2               ; increment FAC1 mantissa
00D9C2  2               
00D9C2  2               LAB_2559
00D9C2  2  E6 AF              INC   FAC1_3            ; increment FAC1 mantissa3
00D9C4  2  D0 06              BNE   LAB_2563          ; finished if no rollover
00D9C6  2               
00D9C6  2  E6 AE              INC   FAC1_2            ; increment FAC1 mantissa2
00D9C8  2  D0 02              BNE   LAB_2563          ; finished if no rollover
00D9CA  2               
00D9CA  2  E6 AD              INC   FAC1_1            ; increment FAC1 mantissa1
00D9CC  2               LAB_2563
00D9CC  2  60                 RTS
00D9CD  2               
00D9CD  2               ; do overflow error (overflow exit)
00D9CD  2               
00D9CD  2               LAB_2564
00D9CD  2  A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
00D9CF  2  4C 49 C1           JMP   LAB_XERR          ; do error #X, then warm start
00D9D2  2               
00D9D2  2               ; shift FCAtemp << A+8 times
00D9D2  2               
00D9D2  2               LAB_2569
00D9D2  2  A2 74              LDX   #FACt_1-1         ; set offset to FACtemp
00D9D4  2               LAB_256B
00D9D4  2  B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
00D9D6  2  84 B9              STY   FAC1_r            ; save as FAC1 rounding byte
00D9D8  2  B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
00D9DA  2  94 03              STY   PLUS_3,X          ; save FACX mantissa3
00D9DC  2  B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
00D9DE  2  94 02              STY   PLUS_2,X          ; save FACX mantissa2
00D9E0  2  A4 B2              LDY   FAC1_o            ; get FAC1 overflow byte
00D9E2  2  94 01              STY   PLUS_1,X          ; save FACX mantissa1
00D9E4  2               
00D9E4  2               ; shift FACX -A times right (> 8 shifts)
00D9E4  2               
00D9E4  2               LAB_257B
00D9E4  2  69 08              ADC   #$08              ; add 8 to shift count
00D9E6  2  30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
00D9E8  2               
00D9E8  2  F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
00D9EA  2               
00D9EA  2  E9 08              SBC   #$08              ; else subtract 8 again
00D9EC  2  A8                 TAY                     ; save count to Y
00D9ED  2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00D9EF  2  B0 12              BCS   LAB_259A          ;.
00D9F1  2               
00D9F1  2               LAB_2588
00D9F1  2  16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
00D9F3  2  90 02              BCC   LAB_258E          ; branch if +ve
00D9F5  2               
00D9F5  2  F6 01              INC   PLUS_1,X          ; this sets b7 eventually
00D9F7  2               LAB_258E
00D9F7  2  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
00D9F9  2  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
00D9FB  2               
00D9FB  2               ; shift FACX Y times right
00D9FB  2               
00D9FB  2               LAB_2592
00D9FB  2  76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
00D9FD  2  76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
00D9FF  2  6A                 ROR                     ; shift FACX rounding byte
00DA00  2  C8                 INY                     ; increment exponent diff
00DA01  2  D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
00DA03  2               
00DA03  2               LAB_259A
00DA03  2  18                 CLC                     ; just clear it
00DA04  2  60                 RTS
00DA05  2               
00DA05  2               ; perform LOG()
00DA05  2               
00DA05  2               LAB_LOG
00DA05  2  20 F3 DB           JSR   LAB_27CA          ; test sign and zero
00DA08  2  F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
00DA0A  2               
00DA0A  2  10 03              BPL   LAB_25C7          ; skip error if +ve
00DA0C  2               
00DA0C  2               LAB_25C4
00DA0C  2  4C 14 D2           JMP   LAB_FCER          ; do function call error then warm start (-ve)
00DA0F  2               
00DA0F  2               LAB_25C7
00DA0F  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DA11  2  E9 7F              SBC   #$7F              ; normalise it
00DA13  2  48                 PHA                     ; save it
00DA14  2  A9 80              LDA   #$80              ; set exponent to zero
00DA16  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00DA18  2  A9 DE              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
00DA1A  2  A0 F6              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
00DA1C  2  20 C8 D8           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
00DA1F  2  A9 E2              LDA   #<LAB_25B1        ; set root2 pointer low byte
00DA21  2  A0 F6              LDY   #>LAB_25B1        ; set root2 pointer high byte
00DA23  2  20 0B DB           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
00DA26  2  A9 55              LDA   #<LAB_259C        ; set 1 pointer low byte
00DA28  2  A0 F7              LDY   #>LAB_259C        ; set 1 pointer high byte
00DA2A  2  20 AD D8           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
00DA2D  2  A9 D1              LDA   #<LAB_25A0        ; set pointer low byte to counter
00DA2F  2  A0 F6              LDY   #>LAB_25A0        ; set pointer high byte to counter
00DA31  2  20 5B DF           JSR   LAB_2B6E          ; ^2 then series evaluation
00DA34  2  A9 E6              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
00DA36  2  A0 F6              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
00DA38  2  20 C8 D8           JSR   LAB_246C          ; add (AY) to FAC1
00DA3B  2  68                 PLA                     ; restore FAC1 exponent
00DA3C  2  20 4F DD           JSR   LAB_2912          ; evaluate new ASCII digit
00DA3F  2  A9 EA              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
00DA41  2  A0 F6              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
00DA43  2               
00DA43  2               ; do convert AY, FCA1*(AY)
00DA43  2               
00DA43  2               LAB_25FB
00DA43  2  20 95 DA           JSR   LAB_264D          ; unpack memory (AY) into FAC2
00DA46  2               LAB_MULTIPLY
00DA46  2  F0 4C              BEQ   LAB_264C          ; exit if zero
00DA48  2               
00DA48  2  20 BB DA           JSR   LAB_2673          ; test and adjust accumulators
00DA4B  2  A9 00              LDA   #$00              ; clear A
00DA4D  2  85 75              STA   FACt_1            ; clear temp mantissa1
00DA4F  2  85 76              STA   FACt_2            ; clear temp mantissa2
00DA51  2  85 77              STA   FACt_3            ; clear temp mantissa3
00DA53  2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00DA55  2  20 6A DA           JSR   LAB_2622          ; go do shift/add FAC2
00DA58  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00DA5A  2  20 6A DA           JSR   LAB_2622          ; go do shift/add FAC2
00DA5D  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00DA5F  2  20 6A DA           JSR   LAB_2622          ; go do shift/add FAC2
00DA62  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00DA64  2  20 70 DA           JSR   LAB_2627          ; go do shift/add FAC2
00DA67  2  4C 78 DB           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
00DA6A  2               
00DA6A  2               LAB_2622
00DA6A  2  D0 04              BNE   LAB_2627          ; branch if byte <> zero
00DA6C  2               ; *** begin patch  2.22p5.6  floating point multiply rounding bug
00DA6C  2               ; *** replace
00DA6C  2               ;      JMP   LAB_2569          ; shift FCAtemp << A+8 times
00DA6C  2               ;
00DA6C  2               ;                              ; else do shift and add
00DA6C  2               ;LAB_2627
00DA6C  2               ;      LSR                     ; shift byte
00DA6C  2               ;      ORA   #$80              ; set top bit (mark for 8 times)
00DA6C  2               ; *** with
00DA6C  2  38                 SEC
00DA6D  2  4C D2 D9           JMP   LAB_2569          ; shift FACtemp << A+8 times
00DA70  2               
00DA70  2                                             ; else do shift and add
00DA70  2               LAB_2627
00DA70  2  38                 SEC                     ; set top bit (mark for 8 times)
00DA71  2  6A                 ROR
00DA72  2               ; *** end patch    2.22p5.6  floating point multiply rounding bug
00DA72  2               LAB_262A
00DA72  2  A8                 TAY                     ; copy result
00DA73  2  90 13              BCC   LAB_2640          ; skip next if bit was zero
00DA75  2               
00DA75  2  18                 CLC                     ; clear carry for add
00DA76  2  A5 77              LDA   FACt_3            ; get temp mantissa3
00DA78  2  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
00DA7A  2  85 77              STA   FACt_3            ; save temp mantissa3
00DA7C  2  A5 76              LDA   FACt_2            ; get temp mantissa2
00DA7E  2  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
00DA80  2  85 76              STA   FACt_2            ; save temp mantissa2
00DA82  2  A5 75              LDA   FACt_1            ; get temp mantissa1
00DA84  2  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
00DA86  2  85 75              STA   FACt_1            ; save temp mantissa1
00DA88  2               LAB_2640
00DA88  2  66 75              ROR   FACt_1            ; shift temp mantissa1
00DA8A  2  66 76              ROR   FACt_2            ; shift temp mantissa2
00DA8C  2  66 77              ROR   FACt_3            ; shift temp mantissa3
00DA8E  2  66 B9              ROR   FAC1_r            ; shift temp rounding byte
00DA90  2  98                 TYA                     ; get byte back
00DA91  2  4A                 LSR                     ; shift byte
00DA92  2  D0 DE              BNE   LAB_262A          ; loop if all bits not done
00DA94  2               
00DA94  2               LAB_264C
00DA94  2  60                 RTS
00DA95  2               
00DA95  2               ; unpack memory (AY) into FAC2
00DA95  2               
00DA95  2               LAB_264D
00DA95  2  85 71              STA   ut1_pl            ; save pointer low byte
00DA97  2  84 72              STY   ut1_ph            ; save pointer high byte
00DA99  2  A0 03              LDY   #$03              ; 4 bytes to get (0-3)
00DA9B  2  B1 71              LDA   (ut1_pl),Y        ; get mantissa3
00DA9D  2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
00DA9F  2  88                 DEY                     ; decrement index
00DAA0  2  B1 71              LDA   (ut1_pl),Y        ; get mantissa2
00DAA2  2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
00DAA4  2  88                 DEY                     ; decrement index
00DAA5  2  B1 71              LDA   (ut1_pl),Y        ; get mantissa1+sign
00DAA7  2  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
00DAA9  2  45 B0              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
00DAAB  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00DAAD  2  A5 B7              LDA   FAC2_s            ; recover FAC2 sign (b7)
00DAAF  2  09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
00DAB1  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00DAB3  2  88                 DEY                     ; decrement index
00DAB4  2  B1 71              LDA   (ut1_pl),Y        ; get exponent byte
00DAB6  2  85 B3              STA   FAC2_e            ; save FAC2 exponent
00DAB8  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DABA  2  60                 RTS
00DABB  2               
00DABB  2               ; test and adjust accumulators
00DABB  2               
00DABB  2               LAB_2673
00DABB  2  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
00DABD  2               LAB_2675
00DABD  2  F0 1D              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
00DABF  2               
00DABF  2  18                 CLC                     ; clear carry for add
00DAC0  2  65 AC              ADC   FAC1_e            ; add FAC1 exponent
00DAC2  2  90 04              BCC   LAB_2680          ; branch if sum of exponents <$0100
00DAC4  2               
00DAC4  2  30 31              BMI   LAB_269B          ; do overflow error
00DAC6  2               
00DAC6  2  18                 CLC                     ; clear carry for the add
00DAC7  2  2C                 .byte $2C               ; makes next line BIT $1410
00DAC8  2               LAB_2680
00DAC8  2  10 12              BPL   LAB_2696          ; if +ve go handle underflow
00DACA  2               
00DACA  2  69 80              ADC   #$80              ; adjust exponent
00DACC  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00DACE  2  D0 03              BNE   LAB_268B          ; branch if not zero
00DAD0  2               
00DAD0  2  4C 5E D9           JMP   LAB_24F5          ; save FAC1 sign and return
00DAD3  2               
00DAD3  2               LAB_268B
00DAD3  2  A5 B8              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
00DAD5  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00DAD7  2               LAB_268F
00DAD7  2  60                 RTS
00DAD8  2               
00DAD8  2               ; handle overflow and underflow
00DAD8  2               
00DAD8  2               LAB_2690
00DAD8  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00DADA  2  10 1B              BPL   LAB_269B          ; do overflow error
00DADC  2               
00DADC  2                                             ; handle underflow
00DADC  2               LAB_2696
00DADC  2  68                 PLA                     ; pop return address low byte
00DADD  2  68                 PLA                     ; pop return address high byte
00DADE  2  4C 5A D9           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
00DAE1  2               
00DAE1  2               ; multiply by 10
00DAE1  2               
00DAE1  2               LAB_269E
00DAE1  2  20 D4 DB           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00DAE4  2  AA                 TAX                     ; copy exponent (set the flags)
00DAE5  2  F0 F0              BEQ   LAB_268F          ; exit if zero
00DAE7  2               
00DAE7  2  18                 CLC                     ; clear carry for add
00DAE8  2  69 02              ADC   #$02              ; add two to exponent (*4)
00DAEA  2  B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
00DAEC  2               
00DAEC  2  A2 00              LDX   #$00              ; clear byte
00DAEE  2  86 B8              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
00DAF0  2  20 E5 D8           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
00DAF3  2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*10)
00DAF5  2  D0 E0              BNE   LAB_268F          ; if non zero just do RTS
00DAF7  2               
00DAF7  2               LAB_269B
00DAF7  2  4C CD D9           JMP   LAB_2564          ; do overflow error and warm start
00DAFA  2               
00DAFA  2               ; divide by 10
00DAFA  2               
00DAFA  2               LAB_26B9
00DAFA  2  20 D4 DB           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00DAFD  2  A9 66              LDA   #<LAB_26B5        ; set pointer to 10d low addr
00DAFF  2  A0 F7              LDY   #>LAB_26B5        ; set pointer to 10d high addr
00DB01  2  A2 00              LDX   #$00              ; clear sign
00DB03  2               
00DB03  2               ; divide by (AY) (X=sign)
00DB03  2               
00DB03  2               LAB_26C2
00DB03  2  86 B8              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00DB05  2  20 87 DB           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00DB08  2  4C 0E DB           JMP   LAB_DIVIDE        ; do FAC2/FAC1
00DB0B  2               
00DB0B  2                                             ; Perform divide-by
00DB0B  2               ; convert AY and do (AY)/FAC1
00DB0B  2               
00DB0B  2               LAB_26CA
00DB0B  2  20 95 DA           JSR   LAB_264D          ; unpack memory (AY) into FAC2
00DB0E  2               
00DB0E  2                                             ; Perform divide-into
00DB0E  2               LAB_DIVIDE
00DB0E  2  F0 63              BEQ   LAB_2737          ; if zero go do /0 error
00DB10  2               
00DB10  2  20 E3 DB           JSR   LAB_27BA          ; round FAC1
00DB13  2  A9 00              LDA   #$00              ; clear A
00DB15  2  38                 SEC                     ; set carry for subtract
00DB16  2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
00DB18  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00DB1A  2  20 BB DA           JSR   LAB_2673          ; test and adjust accumulators
00DB1D  2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
00DB1F  2  F0 D6              BEQ   LAB_269B          ; if zero do overflow error
00DB21  2               
00DB21  2  A2 FF              LDX   #$FF              ; set index for pre increment
00DB23  2  A9 01              LDA   #$01              ; set bit to flag byte save
00DB25  2               LAB_26E4
00DB25  2  A4 B4              LDY   FAC2_1            ; get FAC2 mantissa1
00DB27  2  C4 AD              CPY   FAC1_1            ; compare FAC1 mantissa1
00DB29  2  D0 0A              BNE   LAB_26F4          ; branch if <>
00DB2B  2               
00DB2B  2  A4 B5              LDY   FAC2_2            ; get FAC2 mantissa2
00DB2D  2  C4 AE              CPY   FAC1_2            ; compare FAC1 mantissa2
00DB2F  2  D0 04              BNE   LAB_26F4          ; branch if <>
00DB31  2               
00DB31  2  A4 B6              LDY   FAC2_3            ; get FAC2 mantissa3
00DB33  2  C4 AF              CPY   FAC1_3            ; compare FAC1 mantissa3
00DB35  2               LAB_26F4
00DB35  2  08                 PHP                     ; save FAC2-FAC1 compare status
00DB36  2  2A                 ROL                     ; shift the result byte
00DB37  2  90 0E              BCC   LAB_2702          ; if no carry skip the byte save
00DB39  2               
00DB39  2  A0 01              LDY   #$01              ; set bit to flag byte save
00DB3B  2  E8                 INX                     ; else increment the index to FACt
00DB3C  2  E0 02              CPX   #$02              ; compare with the index to FACt_3
00DB3E  2  30 04              BMI   LAB_2701          ; if not last byte just go save it
00DB40  2               
00DB40  2  D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
00DB42  2                                             ; return
00DB42  2               
00DB42  2  A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
00DB44  2               LAB_2701
00DB44  2  95 75              STA   FACt_1,X          ; write result byte to FACt_1 + index
00DB46  2  98                 TYA                     ; copy the next save byte flag
00DB47  2               LAB_2702
00DB47  2  28                 PLP                     ; restore FAC2-FAC1 compare status
00DB48  2  90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
00DB4A  2               
00DB4A  2  A8                 TAY                     ; save FAC2-FAC1 compare status
00DB4B  2  A5 B6              LDA   FAC2_3            ; get FAC2 mantissa3
00DB4D  2  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
00DB4F  2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
00DB51  2  A5 B5              LDA   FAC2_2            ; get FAC2 mantissa2
00DB53  2  E5 AE              SBC   FAC1_2            ; subtract FAC1 mantissa2
00DB55  2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
00DB57  2  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
00DB59  2  E5 AD              SBC   FAC1_1            ; subtract FAC1 mantissa1
00DB5B  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00DB5D  2  98                 TYA                     ; restore FAC2-FAC1 compare status
00DB5E  2               
00DB5E  2                                             ; FAC2 = FAC2*2
00DB5E  2               LAB_2704
00DB5E  2  06 B6              ASL   FAC2_3            ; shift FAC2 mantissa3
00DB60  2  26 B5              ROL   FAC2_2            ; shift FAC2 mantissa2
00DB62  2  26 B4              ROL   FAC2_1            ; shift FAC2 mantissa1
00DB64  2  B0 CF              BCS   LAB_26F4          ; loop with no compare
00DB66  2               
00DB66  2  30 BD              BMI   LAB_26E4          ; loop with compare
00DB68  2               
00DB68  2  10 CB              BPL   LAB_26F4          ; loop always with no compare
00DB6A  2               
00DB6A  2               ; do A<<6, save as FAC1 rounding byte, normalise and return
00DB6A  2               
00DB6A  2               LAB_272B
00DB6A  2  4A                 LSR                     ; shift b1 - b0 ..
00DB6B  2  6A                 ROR                     ; ..
00DB6C  2  6A                 ROR                     ; .. to b7 - b6
00DB6D  2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
00DB6F  2  28                 PLP                     ; dump FAC2-FAC1 compare status
00DB70  2  4C 78 DB           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
00DB73  2               
00DB73  2               ; do "Divide by zero" error
00DB73  2               
00DB73  2               LAB_2737
00DB73  2  A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
00DB75  2  4C 49 C1           JMP   LAB_XERR          ; do error #X, then warm start
00DB78  2               
00DB78  2               ; copy temp to FAC1 and normalise
00DB78  2               
00DB78  2               LAB_273C
00DB78  2  A5 75              LDA   FACt_1            ; get temp mantissa1
00DB7A  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00DB7C  2  A5 76              LDA   FACt_2            ; get temp mantissa2
00DB7E  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00DB80  2  A5 77              LDA   FACt_3            ; get temp mantissa3
00DB82  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00DB84  2  4C 3E D9           JMP   LAB_24D5          ; normalise FAC1 and return
00DB87  2               
00DB87  2               ; unpack memory (AY) into FAC1
00DB87  2               
00DB87  2               LAB_UFAC
00DB87  2  85 71              STA   ut1_pl            ; save pointer low byte
00DB89  2  84 72              STY   ut1_ph            ; save pointer high byte
00DB8B  2  A0 03              LDY   #$03              ; 4 bytes to do
00DB8D  2  B1 71              LDA   (ut1_pl),Y        ; get last byte
00DB8F  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00DB91  2  88                 DEY                     ; decrement index
00DB92  2  B1 71              LDA   (ut1_pl),Y        ; get last-1 byte
00DB94  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00DB96  2  88                 DEY                     ; decrement index
00DB97  2  B1 71              LDA   (ut1_pl),Y        ; get second byte
00DB99  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00DB9B  2  09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
00DB9D  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00DB9F  2  88                 DEY                     ; decrement index
00DBA0  2  B1 71              LDA   (ut1_pl),Y        ; get first byte (exponent)
00DBA2  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00DBA4  2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
00DBA6  2  60                 RTS
00DBA7  2               
00DBA7  2               ; pack FAC1 into Adatal
00DBA7  2               
00DBA7  2               LAB_276E
00DBA7  2  A2 A4              LDX   #<Adatal          ; set pointer low byte
00DBA9  2               LAB_2770
00DBA9  2  A0 00              LDY   #>Adatal          ; set pointer high byte
00DBAB  2  F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
00DBAD  2               
00DBAD  2               ; pack FAC1 into (Lvarpl)
00DBAD  2               
00DBAD  2               LAB_PFAC
00DBAD  2  A6 97              LDX   Lvarpl            ; get destination pointer low byte
00DBAF  2  A4 98              LDY   Lvarph            ; get destination pointer high byte
00DBB1  2               
00DBB1  2               ; pack FAC1 into (XY)
00DBB1  2               
00DBB1  2               LAB_2778
00DBB1  2  20 E3 DB           JSR   LAB_27BA          ; round FAC1
00DBB4  2  86 71              STX   ut1_pl            ; save pointer low byte
00DBB6  2  84 72              STY   ut1_ph            ; save pointer high byte
00DBB8  2  A0 03              LDY   #$03              ; set index
00DBBA  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00DBBC  2  91 71              STA   (ut1_pl),Y        ; store in destination
00DBBE  2  88                 DEY                     ; decrement index
00DBBF  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00DBC1  2  91 71              STA   (ut1_pl),Y        ; store in destination
00DBC3  2  88                 DEY                     ; decrement index
00DBC4  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00DBC6  2  09 7F              ORA   #$7F              ; set bits x111 1111
00DBC8  2  25 AD              AND   FAC1_1            ; AND in FAC1 mantissa1
00DBCA  2  91 71              STA   (ut1_pl),Y        ; store in destination
00DBCC  2  88                 DEY                     ; decrement index
00DBCD  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DBCF  2  91 71              STA   (ut1_pl),Y        ; store in destination
00DBD1  2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
00DBD3  2  60                 RTS
00DBD4  2               
00DBD4  2               ; round and copy FAC1 to FAC2
00DBD4  2               
00DBD4  2               LAB_27AB
00DBD4  2  20 E3 DB           JSR   LAB_27BA          ; round FAC1
00DBD7  2               
00DBD7  2               ; copy FAC1 to FAC2
00DBD7  2               
00DBD7  2               LAB_27AE
00DBD7  2  A2 05              LDX   #$05              ; 5 bytes to copy
00DBD9  2               LAB_27B0
00DBD9  2  B5 AB              LDA   FAC1_e-1,X        ; get byte from FAC1,X
00DBDB  2  95 B2              STA   FAC1_o,X          ; save byte at FAC2,X
00DBDD  2  CA                 DEX                     ; decrement count
00DBDE  2  D0 F9              BNE   LAB_27B0          ; loop if not all done
00DBE0  2               
00DBE0  2  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
00DBE2  2               LAB_27B9
00DBE2  2  60                 RTS
00DBE3  2               
00DBE3  2               ; round FAC1
00DBE3  2               
00DBE3  2               LAB_27BA
00DBE3  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DBE5  2  F0 FB              BEQ   LAB_27B9          ; exit if zero
00DBE7  2               
00DBE7  2  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
00DBE9  2  90 F7              BCC   LAB_27B9          ; exit if no overflow
00DBEB  2               
00DBEB  2               ; round FAC1 (no check)
00DBEB  2               
00DBEB  2               LAB_27C2
00DBEB  2  20 C2 D9           JSR   LAB_2559          ; increment FAC1 mantissa
00DBEE  2  D0 F2              BNE   LAB_27B9          ; branch if no overflow
00DBF0  2               
00DBF0  2  4C 93 D9           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
00DBF3  2               
00DBF3  2               ; get FAC1 sign
00DBF3  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00DBF3  2               
00DBF3  2               LAB_27CA
00DBF3  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DBF5  2  F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
00DBF7  2               
00DBF7  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00DBF7  2               ; no = 0 check
00DBF7  2               
00DBF7  2               LAB_27CE
00DBF7  2  A5 B0              LDA   FAC1_s            ; else get FAC1 sign (b7)
00DBF9  2               
00DBF9  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00DBF9  2               ; no = 0 check, sign in A
00DBF9  2               
00DBF9  2               LAB_27D0
00DBF9  2  2A                 ROL                     ; move sign bit to carry
00DBFA  2  A9 FF              LDA   #$FF              ; set byte for -ve result
00DBFC  2  B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
00DBFE  2               
00DBFE  2  A9 01              LDA   #$01              ; else set byte for +ve result
00DC00  2               LAB_27D7
00DC00  2  60                 RTS
00DC01  2               
00DC01  2               ; perform SGN()
00DC01  2               
00DC01  2               LAB_SGN
00DC01  2  20 F3 DB           JSR   LAB_27CA          ; get FAC1 sign
00DC04  2                                             ; return A=$FF/-ve A=$01/+ve
00DC04  2               ; save A as integer byte
00DC04  2               
00DC04  2               LAB_27DB
00DC04  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00DC06  2  A9 00              LDA   #$00              ; clear A
00DC08  2  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
00DC0A  2  A2 88              LDX   #$88              ; set exponent
00DC0C  2               
00DC0C  2               ; set exp=X, clearFAC1 mantissa3 and normalise
00DC0C  2               
00DC0C  2               LAB_27E3
00DC0C  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00DC0E  2  49 FF              EOR   #$FF              ; complement it
00DC10  2  2A                 ROL                     ; sign bit into carry
00DC11  2               
00DC11  2               ; set exp=X, clearFAC1 mantissa3 and normalise
00DC11  2               
00DC11  2               LAB_STFA
00DC11  2  A9 00              LDA   #$00              ; clear A
00DC13  2  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
00DC15  2  86 AC              STX   FAC1_e            ; set FAC1 exponent
00DC17  2  85 B9              STA   FAC1_r            ; clear FAC1 rounding byte
00DC19  2  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
00DC1B  2  4C 39 D9           JMP   LAB_24D0          ; do ABS and normalise FAC1
00DC1E  2               
00DC1E  2               ; perform ABS()
00DC1E  2               
00DC1E  2               LAB_ABS
00DC1E  2  46 B0              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
00DC20  2  60                 RTS
00DC21  2               
00DC21  2               ; compare FAC1 with (AY)
00DC21  2               ; returns A=$00 if FAC1 = (AY)
00DC21  2               ; returns A=$01 if FAC1 > (AY)
00DC21  2               ; returns A=$FF if FAC1 < (AY)
00DC21  2               
00DC21  2               LAB_27F8
00DC21  2  85 73              STA   ut2_pl            ; save pointer low byte
00DC23  2               LAB_27FA
00DC23  2  84 74              STY   ut2_ph            ; save pointer high byte
00DC25  2  A0 00              LDY   #$00              ; clear index
00DC27  2  B1 73              LDA   (ut2_pl),Y        ; get exponent
00DC29  2  C8                 INY                     ; increment index
00DC2A  2  AA                 TAX                     ; copy (AY) exponent to X
00DC2B  2  F0 C6              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
00DC2D  2                                             ; A=FF,C=1/-ve A=01,C=0/+ve
00DC2D  2               
00DC2D  2  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
00DC2F  2  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
00DC31  2  30 C4              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
00DC33  2                                             ; A=01,C=0/+ve and return
00DC33  2               
00DC33  2  E4 AC              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
00DC35  2  D0 1A              BNE   LAB_2828          ; branch if different
00DC37  2               
00DC37  2  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
00DC39  2  09 80              ORA   #$80              ; normalise top bit
00DC3B  2  C5 AD              CMP   FAC1_1            ; compare with FAC1 mantissa1
00DC3D  2  D0 12              BNE   LAB_2828          ; branch if different
00DC3F  2               
00DC3F  2  C8                 INY                     ; increment index
00DC40  2  B1 73              LDA   (ut2_pl),Y        ; get mantissa2
00DC42  2  C5 AE              CMP   FAC1_2            ; compare with FAC1 mantissa2
00DC44  2  D0 0B              BNE   LAB_2828          ; branch if different
00DC46  2               
00DC46  2  C8                 INY                     ; increment index
00DC47  2  A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
00DC49  2  C5 B9              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
00DC4B  2  B1 73              LDA   (ut2_pl),Y        ; get mantissa3
00DC4D  2  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
00DC4F  2  F0 28              BEQ   LAB_2850          ; exit if mantissa3 equal
00DC51  2               
00DC51  2               ; gets here if number <> FAC1
00DC51  2               
00DC51  2               LAB_2828
00DC51  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00DC53  2  90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
00DC55  2               
00DC55  2  49 FF              EOR   #$FF              ; else toggle FAC1 sign
00DC57  2               LAB_282E
00DC57  2  4C F9 DB           JMP   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
00DC5A  2               
00DC5A  2               ; convert FAC1 floating-to-fixed
00DC5A  2               
00DC5A  2               LAB_2831
00DC5A  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DC5C  2  F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
00DC5E  2               
00DC5E  2  38                 SEC                     ; set carry for subtract
00DC5F  2  E9 98              SBC   #$98              ; subtract maximum integer range exponent
00DC61  2  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
00DC63  2  10 09              BPL   LAB_2845          ; branch if FAC1 +ve
00DC65  2               
00DC65  2                                             ; FAC1 was -ve
00DC65  2  AA                 TAX                     ; copy subtracted exponent
00DC66  2  A9 FF              LDA   #$FF              ; overflow for -ve number
00DC68  2  85 B2              STA   FAC1_o            ; set FAC1 overflow byte
00DC6A  2  20 A6 D9           JSR   LAB_253D          ; twos complement FAC1 mantissa
00DC6D  2  8A                 TXA                     ; restore subtracted exponent
00DC6E  2               LAB_2845
00DC6E  2  A2 AC              LDX   #FAC1_e           ; set index to FAC1
00DC70  2  C9 F9              CMP   #$F9              ; compare exponent result
00DC72  2  10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
00DC74  2               
00DC74  2  20 E4 D9           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
00DC77  2  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
00DC79  2               LAB_2850
00DC79  2  60                 RTS
00DC7A  2               
00DC7A  2               ; shift FAC1 A times right
00DC7A  2               
00DC7A  2               LAB_2851
00DC7A  2  A8                 TAY                     ; copy shift count
00DC7B  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00DC7D  2  29 80              AND   #$80              ; mask sign bit only (x000 0000)
00DC7F  2  46 AD              LSR   FAC1_1            ; shift FAC1 mantissa1
00DC81  2  05 AD              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
00DC83  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00DC85  2  20 FB D9           JSR   LAB_2592          ; shift FAC1 Y times right
00DC88  2  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
00DC8A  2  60                 RTS
00DC8B  2               
00DC8B  2               ; perform INT()
00DC8B  2               
00DC8B  2               LAB_INT
00DC8B  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DC8D  2  C9 98              CMP   #$98              ; compare with max int
00DC8F  2  B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
00DC91  2               
00DC91  2  20 5A DC           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
00DC94  2  84 B9              STY   FAC1_r            ; save FAC1 rounding byte
00DC96  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00DC98  2  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
00DC9A  2  49 80              EOR   #$80              ; toggle FAC1 sign
00DC9C  2  2A                 ROL                     ; shift into carry
00DC9D  2  A9 98              LDA   #$98              ; set new exponent
00DC9F  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00DCA1  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00DCA3  2  85 5B              STA   Temp3             ; save for EXP() function
00DCA5  2  4C 39 D9           JMP   LAB_24D0          ; do ABS and normalise FAC1
00DCA8  2               
00DCA8  2               ; clear FAC1 and return
00DCA8  2               
00DCA8  2               LAB_287F
00DCA8  2  85 AD              STA   FAC1_1            ; clear FAC1 mantissa1
00DCAA  2  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
00DCAC  2  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
00DCAE  2  A8                 TAY                     ; clear Y
00DCAF  2               LAB_2886
00DCAF  2  60                 RTS
00DCB0  2               
00DCB0  2               ; get FAC1 from string
00DCB0  2               ; this routine now handles hex and binary values from strings
00DCB0  2               ; starting with "$" and "%" respectively
00DCB0  2               
00DCB0  2               LAB_2887
00DCB0  2  A0 00              LDY   #$00              ; clear Y
00DCB2  2  84 5F              STY   Dtypef            ; clear data type flag, $FF=string, $00=numeric
00DCB4  2  A2 09              LDX   #$09              ; set index
00DCB6  2               LAB_288B
00DCB6  2  94 A8              STY   numexp,X          ; clear byte
00DCB8  2  CA                 DEX                     ; decrement index
00DCB9  2  10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
00DCBB  2               
00DCBB  2  90 7F              BCC   LAB_28FE          ; branch if 1st character numeric
00DCBD  2               
00DCBD  2               ; get FAC1 from string .. first character wasn't numeric
00DCBD  2               
00DCBD  2  C9 2D              CMP   #'-'              ; else compare with "-"
00DCBF  2  D0 04              BNE   LAB_289A          ; branch if not "-"
00DCC1  2               
00DCC1  2  86 B1              STX   negnum            ; set flag for -ve number (X = $FF)
00DCC3  2  F0 04              BEQ   LAB_289C          ; branch always (go scan and check for hex/bin)
00DCC5  2               
00DCC5  2               ; get FAC1 from string .. first character wasn't numeric or -
00DCC5  2               
00DCC5  2               LAB_289A
00DCC5  2  C9 2B              CMP   #'+'              ; else compare with "+"
00DCC7  2  D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
00DCC9  2               
00DCC9  2               ; was "+" or "-" to start, so get next character
00DCC9  2               
00DCC9  2               LAB_289C
00DCC9  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00DCCC  2  90 6E              BCC   LAB_28FE          ; branch if numeric character
00DCCE  2               
00DCCE  2               ; code here for hex and binary numbers
00DCCE  2               
00DCCE  2               LAB_289D
00DCCE  2  C9 24              CMP   #'$'              ; else compare with "$"
00DCD0  2  D0 03              BNE   LAB_NHEX          ; branch if not "$"
00DCD2  2               
00DCD2  2  4C 6B E2           JMP   LAB_CHEX          ; branch if "$"
00DCD5  2               
00DCD5  2               LAB_NHEX
00DCD5  2  C9 25              CMP   #'%'              ; else compare with "%"
00DCD7  2  D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
00DCD9  2               
00DCD9  2  4C 99 E2           JMP   LAB_CBIN          ; branch if "%"
00DCDC  2               
00DCDC  2               LAB_289E
00DCDC  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
00DCDF  2               LAB_28A1
00DCDF  2  90 5B              BCC   LAB_28FE          ; branch if numeric character
00DCE1  2               
00DCE1  2               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
00DCE1  2               
00DCE1  2               LAB_28A3
00DCE1  2  C9 2E              CMP   #'.'              ; else compare with "."
00DCE3  2  F0 2E              BEQ   LAB_28D5          ; branch if "."
00DCE5  2               
00DCE5  2               ; get FAC1 from string .. character wasn't numeric, -, + or .
00DCE5  2               
00DCE5  2  C9 45              CMP   #'E'              ; else compare with "E"
00DCE7  2  D0 30              BNE   LAB_28DB          ; branch if not "E"
00DCE9  2               
00DCE9  2                                             ; was "E" so evaluate exponential part
00DCE9  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00DCEC  2  90 17              BCC   LAB_28C7          ; branch if numeric character
00DCEE  2               
00DCEE  2  C9 CD              CMP   #TK_MINUS         ; else compare with token for -
00DCF0  2  F0 0E              BEQ   LAB_28C2          ; branch if token for -
00DCF2  2               
00DCF2  2  C9 2D              CMP   #'-'              ; else compare with "-"
00DCF4  2  F0 0A              BEQ   LAB_28C2          ; branch if "-"
00DCF6  2               
00DCF6  2  C9 CC              CMP   #TK_PLUS          ; else compare with token for +
00DCF8  2  F0 08              BEQ   LAB_28C4          ; branch if token for +
00DCFA  2               
00DCFA  2  C9 2B              CMP   #'+'              ; else compare with "+"
00DCFC  2  F0 04              BEQ   LAB_28C4          ; branch if "+"
00DCFE  2               
00DCFE  2  D0 07              BNE   LAB_28C9          ; branch always
00DD00  2               
00DD00  2               LAB_28C2
00DD00  2  66 AB              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
00DD02  2               LAB_28C4
00DD02  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00DD05  2               LAB_28C7
00DD05  2  90 5B              BCC   LAB_2925          ; branch if numeric character
00DD07  2               
00DD07  2               LAB_28C9
00DD07  2  24 AB              BIT   expneg            ; test exponent -ve flag
00DD09  2  10 0E              BPL   LAB_28DB          ; if +ve go evaluate exponent
00DD0B  2               
00DD0B  2                                             ; else do exponent = -exponent
00DD0B  2  A9 00              LDA   #$00              ; clear result
00DD0D  2  38                 SEC                     ; set carry for subtract
00DD0E  2  E5 A9              SBC   expcnt            ; subtract exponent byte
00DD10  2  4C 1B DD           JMP   LAB_28DD          ; go evaluate exponent
00DD13  2               
00DD13  2               LAB_28D5
00DD13  2  66 AA              ROR   numdpf            ; set decimal point flag
00DD15  2  24 AA              BIT   numdpf            ; test decimal point flag
00DD17  2  50 C3              BVC   LAB_289E          ; branch if only one decimal point so far
00DD19  2               
00DD19  2                                             ; evaluate exponent
00DD19  2               LAB_28DB
00DD19  2  A5 A9              LDA   expcnt            ; get exponent count byte
00DD1B  2               LAB_28DD
00DD1B  2  38                 SEC                     ; set carry for subtract
00DD1C  2  E5 A8              SBC   numexp            ; subtract numerator exponent
00DD1E  2  85 A9              STA   expcnt            ; save exponent count byte
00DD20  2  F0 12              BEQ   LAB_28F6          ; branch if no adjustment
00DD22  2               
00DD22  2  10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
00DD24  2               
00DD24  2                                             ; else go do FAC1/10^(0-expcnt)
00DD24  2               LAB_28E6
00DD24  2  20 FA DA           JSR   LAB_26B9          ; divide by 10
00DD27  2  E6 A9              INC   expcnt            ; increment exponent count byte
00DD29  2  D0 F9              BNE   LAB_28E6          ; loop until all done
00DD2B  2               
00DD2B  2  F0 07              BEQ   LAB_28F6          ; branch always
00DD2D  2               
00DD2D  2               LAB_28EF
00DD2D  2  20 E1 DA           JSR   LAB_269E          ; multiply by 10
00DD30  2  C6 A9              DEC   expcnt            ; decrement exponent count byte
00DD32  2  D0 F9              BNE   LAB_28EF          ; loop until all done
00DD34  2               
00DD34  2               LAB_28F6
00DD34  2  A5 B1              LDA   negnum            ; get -ve flag
00DD36  2  30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
00DD38  2               
00DD38  2  60                 RTS
00DD39  2               
00DD39  2               ; do - FAC1 and return
00DD39  2               
00DD39  2               LAB_28FB
00DD39  2  4C FE DE           JMP   LAB_GTHAN         ; do - FAC1 and return
00DD3C  2               
00DD3C  2               ; do unsigned FAC1*10+number
00DD3C  2               
00DD3C  2               LAB_28FE
00DD3C  2  48                 PHA                     ; save character
00DD3D  2  24 AA              BIT   numdpf            ; test decimal point flag
00DD3F  2  10 02              BPL   LAB_2905          ; skip exponent increment if not set
00DD41  2               
00DD41  2  E6 A8              INC   numexp            ; else increment number exponent
00DD43  2               LAB_2905
00DD43  2  20 E1 DA           JSR   LAB_269E          ; multiply FAC1 by 10
00DD46  2  68                 PLA                     ; restore character
00DD47  2  29 0F              AND   #$0F              ; convert to binary
00DD49  2  20 4F DD           JSR   LAB_2912          ; evaluate new ASCII digit
00DD4C  2  4C DC DC           JMP   LAB_289E          ; go do next character
00DD4F  2               
00DD4F  2               ; evaluate new ASCII digit
00DD4F  2               
00DD4F  2               LAB_2912
00DD4F  2  48                 PHA                     ; save digit
00DD50  2  20 D4 DB           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00DD53  2  68                 PLA                     ; restore digit
00DD54  2  20 04 DC           JSR   LAB_27DB          ; save A as integer byte
00DD57  2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
00DD59  2  45 B0              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
00DD5B  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00DD5D  2  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
00DD5F  2  4C CB D8           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
00DD62  2               
00DD62  2               ; evaluate next character of exponential part of number
00DD62  2               
00DD62  2               LAB_2925
00DD62  2  A5 A9              LDA   expcnt            ; get exponent count byte
00DD64  2  C9 0A              CMP   #$0A              ; compare with 10 decimal
00DD66  2  90 09              BCC   LAB_2934          ; branch if less
00DD68  2               
00DD68  2  A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
00DD6A  2  24 AB              BIT   expneg            ; test exponent -ve flag
00DD6C  2  30 0E              BMI   LAB_2942          ; branch if -ve
00DD6E  2               
00DD6E  2  4C CD D9           JMP   LAB_2564          ; else do overflow error
00DD71  2               
00DD71  2               LAB_2934
00DD71  2  0A                 ASL                     ; * 2
00DD72  2  0A                 ASL                     ; * 4
00DD73  2  65 A9              ADC   expcnt            ; * 5
00DD75  2  0A                 ASL                     ; * 10
00DD76  2  A0 00              LDY   #$00              ; set index
00DD78  2  71 C3              ADC   (Bpntrl),Y        ; add character (will be $30 too much!)
00DD7A  2  E9 2F              SBC   #'0'-1            ; convert character to binary
00DD7C  2               LAB_2942
00DD7C  2  85 A9              STA   expcnt            ; save exponent count byte
00DD7E  2  4C 02 DD           JMP   LAB_28C4          ; go get next character
00DD81  2               
00DD81  2               ; print " in line [LINE #]"
00DD81  2               
00DD81  2               LAB_2953
00DD81  2  A9 A6              LDA   #<LAB_LMSG        ; point to " in line " message low byte
00DD83  2  A0 FE              LDY   #>LAB_LMSG        ; point to " in line " message high byte
00DD85  2  20 2A CA           JSR   LAB_18C3          ; print null terminated string from memory
00DD88  2               
00DD88  2               ; print Basic line #
00DD88  2  A5 88              LDA   Clineh            ; get current line high byte
00DD8A  2  A6 87              LDX   Clinel            ; get current line low byte
00DD8C  2               
00DD8C  2               ; print AX as unsigned integer (A=high byte, X=low byte)
00DD8C  2               
00DD8C  2               LAB_295E
00DD8C  2  85 AD              STA   FAC1_1            ; save high byte as FAC1 mantissa1
00DD8E  2  86 AE              STX   FAC1_2            ; save low byte as FAC1 mantissa2
00DD90  2  A2 90              LDX   #$90              ; set exponent to 16d bits
00DD92  2  38                 SEC                     ; set integer is +ve flag
00DD93  2  20 11 DC           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
00DD96  2  A0 00              LDY   #$00              ; clear index
00DD98  2  98                 TYA                     ; clear A
00DD99  2  20 AC DD           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
00DD9C  2  4C 2A CA           JMP   LAB_18C3          ; print null terminated string from memory and return
00DD9F  2               
00DD9F  2               ; convert FAC1 to ASCII string result in (AY)
00DD9F  2               ; not any more, moved scratchpad to page 0
00DD9F  2               
00DD9F  2               LAB_296E
00DD9F  2  A0 01              LDY   #$01              ; set index = 1
00DDA1  2  A9 20              LDA   #$20              ; character = " " (assume +ve)
00DDA3  2  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
00DDA5  2  10 02              BPL   LAB_2978          ; branch if +ve
00DDA7  2               
00DDA7  2  A9 2D              LDA   #$2D              ; else character = "-"
00DDA9  2               LAB_2978
00DDA9  2  99 EF 00           STA   Decss,Y           ; save leading character (" " or "-")
00DDAC  2               LAB_297B
00DDAC  2  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
00DDAE  2  84 BA              STY   Sendl             ; save index
00DDB0  2  C8                 INY                     ; increment index
00DDB1  2  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
00DDB3  2  D0 05              BNE   LAB_2989          ; branch if FAC1<>0
00DDB5  2               
00DDB5  2                                             ; exponent was $00 so FAC1 is 0
00DDB5  2  A9 30              LDA   #'0'              ; set character = "0"
00DDB7  2  4C B8 DE           JMP   LAB_2A89          ; save last character, [EOT] and exit
00DDBA  2               
00DDBA  2                                             ; FAC1 is some non zero value
00DDBA  2               LAB_2989
00DDBA  2  A9 00              LDA   #$00              ; clear (number exponent count)
00DDBC  2  E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
00DDBE  2               
00DDBE  2  B0 09              BCS   LAB_299A          ; branch if FAC1=>1
00DDC0  2               
00DDC0  2                                             ; FAC1<1
00DDC0  2  A9 F6              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
00DDC2  2  A0 F6              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
00DDC4  2  20 43 DA           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00DDC7  2  A9 FA              LDA   #$FA              ; set number exponent count (-6)
00DDC9  2               LAB_299A
00DDC9  2  85 A8              STA   numexp            ; save number exponent count
00DDCB  2               LAB_299C
00DDCB  2  A9 F2              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
00DDCD  2  A0 F6              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
00DDCF  2  20 21 DC           JSR   LAB_27F8          ; compare FAC1 with (AY)
00DDD2  2  F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
00DDD4  2               
00DDD4  2  10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
00DDD6  2               
00DDD6  2                                             ; FAC1 < (AY)
00DDD6  2               LAB_29A7
00DDD6  2  A9 EE              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
00DDD8  2  A0 F6              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
00DDDA  2  20 21 DC           JSR   LAB_27F8          ; compare FAC1 with (AY)
00DDDD  2  F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
00DDDF  2               
00DDDF  2  10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
00DDE1  2               
00DDE1  2                                             ; FAC1 <= (AY)
00DDE1  2               LAB_29B2
00DDE1  2  20 E1 DA           JSR   LAB_269E          ; multiply by 10
00DDE4  2  C6 A8              DEC   numexp            ; decrement number exponent count
00DDE6  2  D0 EE              BNE   LAB_29A7          ; go test again (branch always)
00DDE8  2               
00DDE8  2               LAB_29B9
00DDE8  2  20 FA DA           JSR   LAB_26B9          ; divide by 10
00DDEB  2  E6 A8              INC   numexp            ; increment number exponent count
00DDED  2  D0 DC              BNE   LAB_299C          ; go test again (branch always)
00DDEF  2               
00DDEF  2               ; now we have just the digits to do
00DDEF  2               
00DDEF  2               LAB_29C0
00DDEF  2  20 C4 D8           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
00DDF2  2               LAB_29C3
00DDF2  2  20 5A DC           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
00DDF5  2  A2 01              LDX   #$01              ; set default digits before dp = 1
00DDF7  2  A5 A8              LDA   numexp            ; get number exponent count
00DDF9  2  18                 CLC                     ; clear carry for add
00DDFA  2  69 07              ADC   #$07              ; up to 6 digits before point
00DDFC  2  30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
00DDFE  2               
00DDFE  2  C9 08              CMP   #$08              ; A>=8 if n>=1E6
00DE00  2  B0 06              BCS   LAB_29D9          ; branch if >= $08
00DE02  2               
00DE02  2                                             ; carry is clear
00DE02  2  69 FF              ADC   #$FF              ; take 1 from digit count
00DE04  2  AA                 TAX                     ; copy to A
00DE05  2  A9 02              LDA   #$02              ;.set exponent adjust
00DE07  2               LAB_29D8
00DE07  2  38                 SEC                     ; set carry for subtract
00DE08  2               LAB_29D9
00DE08  2  E9 02              SBC   #$02              ; -2
00DE0A  2  85 A9              STA   expcnt            ;.save exponent adjust
00DE0C  2  86 A8              STX   numexp            ; save digits before dp count
00DE0E  2  8A                 TXA                     ; copy to A
00DE0F  2  F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
00DE11  2               
00DE11  2  10 13              BPL   LAB_29F7          ; branch if digits before dp
00DE13  2               
00DE13  2               LAB_29E4
00DE13  2  A4 BA              LDY   Sendl             ; get output string index
00DE15  2  A9 2E              LDA   #$2E              ; character "."
00DE17  2  C8                 INY                     ; increment index
00DE18  2  99 EF 00           STA   Decss,Y           ; save to output string
00DE1B  2  8A                 TXA                     ;.
00DE1C  2  F0 06              BEQ   LAB_29F5          ;.
00DE1E  2               
00DE1E  2  A9 30              LDA   #'0'              ; character "0"
00DE20  2  C8                 INY                     ; increment index
00DE21  2  99 EF 00           STA   Decss,Y           ; save to output string
00DE24  2               LAB_29F5
00DE24  2  84 BA              STY   Sendl             ; save output string index
00DE26  2               LAB_29F7
00DE26  2  A0 00              LDY   #$00              ; clear index (point to 100,000)
00DE28  2  A2 80              LDX   #$80              ;
00DE2A  2               LAB_29FB
00DE2A  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00DE2C  2  18                 CLC                     ; clear carry for add
00DE2D  2  79 6C F7           ADC   LAB_2A9C,Y        ; add -ve LSB
00DE30  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00DE32  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00DE34  2  79 6B F7           ADC   LAB_2A9B,Y        ; add -ve NMSB
00DE37  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00DE39  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00DE3B  2  79 6A F7           ADC   LAB_2A9A,Y        ; add -ve MSB
00DE3E  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00DE40  2  E8                 INX                     ;
00DE41  2  B0 04              BCS   LAB_2A18          ;
00DE43  2               
00DE43  2  10 E5              BPL   LAB_29FB          ; not -ve so try again
00DE45  2               
00DE45  2  30 02              BMI   LAB_2A1A          ;
00DE47  2               
00DE47  2               LAB_2A18
00DE47  2  30 E1              BMI   LAB_29FB          ;
00DE49  2               
00DE49  2               LAB_2A1A
00DE49  2  8A                 TXA                     ;
00DE4A  2  90 04              BCC   LAB_2A21          ;
00DE4C  2               
00DE4C  2  49 FF              EOR   #$FF              ;
00DE4E  2  69 0A              ADC   #$0A              ;
00DE50  2               LAB_2A21
00DE50  2  69 2F              ADC   #'0'-1            ; add "0"-1 to result
00DE52  2  C8                 INY                     ; increment index ..
00DE53  2  C8                 INY                     ; .. to next less ..
00DE54  2  C8                 INY                     ; .. power of ten
00DE55  2  84 95              STY   Cvaral            ; save as current var address low byte
00DE57  2  A4 BA              LDY   Sendl             ; get output string index
00DE59  2  C8                 INY                     ; increment output string index
00DE5A  2  AA                 TAX                     ; copy character to X
00DE5B  2  29 7F              AND   #$7F              ; mask out top bit
00DE5D  2  99 EF 00           STA   Decss,Y           ; save to output string
00DE60  2  C6 A8              DEC   numexp            ; decrement # of characters before the dp
00DE62  2  D0 06              BNE   LAB_2A3B          ; branch if still characters to do
00DE64  2               
00DE64  2                                             ; else output the point
00DE64  2  A9 2E              LDA   #$2E              ; character "."
00DE66  2  C8                 INY                     ; increment output string index
00DE67  2  99 EF 00           STA   Decss,Y           ; save to output string
00DE6A  2               LAB_2A3B
00DE6A  2  84 BA              STY   Sendl             ; save output string index
00DE6C  2  A4 95              LDY   Cvaral            ; get current var address low byte
00DE6E  2  8A                 TXA                     ; get character back
00DE6F  2  49 FF              EOR   #$FF              ;
00DE71  2  29 80              AND   #$80              ;
00DE73  2  AA                 TAX                     ;
00DE74  2  C0 12              CPY   #$12              ; compare index with max
00DE76  2  D0 B2              BNE   LAB_29FB          ; loop if not max
00DE78  2               
00DE78  2                                             ; now remove trailing zeroes
00DE78  2  A4 BA              LDY   Sendl             ; get output string index
00DE7A  2               LAB_2A4B
00DE7A  2  B9 EF 00           LDA   Decss,Y           ; get character from output string
00DE7D  2  88                 DEY                     ; decrement output string index
00DE7E  2  C9 30              CMP   #'0'              ; compare with "0"
00DE80  2  F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
00DE82  2               
00DE82  2  C9 2E              CMP   #'.'              ; compare with "."
00DE84  2  F0 01              BEQ   LAB_2A58          ; branch if was dp
00DE86  2               
00DE86  2                                             ; restore last character
00DE86  2  C8                 INY                     ; increment output string index
00DE87  2               LAB_2A58
00DE87  2  A9 2B              LDA   #$2B              ; character "+"
00DE89  2  A6 A9              LDX   expcnt            ; get exponent count
00DE8B  2  F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
00DE8D  2               
00DE8D  2                                             ; exponent isn't zero so write exponent
00DE8D  2  10 08              BPL   LAB_2A68          ; branch if exponent count +ve
00DE8F  2               
00DE8F  2  A9 00              LDA   #$00              ; clear A
00DE91  2  38                 SEC                     ; set carry for subtract
00DE92  2  E5 A9              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
00DE94  2  AA                 TAX                     ; copy exponent count to X
00DE95  2  A9 2D              LDA   #'-'              ; character "-"
00DE97  2               LAB_2A68
00DE97  2  99 F1 00           STA   Decss+2,Y         ; save to output string
00DE9A  2  A9 45              LDA   #$45              ; character "E"
00DE9C  2  99 F0 00           STA   Decss+1,Y         ; save exponent sign to output string
00DE9F  2  8A                 TXA                     ; get exponent count back
00DEA0  2  A2 2F              LDX   #'0'-1            ; one less than "0" character
00DEA2  2  38                 SEC                     ; set carry for subtract
00DEA3  2               LAB_2A74
00DEA3  2  E8                 INX                     ; increment 10's character
00DEA4  2  E9 0A              SBC   #$0A              ;.subtract 10 from exponent count
00DEA6  2  B0 FB              BCS   LAB_2A74          ; loop while still >= 0
00DEA8  2               
00DEA8  2  69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
00DEAA  2  99 F3 00           STA   Decss+4,Y         ; save to output string
00DEAD  2  8A                 TXA                     ; copy 10's character
00DEAE  2  99 F2 00           STA   Decss+3,Y         ; save to output string
00DEB1  2  A9 00              LDA   #$00              ; set null terminator
00DEB3  2  99 F4 00           STA   Decss+5,Y         ; save to output string
00DEB6  2  F0 08              BEQ   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
00DEB8  2               
00DEB8  2                                             ; save last character, [EOT] and exit
00DEB8  2               LAB_2A89
00DEB8  2  99 EF 00           STA   Decss,Y           ; save last character to output string
00DEBB  2               
00DEBB  2                                             ; set null terminator and exit
00DEBB  2               LAB_2A8C
00DEBB  2  A9 00              LDA   #$00              ; set null terminator
00DEBD  2  99 F0 00           STA   Decss+1,Y         ; save after last character
00DEC0  2               
00DEC0  2                                             ; set string pointer (AY) and exit
00DEC0  2               LAB_2A91
00DEC0  2  A9 F0              LDA   #<Decssp1         ; set result string low pointer
00DEC2  2  A0 00              LDY   #>Decssp1         ; set result string high pointer
00DEC4  2  60                 RTS
00DEC5  2               
00DEC5  2               ; perform power function
00DEC5  2               
00DEC5  2               LAB_POWER
00DEC5  2  F0 42              BEQ   LAB_EXP           ; go do  EXP()
00DEC7  2               
00DEC7  2  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
00DEC9  2  D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
00DECB  2               
00DECB  2  4C 5C D9           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
00DECE  2               
00DECE  2               LAB_2ABF
00DECE  2  A2 9C              LDX   #<func_l          ; set destination pointer low byte
00DED0  2  A0 00              LDY   #>func_l          ; set destination pointer high byte
00DED2  2  20 B1 DB           JSR   LAB_2778          ; pack FAC1 into (XY)
00DED5  2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
00DED7  2  10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
00DED9  2               
00DED9  2                                             ; else FAC2 is -ve and can only be raised to an
00DED9  2                                             ; integer power which gives an x +j0 result
00DED9  2  20 8B DC           JSR   LAB_INT           ; perform INT
00DEDC  2  A9 9C              LDA   #<func_l          ; set source pointer low byte
00DEDE  2  A0 00              LDY   #>func_l          ; set source pointer high byte
00DEE0  2  20 21 DC           JSR   LAB_27F8          ; compare FAC1 with (AY)
00DEE3  2  D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
00DEE5  2                                             ; this will leave FAC1 -ve and cause a Function Call
00DEE5  2                                             ; error when LOG() is called
00DEE5  2               
00DEE5  2  98                 TYA                     ; clear sign b7
00DEE6  2  A4 5B              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
00DEE8  2                                             ; for possible later negation, b0
00DEE8  2               LAB_2AD9
00DEE8  2  20 CF D8           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
00DEEB  2  98                 TYA                     ; copy sign back ..
00DEEC  2  48                 PHA                     ; .. and save it
00DEED  2  20 05 DA           JSR   LAB_LOG           ; do LOG(n)
00DEF0  2  A9 9C              LDA   #<garb_l          ; set pointer low byte
00DEF2  2  A0 00              LDY   #>garb_l          ; set pointer high byte
00DEF4  2  20 43 DA           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
00DEF7  2  20 09 DF           JSR   LAB_EXP           ; go do EXP(n)
00DEFA  2  68                 PLA                     ; pull sign from stack
00DEFB  2  4A                 LSR                     ; b0 is to be tested, shift to Cb
00DEFC  2  90 0A              BCC   LAB_2AF9          ; if no bit then exit
00DEFE  2               
00DEFE  2                                             ; Perform negation
00DEFE  2               ; do - FAC1
00DEFE  2               
00DEFE  2               LAB_GTHAN
00DEFE  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DF00  2  F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
00DF02  2               
00DF02  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00DF04  2  49 FF              EOR   #$FF              ; complement it
00DF06  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00DF08  2               LAB_2AF9
00DF08  2  60                 RTS
00DF09  2               
00DF09  2               ; perform EXP()   (x^e)
00DF09  2               
00DF09  2               LAB_EXP
00DF09  2  A9 FA              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
00DF0B  2  A0 F6              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
00DF0D  2  20 43 DA           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00DF10  2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00DF12  2  69 50              ADC   #$50              ; +$50/$100
00DF14  2  90 03              BCC   LAB_2B2B          ; skip rounding if no carry
00DF16  2               
00DF16  2  20 EB DB           JSR   LAB_27C2          ; round FAC1 (no check)
00DF19  2               LAB_2B2B
00DF19  2  85 A3              STA   FAC2_r            ; save FAC2 rounding byte
00DF1B  2  20 D7 DB           JSR   LAB_27AE          ; copy FAC1 to FAC2
00DF1E  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DF20  2  C9 88              CMP   #$88              ; compare with EXP limit (256d)
00DF22  2  90 03              BCC   LAB_2B39          ; branch if less
00DF24  2               
00DF24  2               LAB_2B36
00DF24  2  20 D8 DA           JSR   LAB_2690          ; handle overflow and underflow
00DF27  2               LAB_2B39
00DF27  2  20 8B DC           JSR   LAB_INT           ; perform INT
00DF2A  2  A5 5B              LDA   Temp3             ; get mantissa 3 from INT() function
00DF2C  2  18                 CLC                     ; clear carry for add
00DF2D  2  69 81              ADC   #$81              ; normalise +1
00DF2F  2  F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
00DF31  2               
00DF31  2  38                 SEC                     ; set carry for subtract
00DF32  2  E9 01              SBC   #$01              ; now correct for exponent
00DF34  2  48                 PHA                     ; save FAC2 exponent
00DF35  2               
00DF35  2                                             ; swap FAC1 and FAC2
00DF35  2  A2 04              LDX   #$04              ; 4 bytes to do
00DF37  2               LAB_2B49
00DF37  2  B5 B3              LDA   FAC2_e,X          ; get FAC2,X
00DF39  2  B4 AC              LDY   FAC1_e,X          ; get FAC1,X
00DF3B  2  95 AC              STA   FAC1_e,X          ; save FAC1,X
00DF3D  2  94 B3              STY   FAC2_e,X          ; save FAC2,X
00DF3F  2  CA                 DEX                     ; decrement count/index
00DF40  2  10 F5              BPL   LAB_2B49          ; loop if not all done
00DF42  2               
00DF42  2  A5 A3              LDA   FAC2_r            ; get FAC2 rounding byte
00DF44  2  85 B9              STA   FAC1_r            ; save as FAC1 rounding byte
00DF46  2  20 B0 D8           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
00DF49  2  20 FE DE           JSR   LAB_GTHAN         ; do - FAC1
00DF4C  2  A9 FE              LDA   #<LAB_2AFE        ; set counter pointer low byte
00DF4E  2  A0 F6              LDY   #>LAB_2AFE        ; set counter pointer high byte
00DF50  2  20 71 DF           JSR   LAB_2B84          ; go do series evaluation
00DF53  2  A9 00              LDA   #$00              ; clear A
00DF55  2  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
00DF57  2  68                 PLA                     ;.get saved FAC2 exponent
00DF58  2  4C BD DA           JMP   LAB_2675          ; test and adjust accumulators and return
00DF5B  2               
00DF5B  2               ; ^2 then series evaluation
00DF5B  2               
00DF5B  2               LAB_2B6E
00DF5B  2  85 BA              STA   Cptrl             ; save count pointer low byte
00DF5D  2  84 BB              STY   Cptrh             ; save count pointer high byte
00DF5F  2  20 A7 DB           JSR   LAB_276E          ; pack FAC1 into Adatal
00DF62  2  A9 A4              LDA   #<Adatal          ; set pointer low byte (Y already $00)
00DF64  2  20 43 DA           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00DF67  2  20 75 DF           JSR   LAB_2B88          ; go do series evaluation
00DF6A  2  A9 A4              LDA   #<Adatal          ; pointer to original # low byte
00DF6C  2  A0 00              LDY   #>Adatal          ; pointer to original # high byte
00DF6E  2  4C 43 DA           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
00DF71  2               
00DF71  2               ; series evaluation
00DF71  2               
00DF71  2               LAB_2B84
00DF71  2  85 BA              STA   Cptrl             ; save count pointer low byte
00DF73  2  84 BB              STY   Cptrh             ; save count pointer high byte
00DF75  2               LAB_2B88
00DF75  2  A2 A8              LDX   #<numexp          ; set pointer low byte
00DF77  2  20 A9 DB           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
00DF7A  2  B1 BA              LDA   (Cptrl),Y         ; get constants count
00DF7C  2  85 B1              STA   numcon            ; save constants count
00DF7E  2  A4 BA              LDY   Cptrl             ; get count pointer low byte
00DF80  2  C8                 INY                     ; increment it (now constants pointer)
00DF81  2  98                 TYA                     ; copy it
00DF82  2  D0 02              BNE   LAB_2B97          ; skip next if no overflow
00DF84  2               
00DF84  2  E6 BB              INC   Cptrh             ; else increment high byte
00DF86  2               LAB_2B97
00DF86  2  85 BA              STA   Cptrl             ; save low byte
00DF88  2  A4 BB              LDY   Cptrh             ; get high byte
00DF8A  2               LAB_2B9B
00DF8A  2  20 43 DA           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00DF8D  2  A5 BA              LDA   Cptrl             ; get constants pointer low byte
00DF8F  2  A4 BB              LDY   Cptrh             ; get constants pointer high byte
00DF91  2  18                 CLC                     ; clear carry for add
00DF92  2  69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
00DF94  2  90 01              BCC   LAB_2BA8          ; skip next if no overflow
00DF96  2               
00DF96  2  C8                 INY                     ; increment high byte
00DF97  2               LAB_2BA8
00DF97  2  85 BA              STA   Cptrl             ; save pointer low byte
00DF99  2  84 BB              STY   Cptrh             ; save pointer high byte
00DF9B  2  20 C8 D8           JSR   LAB_246C          ; add (AY) to FAC1
00DF9E  2  A9 A8              LDA   #<numexp          ; set pointer low byte to partial @ numexp
00DFA0  2  A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
00DFA2  2  C6 B1              DEC   numcon            ; decrement constants count
00DFA4  2  D0 E4              BNE   LAB_2B9B          ; loop until all done
00DFA6  2               
00DFA6  2  60                 RTS
00DFA7  2               
00DFA7  2               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
00DFA7  2               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
00DFA7  2               ; the Galois method and a sample of 65536 bytes produced gives the following values.
00DFA7  2               
00DFA7  2               ; Entropy = 7.997442 bits per byte
00DFA7  2               ; Optimum compression would reduce these 65536 bytes by 0 percent
00DFA7  2               
00DFA7  2               ; Chi square distribution for 65536 samples is 232.01, and
00DFA7  2               ; randomly would exceed this value 75.00 percent of the time
00DFA7  2               
00DFA7  2               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
00DFA7  2               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
00DFA7  2               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
00DFA7  2               
00DFA7  2               LAB_RND
00DFA7  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DFA9  2  F0 07              BEQ   NextPRN           ; do next random # if zero
00DFAB  2               
00DFAB  2                                             ; else get seed into random number store
00DFAB  2  A2 D8              LDX   #Rbyte4           ; set PRNG pointer low byte
00DFAD  2  A0 00              LDY   #$00              ; set PRNG pointer high byte
00DFAF  2  20 B1 DB           JSR   LAB_2778          ; pack FAC1 into (XY)
00DFB2  2               NextPRN
00DFB2  2  A2 AF              LDX   #$AF              ; set EOR byte
00DFB4  2  A0 13              LDY   #$13              ; do this nineteen times
00DFB6  2               LoopPRN
00DFB6  2  06 D9              ASL   Rbyte1            ; shift PRNG most significant byte
00DFB8  2  26 DA              ROL   Rbyte2            ; shift PRNG middle byte
00DFBA  2  26 DB              ROL   Rbyte3            ; shift PRNG least significant byte
00DFBC  2  26 D8              ROL   Rbyte4            ; shift PRNG extra byte
00DFBE  2  90 05              BCC   Ninc1             ; branch if bit 32 clear
00DFC0  2               
00DFC0  2  8A                 TXA                     ; set EOR byte
00DFC1  2  45 D9              EOR   Rbyte1            ; EOR PRNG extra byte
00DFC3  2  85 D9              STA   Rbyte1            ; save new PRNG extra byte
00DFC5  2               Ninc1
00DFC5  2  88                 DEY                     ; decrement loop count
00DFC6  2  D0 EE              BNE   LoopPRN           ; loop if not all done
00DFC8  2               
00DFC8  2  A2 02              LDX   #$02              ; three bytes to copy
00DFCA  2               CopyPRNG
00DFCA  2  B5 D9              LDA   Rbyte1,X          ; get PRNG byte
00DFCC  2  95 AD              STA   FAC1_1,X          ; save FAC1 byte
00DFCE  2  CA                 DEX
00DFCF  2  10 F9              BPL   CopyPRNG          ; loop if not complete
00DFD1  2               
00DFD1  2  A9 80              LDA   #$80              ; set the exponent
00DFD3  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00DFD5  2               
00DFD5  2  0A                 ASL                     ; clear A
00DFD6  2  85 B0              STA   FAC1_s            ; save FAC1 sign
00DFD8  2               
00DFD8  2  4C 3E D9           JMP   LAB_24D5          ; normalise FAC1 and return
00DFDB  2               
00DFDB  2               ; perform COS()
00DFDB  2               
00DFDB  2               LAB_COS
00DFDB  2  A9 1B              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
00DFDD  2  A0 F7              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
00DFDF  2  20 C8 D8           JSR   LAB_246C          ; add (AY) to FAC1
00DFE2  2               
00DFE2  2               ; perform SIN()
00DFE2  2               
00DFE2  2               LAB_SIN
00DFE2  2  20 D4 DB           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00DFE5  2  A9 30              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
00DFE7  2  A0 F7              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
00DFE9  2  A6 B7              LDX   FAC2_s            ; get FAC2 sign (b7)
00DFEB  2  20 03 DB           JSR   LAB_26C2          ; divide by (AY) (X=sign)
00DFEE  2  20 D4 DB           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00DFF1  2  20 8B DC           JSR   LAB_INT           ; perform INT
00DFF4  2  A9 00              LDA   #$00              ; clear byte
00DFF6  2  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
00DFF8  2  20 B0 D8           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
00DFFB  2  A9 62              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
00DFFD  2  A0 F7              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
00DFFF  2  20 AD D8           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
00E002  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00E004  2  48                 PHA                     ; save FAC1 sign
00E005  2  10 0D              BPL   LAB_2C35          ; branch if +ve
00E007  2               
00E007  2                                             ; FAC1 sign was -ve
00E007  2  20 C4 D8           JSR   LAB_244E          ; add 0.5 to FAC1
00E00A  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00E00C  2  30 09              BMI   LAB_2C38          ; branch if -ve
00E00E  2               
00E00E  2  A5 63              LDA   Cflag             ; get comparison evaluation flag
00E010  2  49 FF              EOR   #$FF              ; toggle flag
00E012  2  85 63              STA   Cflag             ; save comparison evaluation flag
00E014  2               LAB_2C35
00E014  2  20 FE DE           JSR   LAB_GTHAN         ; do - FAC1
00E017  2               LAB_2C38
00E017  2  A9 62              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
00E019  2  A0 F7              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
00E01B  2  20 C8 D8           JSR   LAB_246C          ; add (AY) to FAC1
00E01E  2  68                 PLA                     ; restore FAC1 sign
00E01F  2  10 03              BPL   LAB_2C45          ; branch if was +ve
00E021  2               
00E021  2                                             ; else correct FAC1
00E021  2  20 FE DE           JSR   LAB_GTHAN         ; do - FAC1
00E024  2               LAB_2C45
00E024  2  A9 1F              LDA   #<LAB_2C84        ; set pointer low byte to counter
00E026  2  A0 F7              LDY   #>LAB_2C84        ; set pointer high byte to counter
00E028  2  4C 5B DF           JMP   LAB_2B6E          ; ^2 then series evaluation and return
00E02B  2               
00E02B  2               ; perform TAN()
00E02B  2               
00E02B  2               LAB_TAN
00E02B  2  20 A7 DB           JSR   LAB_276E          ; pack FAC1 into Adatal
00E02E  2  A9 00              LDA   #$00              ; clear byte
00E030  2  85 63              STA   Cflag             ; clear comparison evaluation flag
00E032  2  20 E2 DF           JSR   LAB_SIN           ; go do SIN(n)
00E035  2  A2 9C              LDX   #<func_l          ; set sin(n) pointer low byte
00E037  2  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
00E039  2  20 B1 DB           JSR   LAB_2778          ; pack FAC1 into (XY)
00E03C  2  A9 A4              LDA   #<Adatal          ; set n pointer low addr
00E03E  2  A0 00              LDY   #>Adatal          ; set n pointer high addr
00E040  2  20 87 DB           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00E043  2  A9 00              LDA   #$00              ; clear byte
00E045  2  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
00E047  2  A5 63              LDA   Cflag             ; get comparison evaluation flag
00E049  2  20 53 E0           JSR   LAB_2C74          ; save flag and go do series evaluation
00E04C  2               
00E04C  2  A9 9C              LDA   #<func_l          ; set sin(n) pointer low byte
00E04E  2  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
00E050  2  4C 0B DB           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
00E053  2               
00E053  2               LAB_2C74
00E053  2  48                 PHA                     ; save comparison evaluation flag
00E054  2  4C 14 E0           JMP   LAB_2C35          ; go do series evaluation
00E057  2               
00E057  2               ; perform USR()
00E057  2               
00E057  2               LAB_USR
00E057  2  20 0A 00           JSR   Usrjmp            ; call user code
00E05A  2  4C 3E CD           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
00E05D  2               
00E05D  2               ; perform ATN()
00E05D  2               
00E05D  2               LAB_ATN
00E05D  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00E05F  2  48                 PHA                     ; save sign
00E060  2  10 03              BPL   LAB_2CA1          ; branch if +ve
00E062  2               
00E062  2  20 FE DE           JSR   LAB_GTHAN         ; else do - FAC1
00E065  2               LAB_2CA1
00E065  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00E067  2  48                 PHA                     ; push exponent
00E068  2  C9 81              CMP   #$81              ; compare with 1
00E06A  2  90 07              BCC   LAB_2CAF          ; branch if FAC1<1
00E06C  2               
00E06C  2  A9 55              LDA   #<LAB_259C        ; set 1 pointer low byte
00E06E  2  A0 F7              LDY   #>LAB_259C        ; set 1 pointer high byte
00E070  2  20 0B DB           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
00E073  2               LAB_2CAF
00E073  2  A9 34              LDA   #<LAB_2CC9        ; set pointer low byte to counter
00E075  2  A0 F7              LDY   #>LAB_2CC9        ; set pointer high byte to counter
00E077  2  20 5B DF           JSR   LAB_2B6E          ; ^2 then series evaluation
00E07A  2  68                 PLA                     ; restore old FAC1 exponent
00E07B  2  C9 81              CMP   #$81              ; compare with 1
00E07D  2  90 07              BCC   LAB_2CC2          ; branch if FAC1<1
00E07F  2               
00E07F  2  A9 1B              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
00E081  2  A0 F7              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
00E083  2  20 AD D8           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
00E086  2               LAB_2CC2
00E086  2  68                 PLA                     ; restore FAC1 sign
00E087  2  10 0D              BPL   LAB_2D04          ; exit if was +ve
00E089  2               
00E089  2  4C FE DE           JMP   LAB_GTHAN         ; else do - FAC1 and return
00E08C  2               
00E08C  2               ; perform BITSET addr, mask — set bits: mem[addr] = mem[addr] OR mask
00E08C  2               
00E08C  2               LAB_BITSET
00E08C  2  20 D4 D7           JSR   LAB_GADB          ; addr in Itempl/h, mask in X
00E08F  2  A0 00              LDY   #$00
00E091  2  8A                 TXA                     ; A = mask
00E092  2  11 11              ORA   (Itempl),Y        ; OR with byte at addr
00E094  2  91 11              STA   (Itempl),Y        ; store result
00E096  2               LAB_2D04
00E096  2  60                 RTS
00E097  2               
00E097  2               ; perform BITCLR addr, mask — clear bits: mem[addr] = mem[addr] AND NOT mask
00E097  2               
00E097  2               LAB_BITCLR
00E097  2  20 D4 D7           JSR   LAB_GADB          ; addr in Itempl/h, mask in X
00E09A  2  A0 00              LDY   #$00
00E09C  2  8A                 TXA                     ; A = mask
00E09D  2  49 FF              EOR   #$FF              ; invert mask
00E09F  2  31 11              AND   (Itempl),Y        ; AND with byte at addr
00E0A1  2  91 11              STA   (Itempl),Y        ; store result
00E0A3  2  60                 RTS
00E0A4  2               
00E0A4  2               ; perform BITTGL addr, mask — toggle bits: mem[addr] = mem[addr] EOR mask
00E0A4  2               
00E0A4  2               LAB_BITTGL
00E0A4  2  20 D4 D7           JSR   LAB_GADB          ; addr in Itempl/h, mask in X
00E0A7  2  A0 00              LDY   #$00
00E0A9  2  8A                 TXA                     ; A = mask
00E0AA  2  51 11              EOR   (Itempl),Y        ; EOR with byte at addr
00E0AC  2  91 11              STA   (Itempl),Y        ; store result
00E0AE  2  60                 RTS
00E0AF  2               
00E0AF  2               ;; ========================================
00E0AF  2               ;; HELP [keyword$]
00E0AF  2               ;; Opens the help panel, optionally searching for a keyword
00E0AF  2               ;; ========================================
00E0AF  2               LAB_HELP
00E0AF  2  20 C2 00           JSR   LAB_GBYT          ; peek at next byte (don't consume)
00E0B2  2  D0 03              BNE   @has_arg           ; not end of statement, check what it is
00E0B4  2  4C A0 E1           JMP   @no_arg            ; end of statement -> open general help
00E0B7  2               
00E0B7  2               @has_arg
00E0B7  2  C9 22              CMP   #'"'              ; quoted string?
00E0B9  2  D0 03              BNE   @not_quote
00E0BB  2  4C 70 E1           JMP   @string_arg        ; handle with expression evaluator
00E0BE  2               
00E0BE  2               @not_quote
00E0BE  2  C9 01              CMP   #TKX_PREFIX       ; extended token prefix?
00E0C0  2  F0 73              BEQ   @ext_token
00E0C2  2               
00E0C2  2  C9 80              CMP   #$80              ; primary token? (bit 7 set)
00E0C4  2  B0 22              BCS   @pri_token
00E0C6  2               
00E0C6  2                     ; --- Raw ASCII text: copy until end of statement ---
00E0C6  2  A0 00              LDY   #$00              ; buffer index
00E0C8  2               @raw_loop
00E0C8  2  B1 C3              LDA   (Bpntrl),Y        ; read from BASIC text (don't consume yet)
00E0CA  2  F0 0C              BEQ   @raw_done          ; end of line
00E0CC  2  C9 3A              CMP   #':'              ; end of statement
00E0CE  2  F0 08              BEQ   @raw_done
00E0D0  2  99 21 A0           STA   $A021,Y           ; store in help buffer
00E0D3  2  C8                 INY
00E0D4  2  C0 10              CPY   #$10              ; max 16 chars
00E0D6  2  90 F0              BCC   @raw_loop
00E0D8  2               @raw_done
00E0D8  2  8C A6 E1           STY   @help_len          ; save how many we wrote
00E0DB  2                     ; advance BASIC pointer past the chars we consumed
00E0DB  2  98                 TYA
00E0DC  2  18                 CLC
00E0DD  2  65 C3              ADC   Bpntrl
00E0DF  2  85 C3              STA   Bpntrl
00E0E1  2  90 02              BCC   @raw_noinc
00E0E3  2  E6 C4              INC   Bpntrh
00E0E5  2               @raw_noinc
00E0E5  2  4C 8B E1           JMP   @zero_and_trigger
00E0E8  2               
00E0E8  2                     ; --- Primary token: detokenize via LAB_KEYT table ---
00E0E8  2               @pri_token
00E0E8  2  20 BC 00           JSR   LAB_IGBY          ; consume the token byte, A = token
00E0EB  2                     ; use LAB_KEYT lookup (same method as LIST decoder)
00E0EB  2  A2 FB              LDX   #>LAB_KEYT        ; table high byte
00E0ED  2  0A                 ASL                     ; *2 (shifts out bit 7 into carry)
00E0EE  2  0A                 ASL                     ; *4
00E0EF  2  90 02              BCC   @pk_nc1
00E0F1  2  E8                 INX                     ; carry into high byte
00E0F2  2  18                 CLC
00E0F3  2               @pk_nc1
00E0F3  2  69 62              ADC   #<LAB_KEYT        ; add table base low byte
00E0F5  2  90 01              BCC   @pk_nc2
00E0F7  2  E8                 INX
00E0F8  2               @pk_nc2
00E0F8  2  85 73              STA   ut2_pl            ; pointer to 4-byte entry
00E0FA  2  86 74              STX   ut2_ph
00E0FC  2  A0 00              LDY   #$00
00E0FE  2  B1 73              LDA   (ut2_pl),Y        ; byte 0 = keyword length
00E100  2  8D A6 E1           STA   @help_len          ; total chars to copy
00E103  2  C8                 INY
00E104  2  B1 73              LDA   (ut2_pl),Y        ; byte 1 = first character
00E106  2  8D 21 A0           STA   $A021             ; store first char in buffer
00E109  2  C8                 INY
00E10A  2  B1 73              LDA   (ut2_pl),Y        ; byte 2 = rest-of-keyword pointer low
00E10C  2  48                 PHA
00E10D  2  C8                 INY
00E10E  2  B1 73              LDA   (ut2_pl),Y        ; byte 3 = rest-of-keyword pointer high
00E110  2  85 74              STA   ut2_ph
00E112  2  68                 PLA
00E113  2  85 73              STA   ut2_pl            ; ut2 now points to remaining chars
00E115  2               
00E115  2  AE A6 E1           LDX   @help_len          ; total keyword length
00E118  2  CA                 DEX                     ; remaining chars = length - 1
00E119  2  A0 00              LDY   #$00              ; index into remaining chars
00E11B  2  A2 01              LDX   #$01              ; buffer write index (char 0 already written)
00E11D  2               @pk_copy
00E11D  2  EC A6 E1           CPX   @help_len
00E120  2  B0 0D              BCS   @pk_done           ; copied all chars
00E122  2  B1 73              LDA   (ut2_pl),Y        ; get next keyword char
00E124  2  29 7F              AND   #$7F              ; clear bit 7 (last char in cruncher table has it set)
00E126  2  9D 21 A0           STA   $A021,X
00E129  2  C8                 INY
00E12A  2  E8                 INX
00E12B  2  E0 10              CPX   #$10              ; buffer max
00E12D  2  90 EE              BCC   @pk_copy
00E12F  2               @pk_done
00E12F  2  8E A6 E1           STX   @help_len          ; actual chars written
00E132  2  4C 8B E1           JMP   @zero_and_trigger
00E135  2               
00E135  2                     ; --- Extended token: look up in TAB_XTKSTR ---
00E135  2               @ext_token
00E135  2  20 BC 00           JSR   LAB_IGBY          ; consume prefix byte ($01)
00E138  2  A0 00              LDY   #$00
00E13A  2  B1 C3              LDA   (Bpntrl),Y        ; read raw extension id
00E13C  2  48                 PHA                     ; save it
00E13D  2  20 BC 00           JSR   LAB_IGBY          ; consume extension id byte
00E140  2  68                 PLA                     ; restore extension id
00E141  2  C9 01              CMP   #$01
00E143  2  90 5B              BCC   @no_arg            ; invalid, treat as no arg
00E145  2  C9 47              CMP   #XTK_COUNT+1
00E147  2  B0 57              BCS   @no_arg            ; out of range
00E149  2  38                 SEC
00E14A  2  E9 01              SBC   #$01              ; 0-based index
00E14C  2  0A                 ASL                     ; *2 for word pointer
00E14D  2  AA                 TAX
00E14E  2  BD E7 E4           LDA   TAB_XTKSTR,X      ; string pointer low
00E151  2  85 73              STA   ut2_pl
00E153  2  BD E8 E4           LDA   TAB_XTKSTR+1,X    ; string pointer high
00E156  2  85 74              STA   ut2_ph
00E158  2  A0 00              LDY   #$00
00E15A  2               @xt_copy
00E15A  2  B1 73              LDA   (ut2_pl),Y        ; get char from null-terminated string
00E15C  2  F0 0C              BEQ   @xt_done           ; null terminator
00E15E  2  C9 28              CMP   #'('              ; strip trailing '(' from function tokens like XPEEK(
00E160  2  F0 08              BEQ   @xt_done
00E162  2  99 21 A0           STA   $A021,Y
00E165  2  C8                 INY
00E166  2  C0 10              CPY   #$10              ; buffer max
00E168  2  90 F0              BCC   @xt_copy
00E16A  2               @xt_done
00E16A  2  8C A6 E1           STY   @help_len
00E16D  2  4C 8B E1           JMP   @zero_and_trigger
00E170  2               
00E170  2                     ; --- Quoted string: use expression evaluator ---
00E170  2               @string_arg
00E170  2  20 29 CC           JSR   LAB_EVEX          ; evaluate expression
00E173  2  20 2C D6           JSR   LAB_EVST          ; pop string: A=length, ut1_pl/ph=pointer
00E176  2  A8                 TAY                     ; Y = length
00E177  2  C0 10              CPY   #$10
00E179  2  90 02              BCC   @sl_ok
00E17B  2  A0 10              LDY   #$10              ; clamp to 16
00E17D  2               @sl_ok
00E17D  2  8C A6 E1           STY   @help_len
00E180  2  88                 DEY
00E181  2               @sl_copy
00E181  2  30 08              BMI   @sl_done
00E183  2  B1 71              LDA   (ut1_pl),Y
00E185  2  99 21 A0           STA   $A021,Y
00E188  2  88                 DEY
00E189  2  10 F6              BPL   @sl_copy
00E18B  2               @sl_done
00E18B  2                     ; fall through to zero_and_trigger
00E18B  2               
00E18B  2                     ; --- Zero-fill remainder and trigger search ---
00E18B  2               @zero_and_trigger
00E18B  2  AC A6 E1           LDY   @help_len
00E18E  2               @zero_loop
00E18E  2  C0 10              CPY   #$10
00E190  2  B0 08              BCS   @trigger_search
00E192  2  A9 00              LDA   #$00
00E194  2  99 21 A0           STA   $A021,Y
00E197  2  C8                 INY
00E198  2  D0 F4              BNE   @zero_loop
00E19A  2               @trigger_search
00E19A  2  A9 02              LDA   #$02              ; command: search
00E19C  2  8D 20 A0           STA   $A020             ; RegHelp
00E19F  2  60                 RTS
00E1A0  2               
00E1A0  2               @no_arg
00E1A0  2  A9 01              LDA   #$01              ; command: open
00E1A2  2  8D 20 A0           STA   $A020             ; RegHelp
00E1A5  2  60                 RTS
00E1A6  2               
00E1A6  2               @help_len
00E1A6  2  00                 .byte $00
00E1A7  2               
00E1A7  2               ; perform BITTST(addr, mask) — returns -1 if ALL masked bits set, else 0
00E1A7  2               
00E1A7  2               LAB_BTST
00E1A7  2  20 BC 00           JSR   LAB_IGBY          ; increment BASIC pointer
00E1AA  2  20 D4 D7           JSR   LAB_GADB          ; addr in Itempl/h, mask in X
00E1AD  2               
00E1AD  2  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
00E1B0  2  C9 29              CMP   #')'              ; is next character ")"
00E1B2  2  F0 03              BEQ   TST_OK            ; if ")" go do rest of function
00E1B4  2               
00E1B4  2  4C 51 CD           JMP   LAB_SNER          ; do syntax error then warm start
00E1B7  2               
00E1B7  2               TST_OK
00E1B7  2  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (past ")")
00E1BA  2  A0 00              LDY   #$00
00E1BC  2  8A                 TXA                     ; A = mask
00E1BD  2  31 11              AND   (Itempl),Y        ; AND with byte at addr
00E1BF  2  85 11              STA   Itempl            ; save result
00E1C1  2  E4 11              CPX   Itempl            ; compare with original mask (still in X)
00E1C3  2  D0 05              BNE   LAB_NOTT          ; not all bits set — return 0
00E1C5  2               
00E1C5  2  A9 FF              LDA   #$FF              ; all masked bits set — return -1
00E1C7  2  4C 04 DC           JMP   LAB_27DB          ; go do SGN tail
00E1CA  2               
00E1CA  2               LAB_NOTT
00E1CA  2  A9 00              LDA   #$00              ; return 0
00E1CC  2  4C 04 DC           JMP   LAB_27DB          ; go do SGN tail
00E1CF  2               
00E1CF  2               ; perform BIN$()
00E1CF  2               
00E1CF  2               LAB_BINS
00E1CF  2  E0 19              CPX   #$19              ; max + 1
00E1D1  2  B0 48              BCS   BinFErr           ; exit if too big ( > or = )
00E1D3  2               
00E1D3  2  86 78              STX   TempB             ; save # of characters ($00 = leading zero remove)
00E1D5  2  A9 18              LDA   #$18              ; need A byte long space
00E1D7  2  20 25 D4           JSR   LAB_MSSP          ; make string space A bytes long
00E1DA  2  A0 17              LDY   #$17              ; set index
00E1DC  2  A2 18              LDX   #$18              ; character count
00E1DE  2               NextB1
00E1DE  2  46 11              LSR   nums_1            ; shift highest byte
00E1E0  2  66 12              ROR   nums_2            ; shift middle byte
00E1E2  2  66 13              ROR   nums_3            ; shift lowest byte bit 0 to carry
00E1E4  2  8A                 TXA                     ; load with "0"/2
00E1E5  2  2A                 ROL                     ; shift in carry
00E1E6  2  91 AD              STA   (str_pl),Y        ; save to temp string + index
00E1E8  2  88                 DEY                     ; decrement index
00E1E9  2  10 F3              BPL   NextB1            ; loop if not done
00E1EB  2               
00E1EB  2  A5 78              LDA   TempB             ; get # of characters
00E1ED  2  F0 0A              BEQ   EndBHS            ; branch if truncate
00E1EF  2               
00E1EF  2  AA                 TAX                     ; copy length to X
00E1F0  2  38                 SEC                     ; set carry for add !
00E1F1  2  49 FF              EOR   #$FF              ; 1's complement
00E1F3  2  69 18              ADC   #$18              ; add 24d
00E1F5  2  F0 1C              BEQ   GoPr2             ; if zero print whole string
00E1F7  2               
00E1F7  2  D0 0F              BNE   GoPr1             ; else go make output string
00E1F9  2               
00E1F9  2               ; this is the exit code and is also used by HEX$()
00E1F9  2               ; truncate string to remove leading "0"s
00E1F9  2               
00E1F9  2               EndBHS
00E1F9  2  A8                 TAY                     ; clear index (A=0, X=length here)
00E1FA  2               NextB2
00E1FA  2  B1 AD              LDA   (str_pl),Y        ; get character from string
00E1FC  2  C9 30              CMP   #'0'              ; compare with "0"
00E1FE  2  D0 07              BNE   GoPr              ; if not "0" then go print string from here
00E200  2               
00E200  2  CA                 DEX                     ; decrement character count
00E201  2  F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
00E203  2               
00E203  2  C8                 INY                     ; else increment index
00E204  2  10 F4              BPL   NextB2            ; loop always
00E206  2               
00E206  2               ; make fixed length output string - ignore overflows!
00E206  2               
00E206  2               GoPr3
00E206  2  E8                 INX                     ; need at least 1 character
00E207  2               GoPr
00E207  2  98                 TYA                     ; copy result
00E208  2               GoPr1
00E208  2  18                 CLC                     ; clear carry for add
00E209  2  65 AD              ADC   str_pl            ; add low address
00E20B  2  85 AD              STA   str_pl            ; save low address
00E20D  2  A9 00              LDA   #$00              ; do high byte
00E20F  2  65 AE              ADC   str_ph            ; add high address
00E211  2  85 AE              STA   str_ph            ; save high address
00E213  2               GoPr2
00E213  2  86 AC              STX   str_ln            ; X holds string length
00E215  2  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
00E218  2  4C 72 D4           JMP   LAB_RTST          ; check for space on descriptor stack then put address
00E21B  2                                             ; and length on descriptor stack and update stack pointers
00E21B  2               
00E21B  2               BinFErr
00E21B  2  4C 14 D2           JMP   LAB_FCER          ; do function call error then warm start
00E21E  2               
00E21E  2               ; perform HEX$()
00E21E  2               
00E21E  2               LAB_HEXS
00E21E  2  E0 07              CPX   #$07              ; max + 1
00E220  2  B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
00E222  2               
00E222  2  86 78              STX   TempB             ; save # of characters
00E224  2               
00E224  2  A9 06              LDA   #$06              ; need 6 bytes for string
00E226  2  20 25 D4           JSR   LAB_MSSP          ; make string space A bytes long
00E229  2  A0 05              LDY   #$05              ; set string index
00E22B  2               
00E22B  2               ; *** disable decimal mode patch - comment next line ***
00E22B  2               ;      SED                     ; need decimal mode for nibble convert
00E22B  2  A5 13              LDA   nums_3            ; get lowest byte
00E22D  2  20 4A E2           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
00E230  2  A5 12              LDA   nums_2            ; get middle byte
00E232  2  20 4A E2           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
00E235  2  A5 11              LDA   nums_1            ; get highest byte
00E237  2  20 4A E2           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
00E23A  2               ; *** disable decimal mode patch - comment next line ***
00E23A  2               ;      CLD                     ; back to binary
00E23A  2               
00E23A  2  A2 06              LDX   #$06              ; character count
00E23C  2  A5 78              LDA   TempB             ; get # of characters
00E23E  2  F0 B9              BEQ   EndBHS            ; branch if truncate
00E240  2               
00E240  2  AA                 TAX                     ; copy length to X
00E241  2  38                 SEC                     ; set carry for add !
00E242  2  49 FF              EOR   #$FF              ; 1's complement
00E244  2  69 06              ADC   #$06              ; add 6d
00E246  2  F0 CB              BEQ   GoPr2             ; if zero print whole string
00E248  2               
00E248  2  D0 BE              BNE   GoPr1             ; else go make output string (branch always)
00E24A  2               
00E24A  2               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
00E24A  2               
00E24A  2               LAB_A2HX
00E24A  2  AA                 TAX                     ; save byte
00E24B  2  29 0F              AND   #$0F              ; mask off top bits
00E24D  2  20 55 E2           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
00E250  2  8A                 TXA                     ; get byte back
00E251  2  4A                 LSR                     ; /2  shift high nibble to low nibble
00E252  2  4A                 LSR                     ; /4
00E253  2  4A                 LSR                     ; /8
00E254  2  4A                 LSR                     ; /16
00E255  2               LAB_AL2X
00E255  2  C9 0A              CMP   #$0A              ; set carry for +1 if >9
00E257  2               ; *** begin disable decimal mode patch ***
00E257  2               ; *** insert
00E257  2  90 02              BCC   LAB_AL20          ; skip adjust if <= 9
00E259  2  69 06              ADC   #$06              ; adjust for A to F
00E25B  2               LAB_AL20
00E25B  2               ; *** end   disable decimal mode patch ***
00E25B  2  69 30              ADC   #'0'              ; add ASCII "0"
00E25D  2  91 AD              STA   (str_pl),Y        ; save to temp string
00E25F  2  88                 DEY                     ; decrement counter
00E260  2  60                 RTS
00E261  2               
00E261  2               LAB_NLTO
00E261  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00E263  2  A9 00              LDA   #$00              ; clear sign compare
00E265  2               LAB_MLTE
00E265  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00E267  2  8A                 TXA                     ; restore character
00E268  2  20 4F DD           JSR   LAB_2912          ; evaluate new ASCII digit
00E26B  2               
00E26B  2               ; gets here if the first character was "$" for hex
00E26B  2               ; get hex number
00E26B  2               
00E26B  2               LAB_CHEX
00E26B  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00E26E  2  90 0A              BCC   LAB_ISHN          ; branch if numeric character
00E270  2               
00E270  2  09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
00E272  2  E9 61              SBC   #'a'              ; subtract "a" (carry set here)
00E274  2  C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
00E276  2  B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
00E278  2               
00E278  2  69 0A              ADC   #$0A              ; convert to nibble
00E27A  2               LAB_ISHN
00E27A  2  29 0F              AND   #$0F              ; convert to binary
00E27C  2  AA                 TAX                     ; save nibble
00E27D  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00E27F  2  F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
00E281  2               
00E281  2  69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
00E283  2  90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
00E285  2               
00E285  2               LAB_MLTO
00E285  2  4C CD D9           JMP   LAB_2564          ; do overflow error and warm start
00E288  2               
00E288  2               LAB_NXCH
00E288  2  AA                 TAX                     ; save bit
00E289  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00E28B  2  F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
00E28D  2               
00E28D  2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*2)
00E28F  2  F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
00E291  2               
00E291  2  A9 00              LDA   #$00              ; clear sign compare
00E293  2               LAB_MLBT
00E293  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00E295  2  8A                 TXA                     ; restore bit
00E296  2  20 4F DD           JSR   LAB_2912          ; evaluate new ASCII digit
00E299  2               
00E299  2               ; gets here if the first character was  "%" for binary
00E299  2               ; get binary number
00E299  2               
00E299  2               LAB_CBIN
00E299  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00E29C  2  49 30              EOR   #'0'              ; convert "0" to 0 etc.
00E29E  2  C9 02              CMP   #$02              ; compare with max+1
00E2A0  2  90 E6              BCC   LAB_NXCH          ; branch exit if < 2
00E2A2  2               
00E2A2  2               LAB_EXCH
00E2A2  2  4C 34 DD           JMP   LAB_28F6          ; evaluate -ve flag and return
00E2A5  2               
00E2A5  2               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
00E2A5  2               ; now also the code that checks to see if an interrupt has occurred
00E2A5  2               
00E2A5  2               CTRLC
00E2A5  2  AD 00 02           LDA   ccflag            ; get [CTRL-C] check flag
00E2A8  2  D0 18              BNE   LAB_FBA2          ; exit if inhibited
00E2AA  2               
00E2AA  2  20 B3 E6           JSR   V_INPT            ; scan input device
00E2AD  2  90 0B              BCC   LAB_FBA0          ; exit if buffer empty
00E2AF  2               
00E2AF  2  8D 01 02           STA   ccbyte            ; save received byte
00E2B2  2  A2 20              LDX   #$20              ; "life" timer for bytes
00E2B4  2  8E 02 02           STX   ccnull            ; set countdown
00E2B7  2  4C 71 C6           JMP   LAB_1636          ; return to BASIC
00E2BA  2               
00E2BA  2               LAB_FBA0
00E2BA  2  AE 02 02           LDX   ccnull            ; get countdown byte
00E2BD  2  F0 03              BEQ   LAB_FBA2          ; exit if finished
00E2BF  2               
00E2BF  2  CE 02 02           DEC   ccnull            ; else decrement countdown
00E2C2  2               LAB_FBA2
00E2C2  2  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
00E2C4  2  20 CD E2           JSR   LAB_CKIN          ; go check interrupt
00E2C7  2  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
00E2C9  2  20 CD E2           JSR   LAB_CKIN          ; go check interrupt
00E2CC  2               LAB_CRTS
00E2CC  2  60                 RTS
00E2CD  2               
00E2CD  2               ; check whichever interrupt is indexed by X
00E2CD  2               
00E2CD  2               LAB_CKIN
00E2CD  2  B5 00              LDA   PLUS_0,X          ; get interrupt flag byte
00E2CF  2  10 FB              BPL   LAB_CRTS          ; branch if interrupt not enabled
00E2D1  2               
00E2D1  2               ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
00E2D1  2               ; automatically enable the interrupt when we exit
00E2D1  2               
00E2D1  2  0A                 ASL                     ; move happened bit to setup bit
00E2D2  2  29 40              AND   #$40              ; mask happened bits
00E2D4  2  F0 F6              BEQ   LAB_CRTS          ; if no interrupt then exit
00E2D6  2               
00E2D6  2  95 00              STA   PLUS_0,X          ; save interrupt flag byte
00E2D8  2               
00E2D8  2  8A                 TXA                     ; copy index ..
00E2D9  2  A8                 TAY                     ; .. to Y
00E2DA  2               
00E2DA  2  68                 PLA                     ; dump return address low byte, call from CTRL-C
00E2DB  2  68                 PLA                     ; dump return address high byte
00E2DC  2               
00E2DC  2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
00E2DE  2  20 0D C1           JSR   LAB_1212          ; check room on stack for A bytes
00E2E1  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00E2E3  2  48                 PHA                     ; push on stack
00E2E4  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00E2E6  2  48                 PHA                     ; push on stack
00E2E7  2  A5 88              LDA   Clineh            ; get current line high byte
00E2E9  2  48                 PHA                     ; push on stack
00E2EA  2  A5 87              LDA   Clinel            ; get current line low byte
00E2EC  2  48                 PHA                     ; push on stack
00E2ED  2  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
00E2EF  2  48                 PHA                     ; push on stack
00E2F0  2               
00E2F0  2  B9 01 00           LDA   PLUS_1,Y          ; get interrupt code pointer low byte
00E2F3  2  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
00E2F5  2  B9 02 00           LDA   PLUS_2,Y          ; get interrupt code pointer high byte
00E2F8  2  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
00E2FA  2               
00E2FA  2  4C 60 C5           JMP   LAB_15C2          ; go do interpreter inner loop
00E2FD  2                                             ; can't RTS, we used the stack! the RTS from the ctrl-c
00E2FD  2                                             ; check will be taken when the RETIRQ/RETNMI/RETURN is
00E2FD  2                                             ; executed at the end of the subroutine
00E2FD  2               
00E2FD  2               ; get byte from input device, no waiting
00E2FD  2               ; returns with carry set if byte in A
00E2FD  2               
00E2FD  2               INGET
00E2FD  2  20 B3 E6           JSR   V_INPT            ; call scan input device
00E300  2  B0 09              BCS   LAB_FB95          ; if byte go reset timer
00E302  2               
00E302  2  AD 02 02           LDA   ccnull            ; get countdown
00E305  2  F0 09              BEQ   LAB_FB96          ; exit if empty
00E307  2               
00E307  2  AD 01 02           LDA   ccbyte            ; get last received byte
00E30A  2  38                 SEC                     ; flag we got a byte
00E30B  2               LAB_FB95
00E30B  2  A2 00              LDX   #$00              ; clear X
00E30D  2  8E 02 02           STX   ccnull            ; clear timer because we got a byte
00E310  2               LAB_FB96
00E310  2  60                 RTS
00E311  2               
00E311  2               ; these routines only enable the interrupts if the set-up flag is set
00E311  2               ; if not they have no effect
00E311  2               
00E311  2               ; perform IRQ {ON|OFF|CLEAR}
00E311  2               
00E311  2               LAB_IRQ
00E311  2  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
00E313  2  2C                 .byte $2C               ; make next line BIT abs.
00E314  2               
00E314  2               ; perform NMI {ON|OFF|CLEAR}
00E314  2               
00E314  2               LAB_NMI
00E314  2  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
00E316  2  C9 93              CMP   #TK_ON            ; compare with token for ON
00E318  2  F0 11              BEQ   LAB_INON          ; go turn on interrupt
00E31A  2               
00E31A  2  C9 CB              CMP   #TK_OFF           ; compare with token for OFF
00E31C  2  F0 07              BEQ   LAB_IOFF          ; go turn off interrupt
00E31E  2               
00E31E  2  49 A2              EOR   #TK_CLEAR         ; compare with token for CLEAR, A = $00 if = TK_CLEAR
00E320  2  F0 0E              BEQ   LAB_INEX          ; go clear interrupt flags and return
00E322  2               
00E322  2  4C 51 CD           JMP   LAB_SNER          ; do syntax error then warm start
00E325  2               
00E325  2               LAB_IOFF
00E325  2  A9 7F              LDA   #$7F              ; clear A
00E327  2  35 00              AND   PLUS_0,X          ; AND with interrupt setup flag
00E329  2  10 05              BPL   LAB_INEX          ; go clear interrupt enabled flag and return
00E32B  2               
00E32B  2               LAB_INON
00E32B  2  B5 00              LDA   PLUS_0,X          ; get interrupt setup flag
00E32D  2  0A                 ASL                     ; Shift bit to enabled flag
00E32E  2  15 00              ORA   PLUS_0,X          ; OR with flag byte
00E330  2               LAB_INEX
00E330  2  95 00              STA   PLUS_0,X          ; save interrupt flag byte
00E332  2  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer and return
00E335  2               
00E335  2               ; these routines set up the pointers and flags for the interrupt routines
00E335  2               ; note that the interrupts are also enabled by these commands
00E335  2               
00E335  2               ; perform ON IRQ
00E335  2               
00E335  2               LAB_SIRQ
00E335  2  58                 CLI                     ; enable interrupts
00E336  2  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
00E338  2  2C                 .byte $2C               ; make next line BIT abs.
00E339  2               
00E339  2               ; perform ON NMI
00E339  2               
00E339  2               LAB_SNMI
00E339  2  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
00E33B  2               
00E33B  2  86 78              STX   TempB             ; save interrupt pointer
00E33D  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (past token)
00E340  2  20 AC C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00E343  2  A5 79              LDA   Smeml             ; get start of mem low byte
00E345  2  A6 7A              LDX   Smemh             ; get start of mem high byte
00E347  2  20 8E C3           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
00E34A  2  B0 03              BCS   LAB_LFND          ; if carry set go set-up interrupt
00E34C  2               
00E34C  2  4C C6 C7           JMP   LAB_16F7          ; else go do "Undefined statement" error and warm start
00E34F  2               
00E34F  2               LAB_LFND
00E34F  2  A6 78              LDX   TempB             ; get interrupt pointer
00E351  2  A5 AA              LDA   Baslnl            ; get pointer low byte
00E353  2  E9 01              SBC   #$01              ; -1 (carry already set for subtract)
00E355  2  95 01              STA   PLUS_1,X          ; save as interrupt pointer low byte
00E357  2  A5 AB              LDA   Baslnh            ; get pointer high byte
00E359  2  E9 00              SBC   #$00              ; subtract carry
00E35B  2  95 02              STA   PLUS_2,X          ; save as interrupt pointer high byte
00E35D  2               
00E35D  2  A9 C0              LDA   #$C0              ; set interrupt enabled/setup bits
00E35F  2  95 00              STA   PLUS_0,X          ; set interrupt flags
00E361  2               LAB_IRTS
00E361  2  60                 RTS
00E362  2               
00E362  2               ; return from IRQ service, restores the enabled flag.
00E362  2               
00E362  2               ; perform RETIRQ
00E362  2               
00E362  2               LAB_RETIRQ
00E362  2  D0 FD              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
00E364  2               
00E364  2  A5 DF              LDA   IrqBase           ; get interrupt flags
00E366  2  0A                 ASL                     ; copy setup to enabled (b7)
00E367  2  05 DF              ORA   IrqBase           ; OR in setup flag
00E369  2  85 DF              STA   IrqBase           ; save enabled flag
00E36B  2  4C CD C7           JMP   LAB_16E8          ; go do rest of RETURN
00E36E  2               
00E36E  2               ; return from NMI service, restores the enabled flag.
00E36E  2               
00E36E  2               ; perform RETNMI
00E36E  2               
00E36E  2               LAB_RETNMI
00E36E  2  D0 F1              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
00E370  2               
00E370  2  A5 DC              LDA   NmiBase           ; get set-up flag
00E372  2  0A                 ASL                     ; copy setup to enabled (b7)
00E373  2  05 DC              ORA   NmiBase           ; OR in setup flag
00E375  2  85 DC              STA   NmiBase           ; save enabled flag
00E377  2  4C CD C7           JMP   LAB_16E8          ; go do rest of RETURN
00E37A  2               
00E37A  2               ; MAX() MIN() pre process
00E37A  2               
00E37A  2               LAB_MMPP
00E37A  2  20 31 CC           JSR   LAB_EVEZ          ; process expression
00E37D  2  4C 18 CC           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
00E380  2               
00E380  2               ; perform MAX()
00E380  2               
00E380  2               LAB_MAX
00E380  2  20 AE E3           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
00E383  2                                             ; pull FAC2 and compare with FAC1
00E383  2  10 FB              BPL   LAB_MAX           ; branch if no swap to do
00E385  2               
00E385  2  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
00E387  2  09 80              ORA   #$80              ; set top bit (clear sign from compare)
00E389  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00E38B  2  20 CD D8           JSR   LAB_279B          ; copy FAC2 to FAC1
00E38E  2  F0 F0              BEQ   LAB_MAX           ; go do next (branch always)
00E390  2               
00E390  2               ; perform MIN()
00E390  2               
00E390  2               LAB_MIN
00E390  2  20 AE E3           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
00E393  2                                             ; pull FAC2 and compare with FAC1
00E393  2  30 FB              BMI   LAB_MIN           ; branch if no swap to do
00E395  2               
00E395  2  F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
00E397  2               
00E397  2  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
00E399  2  09 80              ORA   #$80              ; set top bit (clear sign from compare)
00E39B  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00E39D  2  20 CD D8           JSR   LAB_279B          ; copy FAC2 to FAC1
00E3A0  2  F0 EE              BEQ   LAB_MIN           ; go do next (branch always)
00E3A2  2               
00E3A2  2               ; exit routine. don't bother returning to the loop code
00E3A2  2               ; check for correct exit, else so syntax error
00E3A2  2               
00E3A2  2               LAB_MMEC
00E3A2  2  C9 29              CMP   #')'              ; is it end of function?
00E3A4  2  D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
00E3A6  2               
00E3A6  2  68                 PLA                     ; dump return address low byte
00E3A7  2  68                 PLA                     ; dump return address high byte
00E3A8  2  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
00E3AB  2               
00E3AB  2               LAB_MMSE
00E3AB  2  4C 51 CD           JMP   LAB_SNER          ; do syntax error then warm start
00E3AE  2               
00E3AE  2               ; check for next, evaluate and return or exit
00E3AE  2               ; this is the routine that does most of the work
00E3AE  2               
00E3AE  2               LAB_PHFA
00E3AE  2  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
00E3B1  2  C9 2C              CMP   #','              ; is there more ?
00E3B3  2  D0 ED              BNE   LAB_MMEC          ; if not go do end check
00E3B5  2               
00E3B5  2                                             ; push FAC1
00E3B5  2  20 E3 DB           JSR   LAB_27BA          ; round FAC1
00E3B8  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign
00E3BA  2  09 7F              ORA   #$7F              ; set all non sign bits
00E3BC  2  25 AD              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
00E3BE  2  48                 PHA                     ; push on stack
00E3BF  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00E3C1  2  48                 PHA                     ; push on stack
00E3C2  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00E3C4  2  48                 PHA                     ; push on stack
00E3C5  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00E3C7  2  48                 PHA                     ; push on stack
00E3C8  2               
00E3C8  2  20 BC 00           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
00E3CB  2  20 15 CC           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00E3CE  2                                             ; else do type mismatch
00E3CE  2               
00E3CE  2                                             ; pop FAC2 (MAX/MIN expression so far)
00E3CE  2  68                 PLA                     ; pop exponent
00E3CF  2  85 B3              STA   FAC2_e            ; save FAC2 exponent
00E3D1  2  68                 PLA                     ; pop mantissa3
00E3D2  2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
00E3D4  2  68                 PLA                     ; pop mantissa1
00E3D5  2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
00E3D7  2  68                 PLA                     ; pop sign/mantissa1
00E3D8  2  85 B4              STA   FAC2_1            ; save FAC2 sign/mantissa1
00E3DA  2  85 B7              STA   FAC2_s            ; save FAC2 sign
00E3DC  2               
00E3DC  2                                             ; compare FAC1 with (packed) FAC2
00E3DC  2  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
00E3DE  2  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
00E3E0  2  4C 21 DC           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
00E3E3  2                                             ; returns A=$00 if FAC1 = (AY)
00E3E3  2                                             ; returns A=$01 if FAC1 > (AY)
00E3E3  2                                             ; returns A=$FF if FAC1 < (AY)
00E3E3  2               
00E3E3  2               ; perform WIDTH
00E3E3  2               
00E3E3  2               LAB_WDTH
00E3E3  2  C9 2C              CMP   #','              ; is next byte ","
00E3E5  2  F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
00E3E7  2               
00E3E7  2  20 8F D7           JSR   LAB_GTBY          ; get byte parameter
00E3EA  2  8A                 TXA                     ; copy width to A
00E3EB  2  F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
00E3ED  2               
00E3ED  2  E0 10              CPX   #$10              ; else make min width = 16d
00E3EF  2  90 45              BCC   TabErr            ; if less do function call error and exit
00E3F1  2               
00E3F1  2               ; this next compare ensures that we can't exit WIDTH via an error leaving the
00E3F1  2               ; tab size greater than the line length.
00E3F1  2               
00E3F1  2  E4 64              CPX   TabSiz            ; compare with tab size
00E3F3  2  B0 02              BCS   LAB_NSTT          ; branch if >= tab size
00E3F5  2               
00E3F5  2  86 64              STX   TabSiz            ; else make tab size = terminal width
00E3F7  2               LAB_NSTT
00E3F7  2  86 0F              STX   TWidth            ; set the terminal width
00E3F9  2  20 C2 00           JSR   LAB_GBYT          ; get BASIC byte back
00E3FC  2  F0 1A              BEQ   WExit             ; exit if no following
00E3FE  2               
00E3FE  2  C9 2C              CMP   #','              ; else is it ","
00E400  2  D0 A9              BNE   LAB_MMSE          ; if not do syntax error
00E402  2               
00E402  2               LAB_TBSZ
00E402  2  20 7A D7           JSR   LAB_SGBY          ; scan and get byte parameter
00E405  2  8A                 TXA                     ; copy TAB size
00E406  2  30 2E              BMI   TabErr            ; if >127 do function call error and exit
00E408  2               
00E408  2  E0 01              CPX   #$01              ; compare with min-1
00E40A  2  90 2A              BCC   TabErr            ; if <=1 do function call error and exit
00E40C  2               
00E40C  2  A5 0F              LDA   TWidth            ; set flags for width
00E40E  2  F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
00E410  2               
00E410  2  E4 0F              CPX   TWidth            ; compare TAB with width
00E412  2  F0 02              BEQ   LAB_SVTB          ; ok if =
00E414  2               
00E414  2  B0 20              BCS   TabErr            ; branch if too big
00E416  2               
00E416  2               LAB_SVTB
00E416  2  86 64              STX   TabSiz            ; save TAB size
00E418  2               
00E418  2               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
00E418  2               ; position on a line that still has at least one whole tab width between it
00E418  2               ; and the end of the line.
00E418  2               
00E418  2               WExit
00E418  2  A5 0F              LDA   TWidth            ; get width
00E41A  2  F0 06              BEQ   LAB_SULP          ; branch if infinite line
00E41C  2               
00E41C  2  C5 64              CMP   TabSiz            ; compare with tab size
00E41E  2  B0 03              BCS   LAB_WDLP          ; branch if >= tab size
00E420  2               
00E420  2  85 64              STA   TabSiz            ; else make tab size = terminal width
00E422  2               LAB_SULP
00E422  2  38                 SEC                     ; set carry for subtract
00E423  2               LAB_WDLP
00E423  2  E5 64              SBC   TabSiz            ; subtract tab size
00E425  2  B0 FC              BCS   LAB_WDLP          ; loop while no borrow
00E427  2               
00E427  2  65 64              ADC   TabSiz            ; add tab size back
00E429  2  18                 CLC                     ; clear carry for add
00E42A  2  65 64              ADC   TabSiz            ; add tab size back again
00E42C  2  85 10              STA   Iclim             ; save for now
00E42E  2  A5 0F              LDA   TWidth            ; get width back
00E430  2  38                 SEC                     ; set carry for subtract
00E431  2  E5 10              SBC   Iclim             ; subtract remainder
00E433  2  85 10              STA   Iclim             ; save tab column limit
00E435  2               LAB_NOSQ
00E435  2  60                 RTS
00E436  2               
00E436  2               TabErr
00E436  2  4C 14 D2           JMP   LAB_FCER          ; do function call error then warm start
00E439  2               
00E439  2               ; perform SQR()
00E439  2               
00E439  2               LAB_SQR
00E439  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign
00E43B  2  30 F9              BMI   TabErr            ; if -ve do function call error
00E43D  2               
00E43D  2  A5 AC              LDA   FAC1_e            ; get exponent
00E43F  2  F0 F4              BEQ   LAB_NOSQ          ; if zero just return
00E441  2               
00E441  2                                             ; else do root
00E441  2  20 D4 DB           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00E444  2  A9 00              LDA   #$00              ; clear A
00E446  2               
00E446  2  85 77              STA   FACt_3            ; clear remainder
00E448  2  85 76              STA   FACt_2            ; ..
00E44A  2  85 75              STA   FACt_1            ; ..
00E44C  2  85 78              STA   TempB             ; ..
00E44E  2               
00E44E  2  85 AF              STA   FAC1_3            ; clear root
00E450  2  85 AE              STA   FAC1_2            ; ..
00E452  2  85 AD              STA   FAC1_1            ; ..
00E454  2               
00E454  2  A2 18              LDX   #$18              ; 24 pairs of bits to do
00E456  2  A5 B3              LDA   FAC2_e            ; get exponent
00E458  2  4A                 LSR                     ; check odd/even
00E459  2  B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
00E45B  2               
00E45B  2               LAB_SQE1
00E45B  2  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
00E45D  2  26 B5              ROL   FAC2_2            ; ..
00E45F  2  26 B4              ROL   FAC2_1            ; ..
00E461  2  26 77              ROL   FACt_3            ; .. into remainder
00E463  2  26 76              ROL   FACt_2            ; ..
00E465  2  26 75              ROL   FACt_1            ; ..
00E467  2  26 78              ROL   TempB             ; .. never overflows
00E469  2               LAB_SQE2
00E469  2  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
00E46B  2  26 B5              ROL   FAC2_2            ; ..
00E46D  2  26 B4              ROL   FAC2_1            ; ..
00E46F  2  26 77              ROL   FACt_3            ; .. into remainder
00E471  2  26 76              ROL   FACt_2            ; ..
00E473  2  26 75              ROL   FACt_1            ; ..
00E475  2  26 78              ROL   TempB             ; .. never overflows
00E477  2               
00E477  2  06 AF              ASL   FAC1_3            ; root = root * 2
00E479  2  26 AE              ROL   FAC1_2            ; ..
00E47B  2  26 AD              ROL   FAC1_1            ; .. never overflows
00E47D  2               
00E47D  2  A5 AF              LDA   FAC1_3            ; get root low byte
00E47F  2  2A                 ROL                     ; *2
00E480  2  85 5B              STA   Temp3             ; save partial low byte
00E482  2  A5 AE              LDA   FAC1_2            ; get root low mid byte
00E484  2  2A                 ROL                     ; *2
00E485  2  85 5C              STA   Temp3+1           ; save partial low mid byte
00E487  2  A5 AD              LDA   FAC1_1            ; get root high mid byte
00E489  2  2A                 ROL                     ; *2
00E48A  2  85 5D              STA   Temp3+2           ; save partial high mid byte
00E48C  2  A9 00              LDA   #$00              ; get root high byte (always $00)
00E48E  2  2A                 ROL                     ; *2
00E48F  2  85 5E              STA   Temp3+3           ; save partial high byte
00E491  2               
00E491  2                                             ; carry clear for subtract +1
00E491  2  A5 77              LDA   FACt_3            ; get remainder low byte
00E493  2  E5 5B              SBC   Temp3             ; subtract partial low byte
00E495  2  85 5B              STA   Temp3             ; save partial low byte
00E497  2               
00E497  2  A5 76              LDA   FACt_2            ; get remainder low mid byte
00E499  2  E5 5C              SBC   Temp3+1           ; subtract partial low mid byte
00E49B  2  85 5C              STA   Temp3+1           ; save partial low mid byte
00E49D  2               
00E49D  2  A5 75              LDA   FACt_1            ; get remainder high mid byte
00E49F  2  E5 5D              SBC   Temp3+2           ; subtract partial high mid byte
00E4A1  2  A8                 TAY                     ; copy partial high mid byte
00E4A2  2               
00E4A2  2  A5 78              LDA   TempB             ; get remainder high byte
00E4A4  2  E5 5E              SBC   Temp3+3           ; subtract partial high byte
00E4A6  2  90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
00E4A8  2               
00E4A8  2  85 78              STA   TempB             ; save remainder high byte
00E4AA  2               
00E4AA  2  84 75              STY   FACt_1            ; save remainder high mid byte
00E4AC  2               
00E4AC  2  A5 5C              LDA   Temp3+1           ; get remainder low mid byte
00E4AE  2  85 76              STA   FACt_2            ; save remainder low mid byte
00E4B0  2               
00E4B0  2  A5 5B              LDA   Temp3             ; get partial low byte
00E4B2  2  85 77              STA   FACt_3            ; save remainder low byte
00E4B4  2               
00E4B4  2  E6 AF              INC   FAC1_3            ; increment root low byte (never any rollover)
00E4B6  2               LAB_SQNS
00E4B6  2  CA                 DEX                     ; decrement bit pair count
00E4B7  2  D0 A2              BNE   LAB_SQE1          ; loop if not all done
00E4B9  2               
00E4B9  2  38                 SEC                     ; set carry for subtract
00E4BA  2  A5 B3              LDA   FAC2_e            ; get exponent
00E4BC  2  E9 80              SBC   #$80              ; normalise
00E4BE  2  6A                 ROR                     ; /2 and re-bias to $80
00E4BF  2  69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
00E4C1  2  85 AC              STA   FAC1_e            ; save it
00E4C3  2  4C 3E D9           JMP   LAB_24D5          ; normalise FAC1 and return
00E4C6  2               
00E4C6  2               ; perform VARPTR()
00E4C6  2               
00E4C6  2               LAB_VARPTR
00E4C6  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00E4C9  2  20 95 D0           JSR   LAB_GVAR          ; get var address
00E4CC  2  20 3E CD           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00E4CF  2  A4 95              LDY   Cvaral            ; get var address low byte
00E4D1  2  A5 96              LDA   Cvarah            ; get var address high byte
00E4D3  2  4C 44 D3           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00E4D6  2               
00E4D6  2               ; perform PI
00E4D6  2               
00E4D6  2               LAB_PI
00E4D6  2  A9 30              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
00E4D8  2  A0 F7              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
00E4DA  2  20 87 DB           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00E4DD  2  C6 AC              DEC   FAC1_e            ; make result = PI
00E4DF  2  60                 RTS
00E4E0  2               
00E4E0  2               ; perform TWOPI
00E4E0  2               
00E4E0  2               LAB_TWOPI
00E4E0  2  A9 30              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
00E4E2  2  A0 F7              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
00E4E4  2  4C 87 DB           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
00E4E7  2               
00E4E7  2               ; shared keyword string table for extended tokens
00E4E7  2               ; used by cruncher, LIST decoder; indexed by (token_id - 1)
00E4E7  2               
00E4E7  2               XTK_COUNT = 70
00E4E7  2               
00E4E7  2               TAB_XTKSTR
00E4E7  2  73 E5 77 E5        .word @s_dir, @s_del, @s_xmem, @s_xbank, @s_xpoke
00E4EB  2  7B E5 80 E5  
00E4EF  2  86 E5        
00E4F1  2  8C E5 93 E5        .word @s_xpeek, @s_stash, @s_fetch, @s_xfree, @s_xreset
00E4F5  2  99 E5 9F E5  
00E4F9  2  A5 E5        
00E4FB  2  AC E5 B3 E5        .word @s_xalloc, @s_xdir, @s_xdel, @s_xmap, @s_xunmap
00E4FF  2  B8 E5 BD E5  
00E503  2  C2 E5        
00E505  2  C9 E5 CF E5        .word @s_gsave, @s_gload, @s_sidplay, @s_sidstop
00E509  2  D5 E5 DD E5  
00E50D  2  E5 E5 EB E5        .word @s_music, @s_playing, @s_mnote, @s_copper, @s_reset
00E511  2  F3 E5 FA E5  
00E515  2  01 E6        
00E517  2  07 E6 0D E6        .word @s_nopen, @s_nclose, @s_nlisten, @s_naccept, @s_nsend
00E51B  2  14 E6 1C E6  
00E51F  2  24 E6        
00E521  2  2A E6 32 E6        .word @s_nrecv, @s_nstatus, @s_reserved20, @s_nready, @s_nlen
00E525  2  3B E6 3D E6  
00E529  2  45 E6        
00E52B  2  4A E6 52 E6        .word @s_dmacopy, @s_dmafill, @s_dmastatus, @s_reserved26, @s_dmaerr, @s_dmacount
00E52F  2  5A E6 64 E6  
00E533  2  66 E6 6D E6  
00E537  2                     ; $29-$3F reserved (23 entries)
00E537  2  76 E6 76 E6        .repeat $17
00E53B  2  76 E6 76 E6  
00E53F  2  76 E6 76 E6  
00E565  2                     .word @s_reserved_ext
00E565  2                     .endrepeat
00E565  2  78 E6 81 E6        .word @s_blitcopy, @s_blitfill, @s_blitstatus, @s_bliterr, @s_blitcount
00E569  2  8A E6 95 E6  
00E56D  2  9D E6        
00E56F  2  A7 E6              .word @s_bittgl
00E571  2  AE E6              .word @s_help
00E573  2               
00E573  2  44 49 52 00  @s_dir:    .byte "DIR",0
00E577  2  44 45 4C 00  @s_del:    .byte "DEL",0
00E57B  2  58 4D 45 4D  @s_xmem:   .byte "XMEM",0
00E57F  2  00           
00E580  2  58 42 41 4E  @s_xbank:  .byte "XBANK",0
00E584  2  4B 00        
00E586  2  58 50 4F 4B  @s_xpoke:  .byte "XPOKE",0
00E58A  2  45 00        
00E58C  2  58 50 45 45  @s_xpeek:  .byte "XPEEK(",0
00E590  2  4B 28 00     
00E593  2  53 54 41 53  @s_stash:  .byte "STASH",0
00E597  2  48 00        
00E599  2  46 45 54 43  @s_fetch:  .byte "FETCH",0
00E59D  2  48 00        
00E59F  2  58 46 52 45  @s_xfree:  .byte "XFREE",0
00E5A3  2  45 00        
00E5A5  2  58 52 45 53  @s_xreset: .byte "XRESET",0
00E5A9  2  45 54 00     
00E5AC  2  58 41 4C 4C  @s_xalloc: .byte "XALLOC",0
00E5B0  2  4F 43 00     
00E5B3  2  58 44 49 52  @s_xdir:   .byte "XDIR",0
00E5B7  2  00           
00E5B8  2  58 44 45 4C  @s_xdel:   .byte "XDEL",0
00E5BC  2  00           
00E5BD  2  58 4D 41 50  @s_xmap:   .byte "XMAP",0
00E5C1  2  00           
00E5C2  2  58 55 4E 4D  @s_xunmap: .byte "XUNMAP",0
00E5C6  2  41 50 00     
00E5C9  2  47 53 41 56  @s_gsave:  .byte "GSAVE",0
00E5CD  2  45 00        
00E5CF  2  47 4C 4F 41  @s_gload:  .byte "GLOAD",0
00E5D3  2  44 00        
00E5D5  2  53 49 44 50  @s_sidplay: .byte "SIDPLAY",0
00E5D9  2  4C 41 59 00  
00E5DD  2  53 49 44 53  @s_sidstop: .byte "SIDSTOP",0
00E5E1  2  54 4F 50 00  
00E5E5  2  4D 55 53 49  @s_music:  .byte "MUSIC",0
00E5E9  2  43 00        
00E5EB  2  50 4C 41 59  @s_playing: .byte "PLAYING",0
00E5EF  2  49 4E 47 00  
00E5F3  2  4D 4E 4F 54  @s_mnote:  .byte "MNOTE(",0
00E5F7  2  45 28 00     
00E5FA  2  43 4F 50 50  @s_copper: .byte "COPPER",0
00E5FE  2  45 52 00     
00E601  2  52 45 53 45  @s_reset:  .byte "RESET",0
00E605  2  54 00        
00E607  2  4E 4F 50 45  @s_nopen:   .byte "NOPEN",0
00E60B  2  4E 00        
00E60D  2  4E 43 4C 4F  @s_nclose:  .byte "NCLOSE",0
00E611  2  53 45 00     
00E614  2  4E 4C 49 53  @s_nlisten: .byte "NLISTEN",0
00E618  2  54 45 4E 00  
00E61C  2  4E 41 43 43  @s_naccept: .byte "NACCEPT",0
00E620  2  45 50 54 00  
00E624  2  4E 53 45 4E  @s_nsend:   .byte "NSEND",0
00E628  2  44 00        
00E62A  2  4E 52 45 43  @s_nrecv:   .byte "NRECV$(",0
00E62E  2  56 24 28 00  
00E632  2  4E 53 54 41  @s_nstatus: .byte "NSTATUS(",0
00E636  2  54 55 53 28  
00E63A  2  00           
00E63B  2  FF 00        @s_reserved20: .byte $FF,0         ; placeholder — token $20 (space) is unusable
00E63D  2  4E 52 45 41  @s_nready:  .byte "NREADY(",0
00E641  2  44 59 28 00  
00E645  2  4E 4C 45 4E  @s_nlen:    .byte "NLEN",0
00E649  2  00           
00E64A  2  44 4D 41 43  @s_dmacopy: .byte "DMACOPY",0
00E64E  2  4F 50 59 00  
00E652  2  44 4D 41 46  @s_dmafill: .byte "DMAFILL",0
00E656  2  49 4C 4C 00  
00E65A  2  44 4D 41 53  @s_dmastatus: .byte "DMASTATUS",0
00E65E  2  54 41 54 55  
00E662  2  53 00        
00E664  2  FF 00        @s_reserved26: .byte $FF,0         ; placeholder — token $26 is unusable
00E666  2  44 4D 41 45  @s_dmaerr:  .byte "DMAERR",0
00E66A  2  52 52 00     
00E66D  2  44 4D 41 43  @s_dmacount: .byte "DMACOUNT",0
00E671  2  4F 55 4E 54  
00E675  2  00           
00E676  2  FF 00        @s_reserved_ext: .byte $FF,0       ; placeholder — reserved extension id
00E678  2  42 4C 49 54  @s_blitcopy: .byte "BLITCOPY",0
00E67C  2  43 4F 50 59  
00E680  2  00           
00E681  2  42 4C 49 54  @s_blitfill: .byte "BLITFILL",0
00E685  2  46 49 4C 4C  
00E689  2  00           
00E68A  2  42 4C 49 54  @s_blitstatus: .byte "BLITSTATUS",0
00E68E  2  53 54 41 54  
00E692  2  55 53 00     
00E695  2  42 4C 49 54  @s_bliterr: .byte "BLITERR",0
00E699  2  45 52 52 00  
00E69D  2  42 4C 49 54  @s_blitcount: .byte "BLITCOUNT",0
00E6A1  2  43 4F 55 4E  
00E6A5  2  54 00        
00E6A7  2  42 49 54 54  @s_bittgl: .byte "BITTGL",0
00E6AB  2  47 4C 00     
00E6AE  2  48 45 4C 50  @s_help:   .byte "HELP",0
00E6B2  2  00           
00E6B3  2               
00E6B3  2               ; system dependant i/o vectors
00E6B3  2               ; these are in RAM and are set by the monitor at start-up
00E6B3  2               
00E6B3  2               V_INPT
00E6B3  2  6C 05 02           JMP   (VEC_IN)          ; non halting scan input device
00E6B6  2               V_OUTP
00E6B6  2  6C 07 02           JMP   (VEC_OUT)         ; send byte to output device
00E6B9  2               V_LOAD
00E6B9  2  6C 09 02           JMP   (VEC_LD)          ; load BASIC program
00E6BC  2               V_SAVE
00E6BC  2  6C 0B 02           JMP   (VEC_SV)          ; save BASIC program
00E6BF  2               
00E6BF  2               ; The rest are tables messages and code for RAM
00E6BF  2               
00E6BF  2               ; the rest of the code is tables and BASIC start-up code
00E6BF  2               
00E6BF  2               PG2_TABS
00E6BF  2  00                 .byte $00               ; ctrl-c flag           -     $00 = enabled
00E6C0  2  00                 .byte $00               ; ctrl-c byte           -     GET needs this
00E6C1  2  00                 .byte $00               ; ctrl-c byte timeout   -     GET needs this
00E6C2  2  A5 E2              .word CTRLC             ; ctrl c check vector
00E6C4  2               ;     .word xxxx              ; non halting key input -     monitor to set this
00E6C4  2               ;     .word xxxx              ; output vector         -     monitor to set this
00E6C4  2               ;     .word xxxx              ; load vector           -     monitor to set this
00E6C4  2               ;     .word xxxx              ; save vector           -     monitor to set this
00E6C4  2               PG2_TABE
00E6C4  2               
00E6C4  2               ; --- VGC I/O register addresses ---
00E6C4  2               
00E6C4  2               VGC_MODE      = $A000
00E6C4  2               VGC_BGCOL     = $A001
00E6C4  2               VGC_FGCOL     = $A002
00E6C4  2               VGC_CURSX     = $A003
00E6C4  2               VGC_CURSY     = $A004
00E6C4  2               VGC_FRAME     = $A008          ; frame counter (read-only, incremented by host)
00E6C4  2               VGC_COLLST    = $A00B          ; sprite-sprite collision (read-only)
00E6C4  2               VGC_COLLBG    = $A00C          ; sprite-background collision (read-only)
00E6C4  2               VGC_BORDER    = $A00D          ; border color
00E6C4  2               VGC_CHAROUT   = $A00E
00E6C4  2               
00E6C4  2               ; --- VGC unified command register and parameters ---
00E6C4  2               
00E6C4  2               VGC_CMD       = $A010          ; command register (write triggers execution)
00E6C4  2               VGC_P0        = $A011          ; parameter 0
00E6C4  2               VGC_P1        = $A012          ; parameter 1
00E6C4  2               VGC_P2        = $A013          ; parameter 2
00E6C4  2               VGC_P3        = $A014          ; parameter 3
00E6C4  2               VGC_P4        = $A015          ; parameter 4
00E6C4  2               VGC_P5        = $A016          ; parameter 5
00E6C4  2               VGC_P6        = $A017          ; parameter 6
00E6C4  2               VGC_P7        = $A018          ; parameter 7
00E6C4  2               VGC_P8        = $A019          ; parameter 8
00E6C4  2               VGC_P9        = $A01A          ; parameter 9
00E6C4  2               
00E6C4  2               ; --- VGC graphics command codes ---
00E6C4  2               
00E6C4  2               VCMD_PLOT     = $01
00E6C4  2               VCMD_UNPLOT   = $02
00E6C4  2               VCMD_LINE     = $03
00E6C4  2               VCMD_CIRCLE   = $04
00E6C4  2               VCMD_RECT     = $05
00E6C4  2               VCMD_FILL     = $06
00E6C4  2               VCMD_GCLS     = $07
00E6C4  2               VCMD_GCOLOR   = $08
00E6C4  2               VCMD_PAINT    = $09
00E6C4  2               
00E6C4  2               ; --- VGC sprite command codes ---
00E6C4  2               
00E6C4  2               VCMD_SPRDEF   = $10            ; P0=sprite, P1=x, P2=y, P3=color
00E6C4  2               VCMD_SPRROW   = $11            ; P0=sprite, P1=row, P2-P9=8 bytes
00E6C4  2               VCMD_SPRCLR   = $12            ; P0=sprite (clears shape data)
00E6C4  2               VCMD_SPRCOPY  = $13            ; P0=src, P1=dest
00E6C4  2               VCMD_SPRPOS   = $14            ; P0=sprite, P1=x_low, P2=x_high, P3=y_low, P4=y_high
00E6C4  2               VCMD_SPRENA   = $15            ; P0=sprite
00E6C4  2               VCMD_SPRDIS   = $16            ; P0=sprite
00E6C4  2               VCMD_SPRFLIP  = $17            ; P0=sprite, P1=flags
00E6C4  2               VCMD_SPRPRI   = $18            ; P0=sprite, P1=priority
00E6C4  2               
00E6C4  2               VCMD_COPPERADD = $1B           ; P0/P1=x, P2=y, P3=reg, P4=0, P5=value
00E6C4  2               VCMD_COPPERCLR = $1C           ; no params
00E6C4  2               VCMD_COPPERENA = $1D           ; no params
00E6C4  2               VCMD_COPPERDIS = $1E           ; no params
00E6C4  2               VCMD_SYSRESET  = $1F           ; full system reset (VGC+SID+music)
00E6C4  2               VCMD_COPPERLIST = $20          ; P0=list index (0-127)
00E6C4  2               VCMD_COPPERUSE = $21           ; P0=list index (0-127)
00E6C4  2               VCMD_COPPEREND = $22           ; reset target to active list
00E6C4  2               
00E6C4  2               ; --- File I/O coprocessor registers ---
00E6C4  2               
00E6C4  2               FIO_CMD       = $B9A0          ; command register (write triggers)
00E6C4  2               FIO_STATUS    = $B9A1          ; status: 0=idle, 2=ok, 3=error
00E6C4  2               FIO_ERRCODE   = $B9A2          ; error: 0=none, 1=not found, 2=io error
00E6C4  2               FIO_NAMELEN   = $B9A3          ; filename length (1-63)
00E6C4  2               FIO_SRCL      = $B9A4          ; source/dest addr low
00E6C4  2               FIO_SRCH      = $B9A5          ; source/dest addr high
00E6C4  2               FIO_ENDL      = $B9A6          ; end addr low (SAVE only)
00E6C4  2               FIO_ENDH      = $B9A7          ; end addr high (SAVE only)
00E6C4  2               FIO_SIZEL     = $B9A8          ; loaded size low (set by host after LOAD)
00E6C4  2               FIO_SIZEH     = $B9A9          ; loaded size high
00E6C4  2               FIO_GSPACE    = $B9AA          ; graphics space selector (0=screen,1=color,2=gfx,3=sprite)
00E6C4  2               FIO_GADDRL    = $B9AB          ; graphics offset low
00E6C4  2               FIO_GADDRH    = $B9AC          ; graphics offset high
00E6C4  2               FIO_GLENL     = $B9AD          ; graphics transfer length low
00E6C4  2               FIO_GLENH     = $B9AE          ; graphics transfer length high
00E6C4  2               FIO_DIRTYPE   = $B9AF          ; dir entry type: 0=PRG, 1=SID
00E6C4  2               FIO_NAME      = $B9B0          ; filename buffer (64 bytes)
00E6C4  2               
00E6C4  2               FIO_CMD_SAVE  = $01            ; save program
00E6C4  2               FIO_CMD_LOAD  = $02            ; load program
00E6C4  2               FIO_OK        = $02            ; status: success
00E6C4  2               FIO_ERR       = $03            ; status: error
00E6C4  2               FIO_CMD_DIROPEN = $03          ; enumerate *.bas files, populate first entry
00E6C4  2               FIO_CMD_DIRREAD = $04          ; advance to next entry
00E6C4  2               FIO_CMD_DELETE = $05           ; delete a single *.bas file by name
00E6C4  2               FIO_CMD_GSAVE = $06            ; save VGC memory block to *.gfx
00E6C4  2               FIO_CMD_GLOAD = $07            ; load *.gfx into VGC memory block
00E6C4  2               FIO_CMD_SIDPLAY = $08          ; load .sid and start playback
00E6C4  2               FIO_CMD_SIDSTOP = $09          ; stop SID playback
00E6C4  2               FIO_CMD_INSTRUMENT = $0A       ; define instrument preset
00E6C4  2               FIO_CMD_SOUND  = $0B           ; play SFX (note, duration, instrument)
00E6C4  2               FIO_CMD_VOLUME = $0C           ; set master volume
00E6C4  2               FIO_CMD_MSEQ   = $0D           ; set voice MML sequence
00E6C4  2               FIO_CMD_MPLAY  = $0E           ; start music playback
00E6C4  2               FIO_CMD_MSTOP  = $0F           ; stop music playback
00E6C4  2               FIO_CMD_MTEMPO = $10           ; set music tempo (BPM)
00E6C4  2               FIO_CMD_MLOOP  = $11           ; set music loop on/off
00E6C4  2               FIO_CMD_MPRI   = $12           ; set SFX voice steal priority
00E6C4  2               MUSIC_STATUS   = $BA50         ; bit 0=SFX playing, bit 1=music playing
00E6C4  2               MUSIC_NOTE1    = $BA51         ; voice 1 current MIDI note (0=silent)
00E6C4  2               MUSIC_NOTE2    = $BA52         ; voice 2 current MIDI note
00E6C4  2               MUSIC_NOTE3    = $BA53         ; voice 3 current MIDI note
00E6C4  2               MUSIC_NOTE4    = $BA54         ; voice 4 current MIDI note (SID2)
00E6C4  2               MUSIC_NOTE5    = $BA55         ; voice 5 current MIDI note (SID2)
00E6C4  2               MUSIC_NOTE6    = $BA56         ; voice 6 current MIDI note (SID2)
00E6C4  2               FIO_ERR_EOD   = $03            ; end of directory
00E6C4  2               
00E6C4  2               ; --- XMC expansion memory controller registers ---
00E6C4  2               
00E6C4  2               XMC_CMD       = $BA00          ; command register (write triggers)
00E6C4  2               XMC_STATUS    = $BA01          ; status: 0=idle, 2=ok, 3=error
00E6C4  2               XMC_ERRCODE   = $BA02          ; error: 0=none
00E6C4  2               XMC_CFG       = $BA03          ; config flags (reserved)
00E6C4  2               XMC_XAL       = $BA04          ; expansion addr low
00E6C4  2               XMC_XAM       = $BA05          ; expansion addr mid
00E6C4  2               XMC_XAH       = $BA06          ; expansion addr high
00E6C4  2               XMC_RAML      = $BA07          ; cpu addr low
00E6C4  2               XMC_RAMH      = $BA08          ; cpu addr high
00E6C4  2               XMC_LENL      = $BA09          ; transfer length low
00E6C4  2               XMC_LENH      = $BA0A          ; transfer length high
00E6C4  2               XMC_DATA      = $BA0B          ; data port
00E6C4  2               XMC_BANK      = $BA0C          ; current 64KB bank
00E6C4  2               XMC_BANKS     = $BA0D          ; total banks
00E6C4  2               XMC_USEDL     = $BA0E          ; used pages low (future allocator)
00E6C4  2               XMC_USEDH     = $BA0F          ; used pages high
00E6C4  2               XMC_FREEL     = $BA10          ; free pages low
00E6C4  2               XMC_FREEH     = $BA11          ; free pages high
00E6C4  2               XMC_NAMELEN   = $BA12          ; name length (0-27)
00E6C4  2               XMC_HANDLE    = $BA13          ; block handle
00E6C4  2               XMC_DIRCOUNTL = $BA14          ; named block count low
00E6C4  2               XMC_DIRCOUNTH = $BA15          ; named block count high
00E6C4  2               XMC_WINCTL    = $BA16          ; mapped window enable bits
00E6C4  2               XMC_W0AL      = $BA18          ; window 0 xaddr low
00E6C4  2               XMC_W0AM      = $BA19          ; window 0 xaddr mid
00E6C4  2               XMC_W0AH      = $BA1A          ; window 0 xaddr high
00E6C4  2               XMC_W1AL      = $BA1B          ; window 1 xaddr low
00E6C4  2               XMC_W1AM      = $BA1C          ; window 1 xaddr mid
00E6C4  2               XMC_W1AH      = $BA1D          ; window 1 xaddr high
00E6C4  2               XMC_W2AL      = $BA1E          ; window 2 xaddr low
00E6C4  2               XMC_W2AM      = $BA1F          ; window 2 xaddr mid
00E6C4  2               XMC_W2AH      = $BA20          ; window 2 xaddr high
00E6C4  2               XMC_W3AL      = $BA21          ; window 3 xaddr low
00E6C4  2               XMC_W3AM      = $BA22          ; window 3 xaddr mid
00E6C4  2               XMC_W3AH      = $BA23          ; window 3 xaddr high
00E6C4  2               XMC_NAME      = $BA24          ; name buffer start
00E6C4  2               XMC_NAME_MAX  = 28             ; bytes in name buffer
00E6C4  2               
00E6C4  2               XMC_CMD_GET   = $01            ; read byte at XADDR into XMC_DATA
00E6C4  2               XMC_CMD_PUT   = $02            ; write XMC_DATA to XADDR
00E6C4  2               XMC_CMD_STASH = $03            ; copy RAM -> XRAM
00E6C4  2               XMC_CMD_FETCH = $04            ; copy XRAM -> RAM
00E6C4  2               XMC_CMD_FILL  = $05            ; fill XRAM with XMC_DATA
00E6C4  2               XMC_CMD_STATS = $07            ; refresh stats
00E6C4  2               XMC_CMD_RSTUS = $08            ; clear usage tracking metadata
00E6C4  2               XMC_CMD_REL   = $09            ; mark range as free in usage tracking
00E6C4  2               XMC_CMD_ALLOC = $0A            ; allocate block (len -> xaddr/handle)
00E6C4  2               XMC_CMD_NSTSH = $0B            ; named stash RAM->XRAM
00E6C4  2               XMC_CMD_NFETC = $0C            ; named fetch XRAM->RAM
00E6C4  2               XMC_CMD_NDEL  = $0D            ; named delete
00E6C4  2               XMC_CMD_NDIRO = $0E            ; named dir open
00E6C4  2               XMC_CMD_NDIRR = $0F            ; named dir read
00E6C4  2               XMC_OK        = $02            ; command success status
00E6C4  2               XMC_ERR_NF    = $03            ; not found
00E6C4  2               XMC_ERR_EOD   = $06            ; end of directory
00E6C4  2               
00E6C4  2               ; --- NIC network interface controller registers ---
00E6C4  2               
00E6C4  2               NIC_CMD        = $A100          ; command register (write triggers)
00E6C4  2               NIC_STATUS     = $A101          ; global status
00E6C4  2               NIC_SLOT       = $A102          ; active slot ID (0-3)
00E6C4  2               NIC_RPORTL     = $A108          ; remote port low
00E6C4  2               NIC_RPORTH     = $A109          ; remote port high
00E6C4  2               NIC_LPORTL     = $A10A          ; local port low (for listen)
00E6C4  2               NIC_LPORTH     = $A10B          ; local port high
00E6C4  2               NIC_DMAL       = $A110          ; DMA RAM address low
00E6C4  2               NIC_DMAH       = $A111          ; DMA RAM address high
00E6C4  2               NIC_DMALEN     = $A112          ; DMA length
00E6C4  2               NIC_MSGLEN     = $A113          ; received message length (read-only)
00E6C4  2               NIC_SLOTST0    = $A118          ; slot 0 status
00E6C4  2               NIC_NAMEBUF    = $A120          ; hostname buffer (32 bytes, null-terminated)
00E6C4  2               
00E6C4  2               NIC_CMD_CONNECT    = $01
00E6C4  2               NIC_CMD_DISCONNECT = $02
00E6C4  2               NIC_CMD_SEND       = $03
00E6C4  2               NIC_CMD_RECV       = $04
00E6C4  2               NIC_CMD_LISTEN     = $05
00E6C4  2               NIC_CMD_ACCEPT     = $06
00E6C4  2               
00E6C4  2               NIC_ST_CONNECTED   = $01
00E6C4  2               NIC_ST_DATAREADY   = $02
00E6C4  2               NIC_ST_ERROR       = $08
00E6C4  2               
00E6C4  2               ; --- Unified DMA controller registers ---
00E6C4  2               
00E6C4  2               DMA_CMD       = $BA60          ; write triggers transfer
00E6C4  2               DMA_STATUS    = $BA61          ; 1=busy, 2=ok, 3=error
00E6C4  2               DMA_ERRCODE   = $BA62          ; DMA error code
00E6C4  2               DMA_SRCSPACE  = $BA63          ; source space id
00E6C4  2               DMA_DSTSPACE  = $BA64          ; destination space id
00E6C4  2               DMA_SRCL      = $BA65          ; source addr low
00E6C4  2               DMA_SRCM      = $BA66          ; source addr mid
00E6C4  2               DMA_SRCH      = $BA67          ; source addr high
00E6C4  2               DMA_DSTL      = $BA68          ; destination addr low
00E6C4  2               DMA_DSTM      = $BA69          ; destination addr mid
00E6C4  2               DMA_DSTH      = $BA6A          ; destination addr high
00E6C4  2               DMA_LENL      = $BA6B          ; length low
00E6C4  2               DMA_LENM      = $BA6C          ; length mid
00E6C4  2               DMA_LENH      = $BA6D          ; length high
00E6C4  2               DMA_MODE      = $BA6E          ; mode flags
00E6C4  2               DMA_FILL      = $BA6F          ; fill byte (when mode bit0 set)
00E6C4  2               DMA_CNTL      = $BA70          ; transferred count low
00E6C4  2               DMA_CNTM      = $BA71          ; transferred count mid
00E6C4  2               DMA_CNTH      = $BA72          ; transferred count high
00E6C4  2               
00E6C4  2               DMA_CMD_START = $01
00E6C4  2               DMA_BUSY      = $01
00E6C4  2               DMA_OK        = $02
00E6C4  2               DMA_MODE_FILL = $01
00E6C4  2               DMA_SPACE_XRAM = $05
00E6C4  2               
00E6C4  2               ; --- Blitter controller registers ---
00E6C4  2               
00E6C4  2               BLT_CMD       = $BA80          ; write triggers blit
00E6C4  2               BLT_STATUS    = $BA81          ; 1=busy, 2=ok, 3=error
00E6C4  2               BLT_ERRCODE   = $BA82          ; blitter error code
00E6C4  2               BLT_SRCSPACE  = $BA83          ; source space id
00E6C4  2               BLT_DSTSPACE  = $BA84          ; destination space id
00E6C4  2               BLT_SRCL      = $BA85          ; source addr low
00E6C4  2               BLT_SRCM      = $BA86          ; source addr mid
00E6C4  2               BLT_SRCH      = $BA87          ; source addr high
00E6C4  2               BLT_DSTL      = $BA88          ; destination addr low
00E6C4  2               BLT_DSTM      = $BA89          ; destination addr mid
00E6C4  2               BLT_DSTH      = $BA8A          ; destination addr high
00E6C4  2               BLT_WIDTHL    = $BA8B          ; width low
00E6C4  2               BLT_WIDTHH    = $BA8C          ; width high
00E6C4  2               BLT_HEIGHTL   = $BA8D          ; height low
00E6C4  2               BLT_HEIGHTH   = $BA8E          ; height high
00E6C4  2               BLT_SRCSTRL   = $BA8F          ; source stride low
00E6C4  2               BLT_SRCSTRH   = $BA90          ; source stride high
00E6C4  2               BLT_DSTSTRL   = $BA91          ; destination stride low
00E6C4  2               BLT_DSTSTRH   = $BA92          ; destination stride high
00E6C4  2               BLT_MODE      = $BA93          ; mode flags
00E6C4  2               BLT_FILL      = $BA94          ; fill byte (when mode bit0 set)
00E6C4  2               BLT_CKEY      = $BA95          ; color key (when mode bit1 set)
00E6C4  2               BLT_CNTL      = $BA96          ; written count low
00E6C4  2               BLT_CNTM      = $BA97          ; written count mid
00E6C4  2               BLT_CNTH      = $BA98          ; written count high
00E6C4  2               
00E6C4  2               BLT_CMD_START = $01
00E6C4  2               BLT_BUSY      = $01
00E6C4  2               BLT_OK        = $02
00E6C4  2               BLT_MODE_FILL = $01
00E6C4  2               BLT_SPACE_XRAM = $05
00E6C4  2               
00E6C4  2               ; --- VGC command handlers ---
00E6C4  2               
00E6C4  2               ; draw a text-only cold-start splash screen
00E6C4  2               
00E6C4  2               LAB_SPLASH
00E6C4  2  A9 06              LDA   #$06              ; blue background
00E6C6  2  8D 01 A0           STA   VGC_BGCOL
00E6C9  2  A9 01              LDA   #$01              ; white text
00E6CB  2  8D 02 A0           STA   VGC_FGCOL
00E6CE  2  A9 06              LDA   #$06              ; blue border
00E6D0  2  8D 0D A0           STA   VGC_BORDER
00E6D3  2  A9 00              LDA   #$00              ; mode 0: text only
00E6D5  2  8D 00 A0           STA   VGC_MODE
00E6D8  2               
00E6D8  2  A9 0C              LDA   #$0C              ; clear text layer and home cursor
00E6DA  2  20 B6 E6           JSR   V_OUTP
00E6DD  2  A9 21              LDA   #$21              ; centered x for "NovaBASIC v1.0"
00E6DF  2  8D 03 A0           STA   VGC_CURSX
00E6E2  2  85 0E              STA   TPos
00E6E4  2  A9 00              LDA   #$00
00E6E6  2  8D 04 A0           STA   VGC_CURSY
00E6E9  2  A9 10              LDA   #<LAB_BNR1
00E6EB  2  A0 E7              LDY   #>LAB_BNR1
00E6ED  2  20 2A CA           JSR   LAB_18C3
00E6F0  2               
00E6F0  2  A9 1A              LDA   #$1A              ; centered x for "Derived from EhBASIC 2.22p5"
00E6F2  2  8D 03 A0           STA   VGC_CURSX
00E6F5  2  85 0E              STA   TPos
00E6F7  2  A9 02              LDA   #$02              ; one empty row between lines
00E6F9  2  8D 04 A0           STA   VGC_CURSY
00E6FC  2  A9 1F              LDA   #<LAB_BNR2
00E6FE  2  A0 E7              LDY   #>LAB_BNR2
00E700  2  20 2A CA           JSR   LAB_18C3
00E703  2               
00E703  2  A9 11              LDA   #$11              ; centered x for "xxxxx BASIC bytes free  xxxK expansion memory"
00E705  2  8D 03 A0           STA   VGC_CURSX
00E708  2  85 0E              STA   TPos
00E70A  2  A9 04              LDA   #$04              ; one empty row between lines
00E70C  2  8D 04 A0           STA   VGC_CURSY
00E70F  2  60                 RTS
00E710  2               
00E710  2               LAB_BNR1
00E710  2  4E 6F 76 61        .byte "NovaBASIC v1.0",$00
00E714  2  42 41 53 49  
00E718  2  43 20 76 31  
00E71F  2               LAB_BNR2
00E71F  2  44 65 72 69        .byte "Derived from EhBASIC 2.22p5",$00
00E723  2  76 65 64 20  
00E727  2  66 72 6F 6D  
00E73B  2               
00E73B  2               ; perform CLS — clear screen, no arguments
00E73B  2               
00E73B  2               LAB_CLS
00E73B  2  A9 0C              LDA   #$0C              ; form feed character
00E73D  2  8D 0E A0           STA   VGC_CHAROUT       ; write to CHAROUT register
00E740  2  60                 RTS
00E741  2               
00E741  2               ; perform COLOR fg [,bg]
00E741  2               
00E741  2               LAB_COLOR
00E741  2  20 8F D7           JSR   LAB_GTBY          ; get fg color byte in X
00E744  2  8E 02 A0           STX   VGC_FGCOL         ; store foreground color
00E747  2  20 C2 00           JSR   LAB_GBYT          ; peek at current byte
00E74A  2  C9 2C              CMP   #','              ; comma follows?
00E74C  2  D0 09              BNE   @done             ; no, just fg was given
00E74E  2  20 BC 00           JSR   LAB_IGBY          ; skip comma
00E751  2  20 8F D7           JSR   LAB_GTBY          ; get bg color byte in X
00E754  2  8E 01 A0           STX   VGC_BGCOL         ; store background color
00E757  2               @done
00E757  2  60                 RTS
00E758  2               
00E758  2               ; perform LOCATE x, y
00E758  2               
00E758  2               LAB_LOCATE
00E758  2  20 8F D7           JSR   LAB_GTBY          ; get x in X
00E75B  2  8E 03 A0           STX   VGC_CURSX         ; store cursor X
00E75E  2  20 4D CD           JSR   LAB_1C01          ; require comma
00E761  2  20 8F D7           JSR   LAB_GTBY          ; get y in X
00E764  2  8E 04 A0           STX   VGC_CURSY         ; store cursor Y
00E767  2  60                 RTS
00E768  2               
00E768  2               ; perform MODE n
00E768  2               
00E768  2               LAB_GMODE
00E768  2  20 8F D7           JSR   LAB_GTBY          ; get mode byte in X
00E76B  2  8E 00 A0           STX   VGC_MODE          ; store graphics mode
00E76E  2  60                 RTS
00E76F  2               
00E76F  2               ; perform GCLS — clear the graphics bitmap layer
00E76F  2               
00E76F  2               LAB_GCLS
00E76F  2  A9 07              LDA   #VCMD_GCLS        ; GCLS command
00E771  2  8D 10 A0           STA   VGC_CMD            ; trigger
00E774  2  60                 RTS
00E775  2               
00E775  2               ; perform GCOLOR c — set graphics draw color (0-15)
00E775  2               
00E775  2               LAB_GCOLOR
00E775  2  20 8F D7           JSR   LAB_GTBY          ; get color byte in X
00E778  2  8E 11 A0           STX   VGC_P0             ; color in P0
00E77B  2  A9 00              LDA   #$00
00E77D  2  8D 12 A0           STA   VGC_P1             ; high byte = 0
00E780  2  A9 08              LDA   #VCMD_GCOLOR      ; GCOLOR command
00E782  2  8D 10 A0           STA   VGC_CMD            ; trigger
00E785  2  60                 RTS
00E786  2               
00E786  2               ; perform PLOT x, y
00E786  2               
00E786  2               LAB_PLOT
00E786  2  20 7D D7           JSR   LAB_GTWRD         ; get x (0-319) as 16-bit
00E789  2  A5 AF              LDA   FAC1_3
00E78B  2  8D 11 A0           STA   VGC_P0             ; x low
00E78E  2  A5 AE              LDA   FAC1_2
00E790  2  8D 12 A0           STA   VGC_P1             ; x high
00E793  2  20 4D CD           JSR   LAB_1C01          ; require comma
00E796  2  20 8F D7           JSR   LAB_GTBY          ; get y (0-199)
00E799  2  8E 13 A0           STX   VGC_P2             ; y low
00E79C  2  A9 00              LDA   #$00
00E79E  2  8D 14 A0           STA   VGC_P3             ; y high = 0
00E7A1  2  A9 01              LDA   #VCMD_PLOT        ; PLOT command
00E7A3  2  8D 10 A0           STA   VGC_CMD            ; trigger
00E7A6  2  60                 RTS
00E7A7  2               
00E7A7  2               ; perform UNPLOT x, y
00E7A7  2               
00E7A7  2               LAB_UNPLOT
00E7A7  2  20 7D D7           JSR   LAB_GTWRD         ; get x as 16-bit
00E7AA  2  A5 AF              LDA   FAC1_3
00E7AC  2  8D 11 A0           STA   VGC_P0             ; x low
00E7AF  2  A5 AE              LDA   FAC1_2
00E7B1  2  8D 12 A0           STA   VGC_P1             ; x high
00E7B4  2  20 4D CD           JSR   LAB_1C01          ; require comma
00E7B7  2  20 8F D7           JSR   LAB_GTBY          ; get y
00E7BA  2  8E 13 A0           STX   VGC_P2             ; y low
00E7BD  2  A9 00              LDA   #$00
00E7BF  2  8D 14 A0           STA   VGC_P3             ; y high = 0
00E7C2  2  A9 02              LDA   #VCMD_UNPLOT      ; UNPLOT command
00E7C4  2  8D 10 A0           STA   VGC_CMD
00E7C7  2  60                 RTS
00E7C8  2               
00E7C8  2               ; perform LINE x0, y0, x1, y1
00E7C8  2               
00E7C8  2               LAB_GLINE
00E7C8  2  20 7D D7           JSR   LAB_GTWRD         ; x0 as 16-bit
00E7CB  2  A5 AF              LDA   FAC1_3
00E7CD  2  8D 11 A0           STA   VGC_P0             ; x0 low
00E7D0  2  A5 AE              LDA   FAC1_2
00E7D2  2  8D 12 A0           STA   VGC_P1             ; x0 high
00E7D5  2  20 4D CD           JSR   LAB_1C01          ; comma
00E7D8  2  20 8F D7           JSR   LAB_GTBY          ; y0
00E7DB  2  8E 13 A0           STX   VGC_P2             ; y0 low
00E7DE  2  A9 00              LDA   #$00
00E7E0  2  8D 14 A0           STA   VGC_P3             ; y0 high = 0
00E7E3  2  20 4D CD           JSR   LAB_1C01          ; comma
00E7E6  2  20 7D D7           JSR   LAB_GTWRD         ; x1 as 16-bit
00E7E9  2  A5 AF              LDA   FAC1_3
00E7EB  2  8D 15 A0           STA   VGC_P4             ; x1 low
00E7EE  2  A5 AE              LDA   FAC1_2
00E7F0  2  8D 16 A0           STA   VGC_P5             ; x1 high
00E7F3  2  20 4D CD           JSR   LAB_1C01          ; comma
00E7F6  2  20 8F D7           JSR   LAB_GTBY          ; y1
00E7F9  2  8E 17 A0           STX   VGC_P6             ; y1 low
00E7FC  2  A9 00              LDA   #$00
00E7FE  2  8D 18 A0           STA   VGC_P7             ; y1 high = 0
00E801  2  A9 03              LDA   #VCMD_LINE        ; LINE command
00E803  2  8D 10 A0           STA   VGC_CMD
00E806  2  60                 RTS
00E807  2               
00E807  2               ; perform CIRCLE cx, cy, r
00E807  2               
00E807  2               LAB_CIRCLE
00E807  2  20 7D D7           JSR   LAB_GTWRD         ; cx as 16-bit
00E80A  2  A5 AF              LDA   FAC1_3
00E80C  2  8D 11 A0           STA   VGC_P0             ; cx low
00E80F  2  A5 AE              LDA   FAC1_2
00E811  2  8D 12 A0           STA   VGC_P1             ; cx high
00E814  2  20 4D CD           JSR   LAB_1C01          ; comma
00E817  2  20 8F D7           JSR   LAB_GTBY          ; cy
00E81A  2  8E 13 A0           STX   VGC_P2             ; cy low
00E81D  2  A9 00              LDA   #$00
00E81F  2  8D 14 A0           STA   VGC_P3             ; cy high = 0
00E822  2  20 4D CD           JSR   LAB_1C01          ; comma
00E825  2  20 7D D7           JSR   LAB_GTWRD         ; r as 16-bit
00E828  2  A5 AF              LDA   FAC1_3
00E82A  2  8D 15 A0           STA   VGC_P4             ; r low
00E82D  2  A5 AE              LDA   FAC1_2
00E82F  2  8D 16 A0           STA   VGC_P5             ; r high
00E832  2  A9 04              LDA   #VCMD_CIRCLE      ; CIRCLE command
00E834  2  8D 10 A0           STA   VGC_CMD
00E837  2  60                 RTS
00E838  2               
00E838  2               ; perform RECT x0, y0, x1, y1
00E838  2               
00E838  2               LAB_RECT
00E838  2  20 7D D7           JSR   LAB_GTWRD         ; x0 as 16-bit
00E83B  2  A5 AF              LDA   FAC1_3
00E83D  2  8D 11 A0           STA   VGC_P0             ; x0 low
00E840  2  A5 AE              LDA   FAC1_2
00E842  2  8D 12 A0           STA   VGC_P1             ; x0 high
00E845  2  20 4D CD           JSR   LAB_1C01          ; comma
00E848  2  20 8F D7           JSR   LAB_GTBY          ; y0
00E84B  2  8E 13 A0           STX   VGC_P2             ; y0 low
00E84E  2  A9 00              LDA   #$00
00E850  2  8D 14 A0           STA   VGC_P3             ; y0 high = 0
00E853  2  20 4D CD           JSR   LAB_1C01          ; comma
00E856  2  20 7D D7           JSR   LAB_GTWRD         ; x1 as 16-bit
00E859  2  A5 AF              LDA   FAC1_3
00E85B  2  8D 15 A0           STA   VGC_P4             ; x1 low
00E85E  2  A5 AE              LDA   FAC1_2
00E860  2  8D 16 A0           STA   VGC_P5             ; x1 high
00E863  2  20 4D CD           JSR   LAB_1C01          ; comma
00E866  2  20 8F D7           JSR   LAB_GTBY          ; y1
00E869  2  8E 17 A0           STX   VGC_P6             ; y1 low
00E86C  2  A9 00              LDA   #$00
00E86E  2  8D 18 A0           STA   VGC_P7             ; y1 high = 0
00E871  2  A9 05              LDA   #VCMD_RECT        ; RECT command
00E873  2  8D 10 A0           STA   VGC_CMD
00E876  2  60                 RTS
00E877  2               
00E877  2               ; perform FILL x0, y0, x1, y1
00E877  2               
00E877  2               LAB_FILLRECT
00E877  2  20 7D D7           JSR   LAB_GTWRD         ; x0 as 16-bit
00E87A  2  A5 AF              LDA   FAC1_3
00E87C  2  8D 11 A0           STA   VGC_P0             ; x0 low
00E87F  2  A5 AE              LDA   FAC1_2
00E881  2  8D 12 A0           STA   VGC_P1             ; x0 high
00E884  2  20 4D CD           JSR   LAB_1C01          ; comma
00E887  2  20 8F D7           JSR   LAB_GTBY          ; y0
00E88A  2  8E 13 A0           STX   VGC_P2             ; y0 low
00E88D  2  A9 00              LDA   #$00
00E88F  2  8D 14 A0           STA   VGC_P3             ; y0 high = 0
00E892  2  20 4D CD           JSR   LAB_1C01          ; comma
00E895  2  20 7D D7           JSR   LAB_GTWRD         ; x1 as 16-bit
00E898  2  A5 AF              LDA   FAC1_3
00E89A  2  8D 15 A0           STA   VGC_P4             ; x1 low
00E89D  2  A5 AE              LDA   FAC1_2
00E89F  2  8D 16 A0           STA   VGC_P5             ; x1 high
00E8A2  2  20 4D CD           JSR   LAB_1C01          ; comma
00E8A5  2  20 8F D7           JSR   LAB_GTBY          ; y1
00E8A8  2  8E 17 A0           STX   VGC_P6             ; y1 low
00E8AB  2  A9 00              LDA   #$00
00E8AD  2  8D 18 A0           STA   VGC_P7             ; y1 high = 0
00E8B0  2  A9 06              LDA   #VCMD_FILL        ; FILL command
00E8B2  2  8D 10 A0           STA   VGC_CMD
00E8B5  2  60                 RTS
00E8B6  2               
00E8B6  2               ; perform PAINT x, y
00E8B6  2               
00E8B6  2               LAB_PAINT
00E8B6  2  20 7D D7           JSR   LAB_GTWRD         ; get x (0-319) as 16-bit
00E8B9  2  A5 AF              LDA   FAC1_3
00E8BB  2  8D 11 A0           STA   VGC_P0             ; x low
00E8BE  2  A5 AE              LDA   FAC1_2
00E8C0  2  8D 12 A0           STA   VGC_P1             ; x high
00E8C3  2  20 4D CD           JSR   LAB_1C01          ; require comma
00E8C6  2  20 8F D7           JSR   LAB_GTBY          ; get y (0-199)
00E8C9  2  8E 13 A0           STX   VGC_P2             ; y low
00E8CC  2  A9 00              LDA   #$00
00E8CE  2  8D 14 A0           STA   VGC_P3             ; y high = 0
00E8D1  2  A9 09              LDA   #VCMD_PAINT       ; PAINT command
00E8D3  2  8D 10 A0           STA   VGC_CMD
00E8D6  2  60                 RTS
00E8D7  2               
00E8D7  2               ; perform SPRITE n, ON/OFF  or  SPRITE n, x, y
00E8D7  2               ; sprite number 0-15, ON/OFF enables/disables, x,y sets position
00E8D7  2               ; Uses command-driven VGC interface:
00E8D7  2               ;   SPRENA ($15): P0=sprite
00E8D7  2               ;   SPRDIS ($16): P0=sprite
00E8D7  2               ;   SPRPOS ($14): P0=sprite, P1=x_low, P2=x_high, P3=y_low, P4=y_high
00E8D7  2               
00E8D7  2               LAB_SPRCMD
00E8D7  2  20 8F D7           JSR   LAB_GTBY          ; get sprite number (0-15) in X
00E8DA  2  86 11              STX   Itempl            ; save sprite number
00E8DC  2  20 4D CD           JSR   LAB_1C01          ; require comma
00E8DF  2  20 C2 00           JSR   LAB_GBYT          ; peek at next token
00E8E2  2  C9 93              CMP   #TK_ON            ; is it ON?
00E8E4  2  F0 2C              BEQ   @spr_on
00E8E6  2  C9 CB              CMP   #TK_OFF           ; is it OFF?
00E8E8  2  F0 36              BEQ   @spr_off
00E8EA  2                     ; not ON/OFF — parse x, y position
00E8EA  2  A5 11              LDA   Itempl            ; get sprite number
00E8EC  2  8D 11 A0           STA   VGC_P0             ; P0 = sprite index
00E8EF  2  20 86 D7           JSR   LAB_GTSW          ; get signed x as 16-bit
00E8F2  2  A5 AF              LDA   FAC1_3
00E8F4  2  8D 12 A0           STA   VGC_P1             ; P1 = x low
00E8F7  2  A5 AE              LDA   FAC1_2
00E8F9  2  8D 13 A0           STA   VGC_P2             ; P2 = x high
00E8FC  2  20 4D CD           JSR   LAB_1C01          ; require comma
00E8FF  2  20 86 D7           JSR   LAB_GTSW          ; get signed y as 16-bit
00E902  2  A5 AF              LDA   FAC1_3
00E904  2  8D 14 A0           STA   VGC_P3             ; P3 = y low
00E907  2  A5 AE              LDA   FAC1_2
00E909  2  8D 15 A0           STA   VGC_P4             ; P4 = y high
00E90C  2  A9 14              LDA   #VCMD_SPRPOS      ; SPRPOS command
00E90E  2  8D 10 A0           STA   VGC_CMD            ; trigger
00E911  2  60                 RTS
00E912  2               
00E912  2               @spr_on
00E912  2  20 BC 00           JSR   LAB_IGBY          ; consume the ON token
00E915  2  A5 11              LDA   Itempl            ; get sprite number
00E917  2  8D 11 A0           STA   VGC_P0             ; P0 = sprite index
00E91A  2  A9 15              LDA   #VCMD_SPRENA      ; SPRENA command
00E91C  2  8D 10 A0           STA   VGC_CMD            ; trigger
00E91F  2  60                 RTS
00E920  2               
00E920  2               @spr_off
00E920  2  20 BC 00           JSR   LAB_IGBY          ; consume the OFF token
00E923  2  A5 11              LDA   Itempl            ; get sprite number
00E925  2  8D 11 A0           STA   VGC_P0             ; P0 = sprite index
00E928  2  A9 16              LDA   #VCMD_SPRDIS      ; SPRDIS command
00E92A  2  8D 10 A0           STA   VGC_CMD            ; trigger
00E92D  2  60                 RTS
00E92E  2               
00E92E  2               ; perform SPRITESHAPE n, shape
00E92E  2               ; Writes shape index to sprite register $A044 + n*8
00E92E  2               
00E92E  2               LAB_SPRSHAPE
00E92E  2  20 8F D7           JSR   LAB_GTBY          ; get sprite number (0-15) in X
00E931  2  8A                 TXA
00E932  2  0A                 ASL                     ; *2
00E933  2  0A                 ASL                     ; *4
00E934  2  0A                 ASL                     ; *8
00E935  2  A8                 TAY                     ; Y = sprite * 8
00E936  2  20 4D CD           JSR   LAB_1C01          ; require comma
00E939  2  20 8F D7           JSR   LAB_GTBY          ; get shape index in X
00E93C  2  8A                 TXA
00E93D  2  99 44 A0           STA   $A044,Y           ; write to shape register ($A044 + n*8)
00E940  2  60                 RTS
00E941  2               
00E941  2               ; perform SPRITESET sprite, field, value — set sprite register with vblank sync
00E941  2               ; Fields 0 (X) and 2 (Y) accept a signed word and write both lo/hi bytes.
00E941  2               ; All other fields accept a byte value.
00E941  2               ; Waits for vblank before writing to avoid visual glitching.
00E941  2               
00E941  2               LAB_SPRCOLOR
00E941  2  20 8F D7           JSR   LAB_GTBY          ; get sprite number (0-15) in X
00E944  2  8A                 TXA
00E945  2  0A                 ASL                     ; *2
00E946  2  0A                 ASL                     ; *4
00E947  2  0A                 ASL                     ; *8
00E948  2  85 11              STA   Itempl            ; save base offset (sprite * 8)
00E94A  2  20 4D CD           JSR   LAB_1C01          ; require comma
00E94D  2  20 8F D7           JSR   LAB_GTBY          ; get field (0-7) in X
00E950  2  86 12              STX   Itemph            ; save field number
00E952  2  8A                 TXA
00E953  2  18                 CLC
00E954  2  65 11              ADC   Itempl            ; base + field = register offset
00E956  2  85 11              STA   Itempl            ; save register offset
00E958  2  20 4D CD           JSR   LAB_1C01          ; require comma
00E95B  2  A5 12              LDA   Itemph            ; check field number
00E95D  2  C9 00              CMP   #$00              ; field 0 = X position?
00E95F  2  F0 16              BEQ   @word_val
00E961  2  C9 02              CMP   #$02              ; field 2 = Y position?
00E963  2  F0 12              BEQ   @word_val
00E965  2                     ; --- byte field: parse byte value ---
00E965  2  20 8F D7           JSR   LAB_GTBY          ; get value (0-255) in X
00E968  2  AD 08 A0           LDA   VGC_FRAME         ; wait for vblank
00E96B  2               @bwait
00E96B  2  CD 08 A0           CMP   VGC_FRAME
00E96E  2  F0 FB              BEQ   @bwait
00E970  2  A4 11              LDY   Itempl            ; Y = register offset
00E972  2  8A                 TXA                     ; A = value
00E973  2  99 40 A0           STA   $A040,Y           ; write to sprite register
00E976  2  60                 RTS
00E977  2               @word_val
00E977  2                     ; --- word field (X or Y): parse signed word, write lo+hi ---
00E977  2  20 86 D7           JSR   LAB_GTSW          ; get signed 16-bit value, lo in FAC1_3, hi in FAC1_2
00E97A  2  AD 08 A0           LDA   VGC_FRAME         ; wait for vblank
00E97D  2               @wwait
00E97D  2  CD 08 A0           CMP   VGC_FRAME
00E980  2  F0 FB              BEQ   @wwait
00E982  2  A4 11              LDY   Itempl            ; Y = register offset (points to lo byte)
00E984  2  A5 AF              LDA   FAC1_3            ; low byte
00E986  2  99 40 A0           STA   $A040,Y           ; write lo
00E989  2  C8                 INY
00E98A  2  A5 AE              LDA   FAC1_2            ; high byte
00E98C  2  99 40 A0           STA   $A040,Y           ; write hi
00E98F  2  60                 RTS
00E990  2               
00E990  2               ; perform SPRITEDATA sprite, row, b1, b2 [, b3 [, b4 [, b5 [, b6 [, b7 [, b8]]]]]]
00E990  2               ; Uses CmdSprRow ($11): P0=sprite, P1=row, P2-P9=8 bytes of row data.
00E990  2               ; Unprovided bytes are zeroed.
00E990  2               
00E990  2               LAB_SPRDATA
00E990  2  20 8F D7           JSR   LAB_GTBY          ; get sprite number (0-15) in X
00E993  2  8E 11 A0           STX   VGC_P0             ; P0 = sprite index
00E996  2  20 4D CD           JSR   LAB_1C01          ; comma
00E999  2  20 8F D7           JSR   LAB_GTBY          ; get row (0-15) in X
00E99C  2  8E 12 A0           STX   VGC_P1             ; P1 = row
00E99F  2                     ; zero all 8 data bytes first
00E99F  2  A9 00              LDA   #$00
00E9A1  2  8D 13 A0           STA   VGC_P2
00E9A4  2  8D 14 A0           STA   VGC_P3
00E9A7  2  8D 15 A0           STA   VGC_P4
00E9AA  2  8D 16 A0           STA   VGC_P5
00E9AD  2  8D 17 A0           STA   VGC_P6
00E9B0  2  8D 18 A0           STA   VGC_P7
00E9B3  2  8D 19 A0           STA   VGC_P8
00E9B6  2  8D 1A A0           STA   VGC_P9
00E9B9  2                     ; parse b1 (required)
00E9B9  2  20 4D CD           JSR   LAB_1C01          ; comma
00E9BC  2  20 8F D7           JSR   LAB_GTBY          ; b1 → X
00E9BF  2  8E 13 A0           STX   VGC_P2
00E9C2  2                     ; parse b2 (required)
00E9C2  2  20 4D CD           JSR   LAB_1C01          ; comma
00E9C5  2  20 8F D7           JSR   LAB_GTBY          ; b2 → X
00E9C8  2  8E 14 A0           STX   VGC_P3
00E9CB  2                     ; parse optional b3-b8
00E9CB  2  20 C2 00           JSR   LAB_GBYT
00E9CE  2  C9 2C              CMP   #','
00E9D0  2  D0 59              BNE   @sd_done
00E9D2  2  20 BC 00           JSR   LAB_IGBY          ; skip comma
00E9D5  2  20 8F D7           JSR   LAB_GTBY          ; b3 → X
00E9D8  2  8E 15 A0           STX   VGC_P4
00E9DB  2  20 C2 00           JSR   LAB_GBYT
00E9DE  2  C9 2C              CMP   #','
00E9E0  2  D0 49              BNE   @sd_done
00E9E2  2  20 BC 00           JSR   LAB_IGBY
00E9E5  2  20 8F D7           JSR   LAB_GTBY          ; b4 → X
00E9E8  2  8E 16 A0           STX   VGC_P5
00E9EB  2  20 C2 00           JSR   LAB_GBYT
00E9EE  2  C9 2C              CMP   #','
00E9F0  2  D0 39              BNE   @sd_done
00E9F2  2  20 BC 00           JSR   LAB_IGBY
00E9F5  2  20 8F D7           JSR   LAB_GTBY          ; b5 → X
00E9F8  2  8E 17 A0           STX   VGC_P6
00E9FB  2  20 C2 00           JSR   LAB_GBYT
00E9FE  2  C9 2C              CMP   #','
00EA00  2  D0 29              BNE   @sd_done
00EA02  2  20 BC 00           JSR   LAB_IGBY
00EA05  2  20 8F D7           JSR   LAB_GTBY          ; b6 → X
00EA08  2  8E 18 A0           STX   VGC_P7
00EA0B  2  20 C2 00           JSR   LAB_GBYT
00EA0E  2  C9 2C              CMP   #','
00EA10  2  D0 19              BNE   @sd_done
00EA12  2  20 BC 00           JSR   LAB_IGBY
00EA15  2  20 8F D7           JSR   LAB_GTBY          ; b7 → X
00EA18  2  8E 19 A0           STX   VGC_P8
00EA1B  2  20 C2 00           JSR   LAB_GBYT
00EA1E  2  C9 2C              CMP   #','
00EA20  2  D0 09              BNE   @sd_done
00EA22  2  20 BC 00           JSR   LAB_IGBY
00EA25  2  20 8F D7           JSR   LAB_GTBY          ; b8 → X
00EA28  2  8E 1A A0           STX   VGC_P9
00EA2B  2               @sd_done
00EA2B  2  A9 11              LDA   #VCMD_SPRROW      ; CmdSprRow command
00EA2D  2  8D 10 A0           STA   VGC_CMD            ; trigger
00EA30  2  60                 RTS
00EA31  2               
00EA31  2               ; perform SOUND note, duration [, instrument]
00EA31  2               ; SOUND 60, 10          — MIDI note 60, 10 frames, default instrument 0
00EA31  2               ; SOUND 60, 10, 3       — MIDI note 60, 10 frames, instrument 3
00EA31  2               
00EA31  2               LAB_SOUND
00EA31  2  20 8F D7           JSR   LAB_GTBY          ; midi note → X
00EA34  2  8E A4 B9           STX   FIO_SRCL          ; note
00EA37  2  20 4D CD           JSR   LAB_1C01          ; comma
00EA3A  2  20 8F D7           JSR   LAB_GTBY          ; duration → X
00EA3D  2  8E A5 B9           STX   FIO_SRCH          ; duration
00EA40  2  A9 00              LDA   #$00
00EA42  2  8D A6 B9           STA   FIO_ENDL          ; default instrument = 0
00EA45  2  20 C2 00           JSR   LAB_GBYT          ; peek next token
00EA48  2  C9 2C              CMP   #','
00EA4A  2  D0 09              BNE   @snd_go
00EA4C  2  20 BC 00           JSR   LAB_IGBY          ; skip comma
00EA4F  2  20 8F D7           JSR   LAB_GTBY          ; instrument id → X
00EA52  2  8E A6 B9           STX   FIO_ENDL
00EA55  2               @snd_go
00EA55  2  A9 0B              LDA   #FIO_CMD_SOUND
00EA57  2  8D A0 B9           STA   FIO_CMD
00EA5A  2  60                 RTS
00EA5B  2               
00EA5B  2               ; perform VOLUME level (0-15)
00EA5B  2               
00EA5B  2               LAB_VOLUME
00EA5B  2  20 8F D7           JSR   LAB_GTBY          ; level → X
00EA5E  2  8E A4 B9           STX   FIO_SRCL
00EA61  2  A9 0C              LDA   #FIO_CMD_VOLUME
00EA63  2  8D A0 B9           STA   FIO_CMD
00EA66  2  60                 RTS
00EA67  2               
00EA67  2               ; perform INSTRUMENT id, waveform, a, d, s, r
00EA67  2               ; Waveform: $10=TRI, $20=SAW, $40=PULSE, $80=NOISE
00EA67  2               ; INSTRUMENT 1, $40, 0, 9, 0, 0
00EA67  2               
00EA67  2               LAB_ENVELOPE
00EA67  2  20 8F D7           JSR   LAB_GTBY          ; id → X
00EA6A  2  8E A4 B9           STX   FIO_SRCL
00EA6D  2  20 4D CD           JSR   LAB_1C01          ; comma
00EA70  2  20 8F D7           JSR   LAB_GTBY          ; waveform → X
00EA73  2  8E A5 B9           STX   FIO_SRCH
00EA76  2  20 4D CD           JSR   LAB_1C01          ; comma
00EA79  2  20 8F D7           JSR   LAB_GTBY          ; attack → X
00EA7C  2  8E A6 B9           STX   FIO_ENDL
00EA7F  2  20 4D CD           JSR   LAB_1C01          ; comma
00EA82  2  20 8F D7           JSR   LAB_GTBY          ; decay → X
00EA85  2  8E A7 B9           STX   FIO_ENDH
00EA88  2  20 4D CD           JSR   LAB_1C01          ; comma
00EA8B  2  20 8F D7           JSR   LAB_GTBY          ; sustain → X
00EA8E  2  8E A8 B9           STX   FIO_SIZEL
00EA91  2  20 4D CD           JSR   LAB_1C01          ; comma
00EA94  2  20 8F D7           JSR   LAB_GTBY          ; release → X
00EA97  2  8E A9 B9           STX   FIO_SIZEH
00EA9A  2  A9 0A              LDA   #FIO_CMD_INSTRUMENT
00EA9C  2  8D A0 B9           STA   FIO_CMD
00EA9F  2  60                 RTS
00EAA0  2               
00EAA0  2               ; WAVE is deprecated — use INSTRUMENT instead
00EAA0  2               
00EAA0  2               LAB_WAVE
00EAA0  2  4C 78 C5           JMP   LAB_15D9          ; syntax error
00EAA3  2               
00EAA3  2               ; perform VSYNC — wait for next frame (vblank sync)
00EAA3  2               
00EAA3  2               LAB_VSYNC
00EAA3  2  AD 08 A0           LDA   VGC_FRAME         ; read current frame counter
00EAA6  2               @wait
00EAA6  2  CD 08 A0           CMP   VGC_FRAME         ; has it changed?
00EAA9  2  F0 FB              BEQ   @wait             ; no — spin until next frame
00EAAB  2  60                 RTS
00EAAC  2               
00EAAC  2               ; --- VGC function handlers ---
00EAAC  2               
00EAAC  2               ; perform SPRITEX(n) — return X position of sprite n as signed word
00EAAC  2               
00EAAC  2               LAB_SPRITEX
00EAAC  2  20 ED D7           JSR   LAB_F2FX          ; convert FAC1 to integer, low byte in Itempl
00EAAF  2  A5 11              LDA   Itempl            ; get sprite number
00EAB1  2  0A                 ASL                     ; *2
00EAB2  2  0A                 ASL                     ; *4
00EAB3  2  0A                 ASL                     ; *8
00EAB4  2  AA                 TAX                     ; X = sprite * 8
00EAB5  2  BC 40 A0           LDY   $A040,X           ; Y = X position low byte
00EAB8  2  BD 41 A0           LDA   $A041,X           ; A = X position high byte
00EABB  2  4C 44 D3           JMP   LAB_AYFC          ; return AY as signed integer
00EABE  2               
00EABE  2               ; perform SPRITEY(n) — return Y position of sprite n as signed word
00EABE  2               
00EABE  2               LAB_SPRITEY
00EABE  2  20 ED D7           JSR   LAB_F2FX          ; convert FAC1 to integer, low byte in Itempl
00EAC1  2  A5 11              LDA   Itempl            ; get sprite number
00EAC3  2  0A                 ASL                     ; *2
00EAC4  2  0A                 ASL                     ; *4
00EAC5  2  0A                 ASL                     ; *8
00EAC6  2  AA                 TAX                     ; X = sprite * 8
00EAC7  2  BC 42 A0           LDY   $A042,X           ; Y = Y position low byte
00EACA  2  BD 43 A0           LDA   $A043,X           ; A = Y position high byte
00EACD  2  4C 44 D3           JMP   LAB_AYFC          ; return AY as signed integer
00EAD0  2               
00EAD0  2               ; perform COLLISION(n) — return sprite-sprite collision register
00EAD0  2               ; argument already consumed by preprocessor
00EAD0  2               
00EAD0  2               LAB_COLLISION
00EAD0  2  A9 00              LDA   #$00              ; high byte = 0
00EAD2  2  AC 0B A0           LDY   VGC_COLLST        ; read collision register
00EAD5  2  4C 44 D3           JMP   LAB_AYFC
00EAD8  2               
00EAD8  2               ; perform BUMPED(n) — return sprite-background collision register
00EAD8  2               
00EAD8  2               LAB_BUMPED
00EAD8  2  A9 00              LDA   #$00
00EADA  2  AC 0C A0           LDY   VGC_COLLBG
00EADD  2  4C 44 D3           JMP   LAB_AYFC
00EAE0  2               
00EAE0  2               ; --- File I/O command handlers ---
00EAE0  2               
00EAE0  2               ; perform SAVE "filename"                     (program save)
00EAE0  2               ; or      SAVE "filename", address, length    (raw block save)
00EAE0  2               
00EAE0  2               LAB_FSAVE
00EAE0  2  20 69 F2           JSR   LAB_FIO_GETNAME   ; parse filename expression into FIO_NAME
00EAE3  2  90 03              BCC   @sv_have_name
00EAE5  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00EAE8  2               @sv_have_name
00EAE8  2  20 C2 00           JSR   LAB_GBYT          ; peek at next token
00EAEB  2  C9 2C              CMP   #','
00EAED  2  F0 17              BEQ   @sv_raw
00EAEF  2                     ; default: save BASIC program area
00EAEF  2  A5 79              LDA   Smeml
00EAF1  2  8D A4 B9           STA   FIO_SRCL
00EAF4  2  A5 7A              LDA   Smemh
00EAF6  2  8D A5 B9           STA   FIO_SRCH
00EAF9  2  A5 7B              LDA   Svarl
00EAFB  2  8D A6 B9           STA   FIO_ENDL
00EAFE  2  A5 7C              LDA   Svarh
00EB00  2  8D A7 B9           STA   FIO_ENDH
00EB03  2  4C 2D EB           JMP   @sv_go
00EB06  2               @sv_raw
00EB06  2  20 4D CD           JSR   LAB_1C01          ; comma
00EB09  2  20 7D D7           JSR   LAB_GTWRD         ; source address
00EB0C  2  A5 AF              LDA   FAC1_3
00EB0E  2  8D A4 B9           STA   FIO_SRCL
00EB11  2  A5 AE              LDA   FAC1_2
00EB13  2  8D A5 B9           STA   FIO_SRCH
00EB16  2  20 4D CD           JSR   LAB_1C01          ; comma
00EB19  2  20 7D D7           JSR   LAB_GTWRD         ; length
00EB1C  2  18                 CLC
00EB1D  2  AD A4 B9           LDA   FIO_SRCL
00EB20  2  65 AF              ADC   FAC1_3
00EB22  2  8D A6 B9           STA   FIO_ENDL
00EB25  2  AD A5 B9           LDA   FIO_SRCH
00EB28  2  65 AE              ADC   FAC1_2
00EB2A  2  8D A7 B9           STA   FIO_ENDH
00EB2D  2               @sv_go
00EB2D  2  A9 01              LDA   #FIO_CMD_SAVE
00EB2F  2  8D A0 B9           STA   FIO_CMD
00EB32  2                     ; check status
00EB32  2  AD A1 B9           LDA   FIO_STATUS
00EB35  2  C9 02              CMP   #FIO_OK
00EB37  2  F0 03              BEQ   @sv_ok
00EB39  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00EB3C  2               @sv_ok
00EB3C  2  60                 RTS
00EB3D  2               
00EB3D  2               ; perform LOAD "filename"             (program load)
00EB3D  2               ; or      LOAD "filename", address    (raw block load)
00EB3D  2               
00EB3D  2               LAB_FLOAD
00EB3D  2  20 69 F2           JSR   LAB_FIO_GETNAME   ; parse filename expression into FIO_NAME
00EB40  2  90 03              BCC   @ld_have_name
00EB42  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00EB45  2               @ld_have_name
00EB45  2  A9 00              LDA   #$00              ; load mode: 0=program, 1=raw
00EB47  2  85 78              STA   TempB
00EB49  2  20 C2 00           JSR   LAB_GBYT          ; peek for optional ",address"
00EB4C  2  C9 2C              CMP   #','
00EB4E  2  F0 0D              BEQ   @ld_raw
00EB50  2                     ; default: load BASIC program at start of program memory
00EB50  2  A5 79              LDA   Smeml
00EB52  2  8D A4 B9           STA   FIO_SRCL
00EB55  2  A5 7A              LDA   Smemh
00EB57  2  8D A5 B9           STA   FIO_SRCH
00EB5A  2  4C 71 EB           JMP   @ld_go
00EB5D  2               @ld_raw
00EB5D  2  20 4D CD           JSR   LAB_1C01          ; comma
00EB60  2  20 7D D7           JSR   LAB_GTWRD         ; destination address
00EB63  2  A5 AF              LDA   FAC1_3
00EB65  2  8D A4 B9           STA   FIO_SRCL
00EB68  2  A5 AE              LDA   FAC1_2
00EB6A  2  8D A5 B9           STA   FIO_SRCH
00EB6D  2  A9 01              LDA   #$01
00EB6F  2  85 78              STA   TempB
00EB71  2               @ld_go
00EB71  2  A9 02              LDA   #FIO_CMD_LOAD
00EB73  2  8D A0 B9           STA   FIO_CMD
00EB76  2                     ; check status
00EB76  2  AD A1 B9           LDA   FIO_STATUS
00EB79  2  C9 02              CMP   #FIO_OK
00EB7B  2  D0 23              BNE   @ld_chk_err
00EB7D  2  A5 78              LDA   TempB
00EB7F  2  D0 1E              BNE   @ld_raw_ok
00EB81  2                     ; success — update Svarl/Svarh = Smeml + FIO_SIZE
00EB81  2  18                 CLC
00EB82  2  A5 79              LDA   Smeml
00EB84  2  6D A8 B9           ADC   FIO_SIZEL
00EB87  2  85 7B              STA   Svarl
00EB89  2  A5 7A              LDA   Smemh
00EB8B  2  6D A9 B9           ADC   FIO_SIZEH
00EB8E  2  85 7C              STA   Svarh
00EB90  2                     ; reset array/var pointers so LIST works correctly
00EB90  2  A5 7B              LDA   Svarl
00EB92  2  85 7D              STA   Sarryl
00EB94  2  85 7F              STA   Earryl
00EB96  2  A5 7C              LDA   Svarh
00EB98  2  85 7E              STA   Sarryh
00EB9A  2  85 80              STA   Earryh
00EB9C  2  4C 67 C1           JMP   LAB_1274          ; print Ready, return to command loop
00EB9F  2               @ld_raw_ok
00EB9F  2  60                 RTS
00EBA0  2               @ld_chk_err
00EBA0  2  AD A2 B9           LDA   FIO_ERRCODE
00EBA3  2  C9 01              CMP   #$01              ; not found?
00EBA5  2  D0 03              BNE   @ld_errio
00EBA7  2  4C 8F F2           JMP   LAB_FIO_ERRFNF
00EBAA  2               @ld_errio
00EBAA  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00EBAD  2               
00EBAD  2               ; perform GSAVE "filename", space, offset, length
00EBAD  2               
00EBAD  2               LAB_GSAVE
00EBAD  2  20 69 F2           JSR   LAB_FIO_GETNAME
00EBB0  2  90 03              BCC   @gs_have_name
00EBB2  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00EBB5  2               @gs_have_name
00EBB5  2  20 4D CD           JSR   LAB_1C01          ; comma
00EBB8  2  20 8F D7           JSR   LAB_GTBY          ; graphics space id
00EBBB  2  8E AA B9           STX   FIO_GSPACE
00EBBE  2  20 4D CD           JSR   LAB_1C01          ; comma
00EBC1  2  20 7D D7           JSR   LAB_GTWRD         ; graphics offset
00EBC4  2  A5 AF              LDA   FAC1_3
00EBC6  2  8D AB B9           STA   FIO_GADDRL
00EBC9  2  A5 AE              LDA   FAC1_2
00EBCB  2  8D AC B9           STA   FIO_GADDRH
00EBCE  2  20 4D CD           JSR   LAB_1C01          ; comma
00EBD1  2  20 7D D7           JSR   LAB_GTWRD         ; graphics length
00EBD4  2  A5 AF              LDA   FAC1_3
00EBD6  2  8D AD B9           STA   FIO_GLENL
00EBD9  2  A5 AE              LDA   FAC1_2
00EBDB  2  8D AE B9           STA   FIO_GLENH
00EBDE  2  A9 06              LDA   #FIO_CMD_GSAVE
00EBE0  2  8D A0 B9           STA   FIO_CMD
00EBE3  2  AD A1 B9           LDA   FIO_STATUS
00EBE6  2  C9 02              CMP   #FIO_OK
00EBE8  2  F0 03              BEQ   @gs_ok
00EBEA  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00EBED  2               @gs_ok
00EBED  2  60                 RTS
00EBEE  2               
00EBEE  2               ; perform GLOAD "filename", space, offset [,length]
00EBEE  2               
00EBEE  2               LAB_GLOAD
00EBEE  2  20 69 F2           JSR   LAB_FIO_GETNAME
00EBF1  2  90 03              BCC   @gl_have_name
00EBF3  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00EBF6  2               @gl_have_name
00EBF6  2  20 4D CD           JSR   LAB_1C01          ; comma
00EBF9  2  20 8F D7           JSR   LAB_GTBY          ; graphics space id
00EBFC  2  8E AA B9           STX   FIO_GSPACE
00EBFF  2  20 4D CD           JSR   LAB_1C01          ; comma
00EC02  2  20 7D D7           JSR   LAB_GTWRD         ; graphics offset
00EC05  2  A5 AF              LDA   FAC1_3
00EC07  2  8D AB B9           STA   FIO_GADDRL
00EC0A  2  A5 AE              LDA   FAC1_2
00EC0C  2  8D AC B9           STA   FIO_GADDRH
00EC0F  2  A9 00              LDA   #$00              ; default: load full file
00EC11  2  8D AD B9           STA   FIO_GLENL
00EC14  2  8D AE B9           STA   FIO_GLENH
00EC17  2  20 C2 00           JSR   LAB_GBYT          ; optional comma,length
00EC1A  2  C9 2C              CMP   #','
00EC1C  2  D0 10              BNE   @gl_go
00EC1E  2  20 4D CD           JSR   LAB_1C01
00EC21  2  20 7D D7           JSR   LAB_GTWRD
00EC24  2  A5 AF              LDA   FAC1_3
00EC26  2  8D AD B9           STA   FIO_GLENL
00EC29  2  A5 AE              LDA   FAC1_2
00EC2B  2  8D AE B9           STA   FIO_GLENH
00EC2E  2               @gl_go
00EC2E  2  A9 07              LDA   #FIO_CMD_GLOAD
00EC30  2  8D A0 B9           STA   FIO_CMD
00EC33  2  AD A1 B9           LDA   FIO_STATUS
00EC36  2  C9 02              CMP   #FIO_OK
00EC38  2  D0 01              BNE   @gl_chk_err
00EC3A  2  60                 RTS
00EC3B  2               @gl_chk_err
00EC3B  2  AD A2 B9           LDA   FIO_ERRCODE
00EC3E  2  C9 01              CMP   #$01              ; not found?
00EC40  2  D0 03              BNE   @gl_errio
00EC42  2  4C 8F F2           JMP   LAB_FIO_ERRFNF
00EC45  2               @gl_errio
00EC45  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00EC48  2               
00EC48  2               ; perform SIDPLAY "filename" [, song]
00EC48  2               
00EC48  2               LAB_SIDPLAY
00EC48  2  20 69 F2           JSR   LAB_FIO_GETNAME   ; parse filename → FIO_NAME/FIO_NAMELEN
00EC4B  2  90 03              BCC   @sp_have_name
00EC4D  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00EC50  2               @sp_have_name
00EC50  2  A9 01              LDA   #$01              ; default song = 1
00EC52  2  8D A4 B9           STA   FIO_SRCL
00EC55  2  20 C2 00           JSR   LAB_GBYT          ; peek next token
00EC58  2  C9 2C              CMP   #','
00EC5A  2  D0 09              BNE   @sp_go
00EC5C  2  20 4D CD           JSR   LAB_1C01          ; consume comma
00EC5F  2  20 8F D7           JSR   LAB_GTBY          ; evaluate song number → X
00EC62  2  8E A4 B9           STX   FIO_SRCL
00EC65  2               @sp_go
00EC65  2  A9 08              LDA   #FIO_CMD_SIDPLAY
00EC67  2  8D A0 B9           STA   FIO_CMD
00EC6A  2  AD A1 B9           LDA   FIO_STATUS
00EC6D  2  C9 02              CMP   #FIO_OK
00EC6F  2  D0 02              BNE   @sp_chk_err
00EC71  2  58                 CLI                     ; enable interrupts so timer IRQ can fire
00EC72  2  60                 RTS
00EC73  2               @sp_chk_err
00EC73  2  AD A2 B9           LDA   FIO_ERRCODE
00EC76  2  C9 01              CMP   #$01              ; not found?
00EC78  2  D0 03              BNE   @sp_errio
00EC7A  2  4C 8F F2           JMP   LAB_FIO_ERRFNF
00EC7D  2               @sp_errio
00EC7D  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00EC80  2               
00EC80  2               ; perform SIDSTOP
00EC80  2               
00EC80  2               LAB_SIDSTOP
00EC80  2  A9 09              LDA   #FIO_CMD_SIDSTOP
00EC82  2  8D A0 B9           STA   FIO_CMD
00EC85  2  60                 RTS
00EC86  2               
00EC86  2               ; perform MUSIC subcommand
00EC86  2               ; MUSIC voice, "mml"
00EC86  2               ; MUSIC PLAY | STOP | TEMPO bpm | LOOP ON|OFF | PRIORITY v1[,v2[,v3]]
00EC86  2               
00EC86  2               LAB_MUSIC
00EC86  2  20 C2 00           JSR   LAB_GBYT          ; peek next byte (after MUSIC token consumed)
00EC89  2  C9 50              CMP   #'P'
00EC8B  2  F0 0F              BEQ   @m_chk_p
00EC8D  2  C9 92              CMP   #TK_STOP           ; STOP is tokenized by BASIC
00EC8F  2  F0 22              BEQ   @m_stop_tok
00EC91  2  C9 54              CMP   #'T'
00EC93  2  F0 27              BEQ   @m_tempo
00EC95  2  C9 9E              CMP   #TK_LOOP           ; LOOP is tokenized by BASIC
00EC97  2  F0 45              BEQ   @m_loop_tok
00EC99  2                     ; Not a subcommand — must be a number (voice 1-6)
00EC99  2  4C 7F ED           JMP   @m_seq
00EC9C  2               
00EC9C  2               ; --- MUSIC PLAY or PRIORITY ---
00EC9C  2               @m_chk_p
00EC9C  2                     ; Consume P, then check next char to distinguish PLAY vs PRIORITY
00EC9C  2  20 BC 00           JSR   LAB_IGBY          ; consume P, A = next char
00EC9F  2  C9 52              CMP   #'R'              ; PRIORITY has R after P
00ECA1  2  F0 65              BEQ   @m_priority
00ECA3  2                     ; else PLAY — consume remaining "LAY" (3 chars, P already consumed)
00ECA3  2  20 BC 00           JSR   LAB_IGBY          ; L
00ECA6  2  20 BC 00           JSR   LAB_IGBY          ; A
00ECA9  2  20 BC 00           JSR   LAB_IGBY          ; Y
00ECAC  2  A9 0E              LDA   #FIO_CMD_MPLAY
00ECAE  2  8D A0 B9           STA   FIO_CMD
00ECB1  2  58                 CLI                     ; enable interrupts for music
00ECB2  2  60                 RTS
00ECB3  2               
00ECB3  2               ; --- MUSIC STOP (TK_STOP is a single token byte) ---
00ECB3  2               @m_stop_tok
00ECB3  2  20 BC 00           JSR   LAB_IGBY          ; consume TK_STOP token
00ECB6  2  A9 0F              LDA   #FIO_CMD_MSTOP
00ECB8  2  8D A0 B9           STA   FIO_CMD
00ECBB  2  60                 RTS
00ECBC  2               
00ECBC  2               ; --- MUSIC TEMPO bpm ---
00ECBC  2               @m_tempo
00ECBC  2  20 BC 00           JSR   LAB_IGBY          ; T
00ECBF  2  20 BC 00           JSR   LAB_IGBY          ; E
00ECC2  2  20 BC 00           JSR   LAB_IGBY          ; M
00ECC5  2  20 BC 00           JSR   LAB_IGBY          ; P
00ECC8  2  20 BC 00           JSR   LAB_IGBY          ; O
00ECCB  2  20 7D D7           JSR   LAB_GTWRD         ; bpm as 16-bit → FAC1_3(lo), FAC1_2(hi)
00ECCE  2  A5 AF              LDA   FAC1_3
00ECD0  2  8D A4 B9           STA   FIO_SRCL
00ECD3  2  A5 AE              LDA   FAC1_2
00ECD5  2  8D A5 B9           STA   FIO_SRCH
00ECD8  2  A9 10              LDA   #FIO_CMD_MTEMPO
00ECDA  2  8D A0 B9           STA   FIO_CMD
00ECDD  2  60                 RTS
00ECDE  2               
00ECDE  2               ; --- MUSIC LOOP ON|OFF (TK_LOOP is a single token byte) ---
00ECDE  2               @m_loop_tok
00ECDE  2  20 BC 00           JSR   LAB_IGBY          ; consume TK_LOOP token
00ECE1  2  20 C2 00           JSR   LAB_GBYT          ; skip spaces, get TK_ON or TK_OFF
00ECE4  2  C9 93              CMP   #TK_ON
00ECE6  2  F0 07              BEQ   @m_loop_on
00ECE8  2  C9 CB              CMP   #TK_OFF
00ECEA  2  F0 0E              BEQ   @m_loop_off
00ECEC  2  4C 78 C5           JMP   LAB_15D9          ; syntax error
00ECEF  2               @m_loop_on
00ECEF  2  20 BC 00           JSR   LAB_IGBY          ; consume ON token
00ECF2  2  A9 01              LDA   #$01
00ECF4  2  8D A4 B9           STA   FIO_SRCL
00ECF7  2  4C 02 ED           JMP   @m_loop_go
00ECFA  2               @m_loop_off
00ECFA  2  20 BC 00           JSR   LAB_IGBY          ; consume OFF token
00ECFD  2  A9 00              LDA   #$00
00ECFF  2  8D A4 B9           STA   FIO_SRCL
00ED02  2               @m_loop_go
00ED02  2  A9 11              LDA   #FIO_CMD_MLOOP
00ED04  2  8D A0 B9           STA   FIO_CMD
00ED07  2  60                 RTS
00ED08  2               
00ED08  2               ; --- MUSIC PRIORITY v1[,v2[,v3[,v4[,v5[,v6]]]]] ---
00ED08  2               @m_priority
00ED08  2                     ; P already consumed by @m_chk_p.  Skip remaining keyword bytes.
00ED08  2                     ; "RIORITY" is tokenized as R,I,TK_OR,I,T,Y (OR becomes a token),
00ED08  2                     ; so we scan dynamically instead of using a fixed IGBY count.
00ED08  2               @m_pri_skip
00ED08  2  20 BC 00           JSR   LAB_IGBY          ; advance past current byte
00ED0B  2  C9 41              CMP   #'A'              ; letters ($41-$5A) and tokens ($80+) are >= 'A'
00ED0D  2  B0 F9              BCS   @m_pri_skip       ; keep skipping keyword chars and tokens
00ED0F  2                     ; A < 'A': hit a space or digit — keyword is consumed.
00ED0F  2                     ; pointer is at the space/digit; LAB_GTBY calls GBYT which skips spaces.
00ED0F  2                     ; Clear all 6 voice slots first
00ED0F  2  A9 00              LDA   #$00
00ED11  2  8D A4 B9           STA   FIO_SRCL
00ED14  2  8D A5 B9           STA   FIO_SRCH
00ED17  2  8D A6 B9           STA   FIO_ENDL
00ED1A  2  8D A7 B9           STA   FIO_ENDH
00ED1D  2  8D A8 B9           STA   FIO_SIZEL
00ED20  2  8D A9 B9           STA   FIO_SIZEH
00ED23  2  20 8F D7           JSR   LAB_GTBY          ; first voice → X
00ED26  2  8E A4 B9           STX   FIO_SRCL
00ED29  2  20 C2 00           JSR   LAB_GBYT          ; peek
00ED2C  2  C9 2C              CMP   #','
00ED2E  2  D0 49              BNE   @m_pri_go
00ED30  2  20 BC 00           JSR   LAB_IGBY          ; skip comma
00ED33  2  20 8F D7           JSR   LAB_GTBY          ; second voice → X
00ED36  2  8E A5 B9           STX   FIO_SRCH
00ED39  2  20 C2 00           JSR   LAB_GBYT
00ED3C  2  C9 2C              CMP   #','
00ED3E  2  D0 39              BNE   @m_pri_go
00ED40  2  20 BC 00           JSR   LAB_IGBY          ; skip comma
00ED43  2  20 8F D7           JSR   LAB_GTBY          ; third voice → X
00ED46  2  8E A6 B9           STX   FIO_ENDL
00ED49  2  20 C2 00           JSR   LAB_GBYT
00ED4C  2  C9 2C              CMP   #','
00ED4E  2  D0 29              BNE   @m_pri_go
00ED50  2  20 BC 00           JSR   LAB_IGBY          ; skip comma
00ED53  2  20 8F D7           JSR   LAB_GTBY          ; fourth voice → X
00ED56  2  8E A7 B9           STX   FIO_ENDH
00ED59  2  20 C2 00           JSR   LAB_GBYT
00ED5C  2  C9 2C              CMP   #','
00ED5E  2  D0 19              BNE   @m_pri_go
00ED60  2  20 BC 00           JSR   LAB_IGBY          ; skip comma
00ED63  2  20 8F D7           JSR   LAB_GTBY          ; fifth voice → X
00ED66  2  8E A8 B9           STX   FIO_SIZEL
00ED69  2  20 C2 00           JSR   LAB_GBYT
00ED6C  2  C9 2C              CMP   #','
00ED6E  2  D0 09              BNE   @m_pri_go
00ED70  2  20 BC 00           JSR   LAB_IGBY          ; skip comma
00ED73  2  20 8F D7           JSR   LAB_GTBY          ; sixth voice → X
00ED76  2  8E A9 B9           STX   FIO_SIZEH
00ED79  2               @m_pri_go
00ED79  2  A9 12              LDA   #FIO_CMD_MPRI
00ED7B  2  8D A0 B9           STA   FIO_CMD
00ED7E  2  60                 RTS
00ED7F  2               
00ED7F  2               ; --- MUSIC voice, "mml" ---
00ED7F  2               ; Pass string via pointer (ut1_pl/ph) so MML strings can exceed 63 bytes.
00ED7F  2               ; FIO_SRCL = voice, FIO_ENDL/ENDH = string pointer, FIO_NAMELEN = length.
00ED7F  2               @m_seq
00ED7F  2  20 8F D7           JSR   LAB_GTBY          ; voice number (1-6) → X
00ED82  2  8E A4 B9           STX   FIO_SRCL          ; store voice
00ED85  2  20 4D CD           JSR   LAB_1C01          ; comma
00ED88  2  20 29 CC           JSR   LAB_EVEX          ; evaluate expression
00ED8B  2  20 2C D6           JSR   LAB_EVST          ; pop string: A=len, ut1_pl/ph=ptr
00ED8E  2  AA                 TAX
00ED8F  2  F0 1A              BEQ   @m_seq_err        ; empty string = error
00ED91  2  8E A3 B9           STX   FIO_NAMELEN       ; string length (1-255)
00ED94  2  A5 71              LDA   ut1_pl
00ED96  2  8D A6 B9           STA   FIO_ENDL          ; string pointer low
00ED99  2  A5 72              LDA   ut1_ph
00ED9B  2  8D A7 B9           STA   FIO_ENDH          ; string pointer high
00ED9E  2  A9 0D              LDA   #FIO_CMD_MSEQ
00EDA0  2  8D A0 B9           STA   FIO_CMD
00EDA3  2  AD A1 B9           LDA   FIO_STATUS
00EDA6  2  C9 02              CMP   #FIO_OK
00EDA8  2  D0 01              BNE   @m_seq_err
00EDAA  2  60                 RTS
00EDAB  2               @m_seq_err
00EDAB  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00EDAE  2               
00EDAE  2               ; perform COPPER subcommand
00EDAE  2               ; COPPER ADD x, y, reg, value
00EDAE  2               ; COPPER CLEAR | ON | OFF
00EDAE  2               
00EDAE  2               LAB_COPPER
00EDAE  2  20 C2 00           JSR   LAB_GBYT          ; peek next byte
00EDB1  2  C9 A2              CMP   #TK_CLEAR
00EDB3  2  F0 17              BEQ   @c_clear
00EDB5  2  C9 93              CMP   #TK_ON
00EDB7  2  F0 1C              BEQ   @c_on
00EDB9  2  C9 CB              CMP   #TK_OFF
00EDBB  2  F0 21              BEQ   @c_off
00EDBD  2  C9 41              CMP   #'A'
00EDBF  2  F0 5A              BEQ   @c_add
00EDC1  2  C9 A1              CMP   #TK_LIST
00EDC3  2  F0 22              BEQ   @c_list
00EDC5  2  C9 55              CMP   #'U'
00EDC7  2  F0 3D              BEQ   @c_use
00EDC9  2  4C 78 C5           JMP   LAB_15D9          ; syntax error
00EDCC  2               
00EDCC  2               ; --- COPPER CLEAR ---
00EDCC  2               @c_clear
00EDCC  2  20 BC 00           JSR   LAB_IGBY          ; consume CLEAR token
00EDCF  2  A9 1C              LDA   #VCMD_COPPERCLR
00EDD1  2  8D 10 A0           STA   VGC_CMD
00EDD4  2  60                 RTS
00EDD5  2               
00EDD5  2               ; --- COPPER ON ---
00EDD5  2               @c_on
00EDD5  2  20 BC 00           JSR   LAB_IGBY          ; consume ON token
00EDD8  2  A9 1D              LDA   #VCMD_COPPERENA
00EDDA  2  8D 10 A0           STA   VGC_CMD
00EDDD  2  60                 RTS
00EDDE  2               
00EDDE  2               ; --- COPPER OFF ---
00EDDE  2               @c_off
00EDDE  2  20 BC 00           JSR   LAB_IGBY          ; consume OFF token
00EDE1  2  A9 1E              LDA   #VCMD_COPPERDIS
00EDE3  2  8D 10 A0           STA   VGC_CMD
00EDE6  2  60                 RTS
00EDE7  2               
00EDE7  2               ; --- COPPER LIST n / COPPER LIST END ---
00EDE7  2               @c_list
00EDE7  2  20 BC 00           JSR   LAB_IGBY          ; consume LIST token
00EDEA  2  20 C2 00           JSR   LAB_GBYT          ; peek next
00EDED  2  C9 80              CMP   #TK_END
00EDEF  2  F0 0C              BEQ   @c_list_end
00EDF1  2                     ; LIST n — parse list index
00EDF1  2  20 8F D7           JSR   LAB_GTBY          ; 8-bit → X
00EDF4  2  8E 11 A0           STX   VGC_P0             ; list index
00EDF7  2  A9 20              LDA   #VCMD_COPPERLIST
00EDF9  2  8D 10 A0           STA   VGC_CMD
00EDFC  2  60                 RTS
00EDFD  2               
00EDFD  2               @c_list_end
00EDFD  2  20 BC 00           JSR   LAB_IGBY          ; consume END token
00EE00  2  A9 22              LDA   #VCMD_COPPEREND
00EE02  2  8D 10 A0           STA   VGC_CMD
00EE05  2  60                 RTS
00EE06  2               
00EE06  2               ; --- COPPER USE n ---
00EE06  2               @c_use
00EE06  2  20 BC 00           JSR   LAB_IGBY          ; U
00EE09  2  20 BC 00           JSR   LAB_IGBY          ; S
00EE0C  2  20 BC 00           JSR   LAB_IGBY          ; E
00EE0F  2  20 8F D7           JSR   LAB_GTBY          ; list index → X
00EE12  2  8E 11 A0           STX   VGC_P0
00EE15  2  A9 21              LDA   #VCMD_COPPERUSE
00EE17  2  8D 10 A0           STA   VGC_CMD
00EE1A  2  60                 RTS
00EE1B  2               
00EE1B  2               ; --- COPPER ADD x, y, reg, value ---
00EE1B  2               @c_add
00EE1B  2  20 BC 00           JSR   LAB_IGBY          ; A
00EE1E  2  20 BC 00           JSR   LAB_IGBY          ; D
00EE21  2  20 BC 00           JSR   LAB_IGBY          ; D
00EE24  2  20 7D D7           JSR   LAB_GTWRD         ; x (16-bit) → FAC1_3(lo), FAC1_2(hi)
00EE27  2  A5 AF              LDA   FAC1_3
00EE29  2  8D 11 A0           STA   VGC_P0             ; x low
00EE2C  2  A5 AE              LDA   FAC1_2
00EE2E  2  8D 12 A0           STA   VGC_P1             ; x high
00EE31  2  20 4D CD           JSR   LAB_1C01          ; comma
00EE34  2  20 8F D7           JSR   LAB_GTBY          ; y (8-bit) → X
00EE37  2  8E 13 A0           STX   VGC_P2             ; y
00EE3A  2  20 4D CD           JSR   LAB_1C01          ; comma
00EE3D  2                     ; parse register name: BGCOL, MODE, SCROLLX, SCROLLY,
00EE3D  2                     ; SPRX(n), SPRXH(n), SPRY(n), SPRYH(n), SPRSHAPE(n), SPRFLAGS(n), SPRPRI(n)
00EE3D  2  20 C2 00           JSR   LAB_GBYT          ; peek
00EE40  2  C9 42              CMP   #'B'
00EE42  2  F0 0B              BEQ   @c_bgcol
00EE44  2  C9 B5              CMP   #TK_GMODE
00EE46  2  F0 1B              BEQ   @c_mode
00EE48  2  C9 53              CMP   #'S'
00EE4A  2  F0 1F              BEQ   @c_s_dispatch
00EE4C  2  4C 78 C5           JMP   LAB_15D9          ; syntax error
00EE4F  2               
00EE4F  2               @c_bgcol
00EE4F  2  20 BC 00           JSR   LAB_IGBY          ; B
00EE52  2  20 BC 00           JSR   LAB_IGBY          ; G
00EE55  2  20 BC 00           JSR   LAB_IGBY          ; C
00EE58  2  20 BC 00           JSR   LAB_IGBY          ; O
00EE5B  2  20 BC 00           JSR   LAB_IGBY          ; L
00EE5E  2  A9 01              LDA   #$01              ; reg index 1 = BGCOL
00EE60  2  4C A9 EE           JMP   @c_store_idx
00EE63  2               
00EE63  2               @c_mode
00EE63  2  20 BC 00           JSR   LAB_IGBY          ; consume MODE token
00EE66  2  A9 00              LDA   #$00              ; reg index 0 = MODE
00EE68  2  4C A9 EE           JMP   @c_store_idx
00EE6B  2               
00EE6B  2               @c_s_dispatch
00EE6B  2  20 BC 00           JSR   LAB_IGBY          ; consume S
00EE6E  2  20 C2 00           JSR   LAB_GBYT          ; peek next: C=scroll, P=sprite
00EE71  2  C9 43              CMP   #'C'
00EE73  2  F0 07              BEQ   @c_scroll
00EE75  2  C9 50              CMP   #'P'
00EE77  2  F0 3B              BEQ   @c_spr
00EE79  2  4C 78 C5           JMP   LAB_15D9          ; syntax error
00EE7C  2               
00EE7C  2               @c_scroll
00EE7C  2  20 BC 00           JSR   LAB_IGBY          ; C
00EE7F  2  20 BC 00           JSR   LAB_IGBY          ; R
00EE82  2  20 BC 00           JSR   LAB_IGBY          ; O
00EE85  2  20 BC 00           JSR   LAB_IGBY          ; L
00EE88  2  20 BC 00           JSR   LAB_IGBY          ; L
00EE8B  2  20 C2 00           JSR   LAB_GBYT          ; peek X or Y
00EE8E  2  C9 58              CMP   #'X'
00EE90  2  F0 07              BEQ   @c_scrollx
00EE92  2  C9 59              CMP   #'Y'
00EE94  2  F0 0B              BEQ   @c_scrolly
00EE96  2  4C 78 C5           JMP   LAB_15D9          ; syntax error
00EE99  2               
00EE99  2               @c_scrollx
00EE99  2  20 BC 00           JSR   LAB_IGBY          ; consume X
00EE9C  2  A9 05              LDA   #$05              ; reg index 5 = SCROLLX
00EE9E  2  4C A9 EE           JMP   @c_store_idx
00EEA1  2               
00EEA1  2               @c_scrolly
00EEA1  2  20 BC 00           JSR   LAB_IGBY          ; consume Y
00EEA4  2  A9 06              LDA   #$06              ; reg index 6 = SCROLLY
00EEA6  2  4C A9 EE           JMP   @c_store_idx
00EEA9  2               
00EEA9  2               @c_store_idx
00EEA9  2  8D 14 A0           STA   VGC_P3             ; register index (low byte)
00EEAC  2  A9 00              LDA   #$00
00EEAE  2  8D 15 A0           STA   VGC_P4             ; high byte = 0
00EEB1  2  4C 5E EF           JMP   @c_store_val
00EEB4  2               
00EEB4  2                     ; --- Sprite register names: SPR + field + (n) ---
00EEB4  2                     ; SPRX(n)=$A040+n*8+0, SPRXH(n)=+1, SPRY(n)=+2, SPRYH(n)=+3,
00EEB4  2                     ; SPRSHAPE(n)=+4, SPRFLAGS(n)=+5, SPRPRI(n)=+6
00EEB4  2               @c_spr
00EEB4  2  20 BC 00           JSR   LAB_IGBY          ; consume P
00EEB7  2  20 BC 00           JSR   LAB_IGBY          ; consume R
00EEBA  2  20 C2 00           JSR   LAB_GBYT          ; peek field start: X, Y, S, F, P
00EEBD  2  C9 58              CMP   #'X'
00EEBF  2  F0 13              BEQ   @cs_x
00EEC1  2  C9 59              CMP   #'Y'
00EEC3  2  F0 26              BEQ   @cs_y
00EEC5  2  C9 53              CMP   #'S'
00EEC7  2  F0 39              BEQ   @cs_shape
00EEC9  2  C9 46              CMP   #'F'
00EECB  2  F0 49              BEQ   @cs_flags
00EECD  2  C9 50              CMP   #'P'
00EECF  2  F0 59              BEQ   @cs_pri
00EED1  2  4C 78 C5           JMP   LAB_15D9          ; syntax error
00EED4  2               
00EED4  2               @cs_x
00EED4  2  20 BC 00           JSR   LAB_IGBY          ; consume X
00EED7  2  20 C2 00           JSR   LAB_GBYT          ; peek: H or (
00EEDA  2  C9 48              CMP   #'H'
00EEDC  2  F0 05              BEQ   @cs_xh
00EEDE  2  A9 00              LDA   #$00              ; field offset 0 = X low
00EEE0  2  4C 35 EF           JMP   @c_spr_idx
00EEE3  2               
00EEE3  2               @cs_xh
00EEE3  2  20 BC 00           JSR   LAB_IGBY          ; consume H
00EEE6  2  A9 01              LDA   #$01              ; field offset 1 = X high
00EEE8  2  4C 35 EF           JMP   @c_spr_idx
00EEEB  2               
00EEEB  2               @cs_y
00EEEB  2  20 BC 00           JSR   LAB_IGBY          ; consume Y
00EEEE  2  20 C2 00           JSR   LAB_GBYT          ; peek: H or (
00EEF1  2  C9 48              CMP   #'H'
00EEF3  2  F0 05              BEQ   @cs_yh
00EEF5  2  A9 02              LDA   #$02              ; field offset 2 = Y low
00EEF7  2  4C 35 EF           JMP   @c_spr_idx
00EEFA  2               
00EEFA  2               @cs_yh
00EEFA  2  20 BC 00           JSR   LAB_IGBY          ; consume H
00EEFD  2  A9 03              LDA   #$03              ; field offset 3 = Y high
00EEFF  2  4C 35 EF           JMP   @c_spr_idx
00EF02  2               
00EF02  2               @cs_shape
00EF02  2  20 BC 00           JSR   LAB_IGBY          ; S
00EF05  2  20 BC 00           JSR   LAB_IGBY          ; H
00EF08  2  20 BC 00           JSR   LAB_IGBY          ; A
00EF0B  2  20 BC 00           JSR   LAB_IGBY          ; P
00EF0E  2  20 BC 00           JSR   LAB_IGBY          ; E
00EF11  2  A9 04              LDA   #$04              ; field offset 4 = Shape
00EF13  2  4C 35 EF           JMP   @c_spr_idx
00EF16  2               
00EF16  2               @cs_flags
00EF16  2  20 BC 00           JSR   LAB_IGBY          ; F
00EF19  2  20 BC 00           JSR   LAB_IGBY          ; L
00EF1C  2  20 BC 00           JSR   LAB_IGBY          ; A
00EF1F  2  20 BC 00           JSR   LAB_IGBY          ; G
00EF22  2  20 BC 00           JSR   LAB_IGBY          ; S
00EF25  2  A9 05              LDA   #$05              ; field offset 5 = Flags
00EF27  2  4C 35 EF           JMP   @c_spr_idx
00EF2A  2               
00EF2A  2               @cs_pri
00EF2A  2  20 BC 00           JSR   LAB_IGBY          ; P
00EF2D  2  20 BC 00           JSR   LAB_IGBY          ; R
00EF30  2  20 BC 00           JSR   LAB_IGBY          ; I
00EF33  2  A9 06              LDA   #$06              ; field offset 6 = Priority
00EF35  2                     ; fall through to @c_spr_idx
00EF35  2               
00EF35  2                     ; A = field offset, now parse (n) and compute address $A040 + n*8 + A
00EF35  2               @c_spr_idx
00EF35  2  48                 PHA                     ; save field offset
00EF36  2  20 BC 00           JSR   LAB_IGBY          ; consume '('
00EF39  2  20 8F D7           JSR   LAB_GTBY          ; sprite index (0-15) → X
00EF3C  2  E0 10              CPX   #$10
00EF3E  2  90 03              BCC   @cs_idx_ok
00EF40  2  4C 78 C5           JMP   LAB_15D9          ; syntax error if n > 15
00EF43  2               @cs_idx_ok
00EF43  2  20 BC 00           JSR   LAB_IGBY          ; consume ')'
00EF46  2                     ; compute address: $A040 + X*8 + field
00EF46  2  8A                 TXA                     ; A = sprite index
00EF47  2  0A                 ASL                     ; *2
00EF48  2  0A                 ASL                     ; *4
00EF49  2  0A                 ASL                     ; *8
00EF4A  2  8D 14 A0           STA   VGC_P3             ; temp = n*8
00EF4D  2  68                 PLA                     ; A = field offset
00EF4E  2  18                 CLC
00EF4F  2  6D 14 A0           ADC   VGC_P3             ; A = n*8 + field
00EF52  2  69 40              ADC   #$40              ; A = n*8 + field + $40 (low byte of $A040)
00EF54  2  8D 14 A0           STA   VGC_P3             ; P3 = address low byte
00EF57  2  A9 A0              LDA   #$A0              ; high byte of $A040
00EF59  2  69 00              ADC   #$00              ; add carry if low byte wrapped
00EF5B  2  8D 15 A0           STA   VGC_P4             ; P4 = address high byte
00EF5E  2               
00EF5E  2               @c_store_val
00EF5E  2  20 4D CD           JSR   LAB_1C01          ; comma
00EF61  2  20 8F D7           JSR   LAB_GTBY          ; value (8-bit) → X
00EF64  2  8E 16 A0           STX   VGC_P5             ; value
00EF67  2  A9 1B              LDA   #VCMD_COPPERADD
00EF69  2  8D 10 A0           STA   VGC_CMD            ; trigger
00EF6C  2  60                 RTS
00EF6D  2               
00EF6D  2               ; perform RESET — full system reset (VGC, SID, music) + cold start BASIC
00EF6D  2               
00EF6D  2               LAB_RESET
00EF6D  2  A9 1F              LDA   #VCMD_SYSRESET
00EF6F  2  8D 10 A0           STA   VGC_CMD            ; trigger hardware reset
00EF72  2  6C FC FF           JMP   ($FFFC)            ; jump through reset vector
00EF75  2               
00EF75  2               ; --- NIC BASIC keyword handlers ---
00EF75  2               
00EF75  2               ; NOPEN slot,"host",port — connect slot to remote host
00EF75  2               LAB_NOPEN
00EF75  2  20 8F D7           JSR   LAB_GTBY          ; slot → X
00EF78  2  8E 02 A1           STX   NIC_SLOT
00EF7B  2  20 4D CD           JSR   LAB_1C01          ; comma
00EF7E  2  20 29 CC           JSR   LAB_EVEX          ; evaluate string expression
00EF81  2  20 2C D6           JSR   LAB_EVST          ; pop: A=len, ut1_pl/ph=ptr
00EF84  2  AA                 TAX                     ; len → X
00EF85  2  F0 2A              BEQ   @nopen_err        ; empty hostname = error
00EF87  2  E0 20              CPX   #32
00EF89  2  B0 26              BCS   @nopen_err        ; too long
00EF8B  2  A0 00              LDY   #$00
00EF8D  2               @nopen_cp
00EF8D  2  B1 71              LDA   (ut1_pl),Y
00EF8F  2  99 20 A1           STA   NIC_NAMEBUF,Y
00EF92  2  C8                 INY
00EF93  2  CA                 DEX
00EF94  2  D0 F7              BNE   @nopen_cp
00EF96  2  A9 00              LDA   #$00
00EF98  2  99 20 A1           STA   NIC_NAMEBUF,Y     ; null-terminate
00EF9B  2  20 4D CD           JSR   LAB_1C01          ; comma
00EF9E  2  20 7D D7           JSR   LAB_GTWRD         ; port → FAC1_3/FAC1_2
00EFA1  2  A5 AF              LDA   FAC1_3
00EFA3  2  8D 08 A1           STA   NIC_RPORTL
00EFA6  2  A5 AE              LDA   FAC1_2
00EFA8  2  8D 09 A1           STA   NIC_RPORTH
00EFAB  2  A9 01              LDA   #NIC_CMD_CONNECT
00EFAD  2  8D 00 A1           STA   NIC_CMD
00EFB0  2  60                 RTS
00EFB1  2               @nopen_err
00EFB1  2  4C 14 D2           JMP   LAB_FCER          ; function call error
00EFB4  2               
00EFB4  2               ; NCLOSE slot — disconnect slot
00EFB4  2               LAB_NCLOSE
00EFB4  2  20 8F D7           JSR   LAB_GTBY          ; slot → X
00EFB7  2  8E 02 A1           STX   NIC_SLOT
00EFBA  2  A9 02              LDA   #NIC_CMD_DISCONNECT
00EFBC  2  8D 00 A1           STA   NIC_CMD
00EFBF  2  60                 RTS
00EFC0  2               
00EFC0  2               ; NLISTEN slot,port — listen for incoming connections
00EFC0  2               LAB_NLISTEN
00EFC0  2  20 8F D7           JSR   LAB_GTBY          ; slot → X
00EFC3  2  8E 02 A1           STX   NIC_SLOT
00EFC6  2  20 4D CD           JSR   LAB_1C01          ; comma
00EFC9  2  20 7D D7           JSR   LAB_GTWRD         ; port → FAC1_3/FAC1_2
00EFCC  2  A5 AF              LDA   FAC1_3
00EFCE  2  8D 0A A1           STA   NIC_LPORTL
00EFD1  2  A5 AE              LDA   FAC1_2
00EFD3  2  8D 0B A1           STA   NIC_LPORTH
00EFD6  2  A9 05              LDA   #NIC_CMD_LISTEN
00EFD8  2  8D 00 A1           STA   NIC_CMD
00EFDB  2  60                 RTS
00EFDC  2               
00EFDC  2               ; NACCEPT slot — accept pending connection
00EFDC  2               LAB_NACCEPT
00EFDC  2  20 8F D7           JSR   LAB_GTBY          ; slot → X
00EFDF  2  8E 02 A1           STX   NIC_SLOT
00EFE2  2  A9 06              LDA   #NIC_CMD_ACCEPT
00EFE4  2  8D 00 A1           STA   NIC_CMD
00EFE7  2  60                 RTS
00EFE8  2               
00EFE8  2               ; NSEND slot,A$ — send string via NIC
00EFE8  2               LAB_NSEND
00EFE8  2  20 8F D7           JSR   LAB_GTBY          ; slot → X
00EFEB  2  8E 02 A1           STX   NIC_SLOT
00EFEE  2  20 4D CD           JSR   LAB_1C01          ; comma
00EFF1  2  20 29 CC           JSR   LAB_EVEX          ; evaluate expression
00EFF4  2  20 2C D6           JSR   LAB_EVST          ; pop string: A=len, ut1_pl/ph=ptr
00EFF7  2  AA                 TAX
00EFF8  2  F0 13              BEQ   @nsend_err        ; empty string
00EFFA  2                     ; Point DMA at string in BASIC memory
00EFFA  2  A5 71              LDA   ut1_pl
00EFFC  2  8D 10 A1           STA   NIC_DMAL
00EFFF  2  A5 72              LDA   ut1_ph
00F001  2  8D 11 A1           STA   NIC_DMAH
00F004  2  8E 12 A1           STX   NIC_DMALEN        ; length
00F007  2  A9 03              LDA   #NIC_CMD_SEND
00F009  2  8D 00 A1           STA   NIC_CMD
00F00C  2  60                 RTS
00F00D  2               @nsend_err
00F00D  2  4C 14 D2           JMP   LAB_FCER
00F010  2               
00F010  2               ; DMACOPY srcSpace,srcAddr,dstSpace,dstAddr,len
00F010  2               ; Address arguments are 16-bit offsets. For XRAM space (5), current XBANK
00F010  2               ; is used as the high address byte.
00F010  2               LAB_DMACOPY
00F010  2                     ; src space
00F010  2  20 8F D7           JSR   LAB_GTBY
00F013  2  8E 63 BA           STX   DMA_SRCSPACE
00F016  2  86 11              STX   Itempl
00F018  2                     ; src addr
00F018  2  20 4D CD           JSR   LAB_1C01
00F01B  2  20 7D D7           JSR   LAB_GTWRD
00F01E  2  A5 AF              LDA   FAC1_3
00F020  2  8D 65 BA           STA   DMA_SRCL
00F023  2  A5 AE              LDA   FAC1_2
00F025  2  8D 66 BA           STA   DMA_SRCM
00F028  2  A9 00              LDA   #$00
00F02A  2  8D 67 BA           STA   DMA_SRCH
00F02D  2  A4 11              LDY   Itempl
00F02F  2  C0 05              CPY   #DMA_SPACE_XRAM
00F031  2  D0 06              BNE   @dmac_srcok
00F033  2  AD 0C BA           LDA   XMC_BANK
00F036  2  8D 67 BA           STA   DMA_SRCH
00F039  2               @dmac_srcok
00F039  2                     ; dst space
00F039  2  20 4D CD           JSR   LAB_1C01
00F03C  2  20 8F D7           JSR   LAB_GTBY
00F03F  2  8E 64 BA           STX   DMA_DSTSPACE
00F042  2  86 11              STX   Itempl
00F044  2                     ; dst addr
00F044  2  20 4D CD           JSR   LAB_1C01
00F047  2  20 7D D7           JSR   LAB_GTWRD
00F04A  2  A5 AF              LDA   FAC1_3
00F04C  2  8D 68 BA           STA   DMA_DSTL
00F04F  2  A5 AE              LDA   FAC1_2
00F051  2  8D 69 BA           STA   DMA_DSTM
00F054  2  A9 00              LDA   #$00
00F056  2  8D 6A BA           STA   DMA_DSTH
00F059  2  A4 11              LDY   Itempl
00F05B  2  C0 05              CPY   #DMA_SPACE_XRAM
00F05D  2  D0 06              BNE   @dmac_dstok
00F05F  2  AD 0C BA           LDA   XMC_BANK
00F062  2  8D 6A BA           STA   DMA_DSTH
00F065  2               @dmac_dstok
00F065  2                     ; len
00F065  2  20 4D CD           JSR   LAB_1C01
00F068  2  20 7D D7           JSR   LAB_GTWRD
00F06B  2  A5 AF              LDA   FAC1_3
00F06D  2  8D 6B BA           STA   DMA_LENL
00F070  2  A5 AE              LDA   FAC1_2
00F072  2  8D 6C BA           STA   DMA_LENM
00F075  2  A9 00              LDA   #$00
00F077  2  8D 6D BA           STA   DMA_LENH
00F07A  2                     ; mode = copy
00F07A  2  A9 00              LDA   #$00
00F07C  2  8D 6E BA           STA   DMA_MODE
00F07F  2                     ; start
00F07F  2  A9 01              LDA   #DMA_CMD_START
00F081  2  8D 60 BA           STA   DMA_CMD
00F084  2  AD 61 BA           LDA   DMA_STATUS
00F087  2  C9 01              CMP   #DMA_BUSY
00F089  2  F0 07              BEQ   @dmac_ok
00F08B  2  C9 02              CMP   #DMA_OK
00F08D  2  F0 03              BEQ   @dmac_ok
00F08F  2  4C 14 D2           JMP   LAB_FCER
00F092  2               @dmac_ok
00F092  2  60                 RTS
00F093  2               
00F093  2               ; DMAFILL dstSpace,dstAddr,len,value
00F093  2               ; Address argument is a 16-bit offset. For XRAM space (5), current XBANK
00F093  2               ; is used as the high address byte.
00F093  2               LAB_DMAFILL
00F093  2                     ; dst space
00F093  2  20 8F D7           JSR   LAB_GTBY
00F096  2  8E 64 BA           STX   DMA_DSTSPACE
00F099  2  86 11              STX   Itempl
00F09B  2                     ; dst addr
00F09B  2  20 4D CD           JSR   LAB_1C01
00F09E  2  20 7D D7           JSR   LAB_GTWRD
00F0A1  2  A5 AF              LDA   FAC1_3
00F0A3  2  8D 68 BA           STA   DMA_DSTL
00F0A6  2  A5 AE              LDA   FAC1_2
00F0A8  2  8D 69 BA           STA   DMA_DSTM
00F0AB  2  A9 00              LDA   #$00
00F0AD  2  8D 6A BA           STA   DMA_DSTH
00F0B0  2  A4 11              LDY   Itempl
00F0B2  2  C0 05              CPY   #DMA_SPACE_XRAM
00F0B4  2  D0 06              BNE   @dmaf_dstok
00F0B6  2  AD 0C BA           LDA   XMC_BANK
00F0B9  2  8D 6A BA           STA   DMA_DSTH
00F0BC  2               @dmaf_dstok
00F0BC  2                     ; len
00F0BC  2  20 4D CD           JSR   LAB_1C01
00F0BF  2  20 7D D7           JSR   LAB_GTWRD
00F0C2  2  A5 AF              LDA   FAC1_3
00F0C4  2  8D 6B BA           STA   DMA_LENL
00F0C7  2  A5 AE              LDA   FAC1_2
00F0C9  2  8D 6C BA           STA   DMA_LENM
00F0CC  2  A9 00              LDA   #$00
00F0CE  2  8D 6D BA           STA   DMA_LENH
00F0D1  2                     ; fill value
00F0D1  2  20 4D CD           JSR   LAB_1C01
00F0D4  2  20 8F D7           JSR   LAB_GTBY
00F0D7  2  8E 6F BA           STX   DMA_FILL
00F0DA  2                     ; mode = fill
00F0DA  2  A9 01              LDA   #DMA_MODE_FILL
00F0DC  2  8D 6E BA           STA   DMA_MODE
00F0DF  2                     ; source fields are ignored in fill mode; keep deterministic
00F0DF  2  A9 00              LDA   #$00
00F0E1  2  8D 63 BA           STA   DMA_SRCSPACE
00F0E4  2  8D 65 BA           STA   DMA_SRCL
00F0E7  2  8D 66 BA           STA   DMA_SRCM
00F0EA  2  8D 67 BA           STA   DMA_SRCH
00F0ED  2                     ; start
00F0ED  2  A9 01              LDA   #DMA_CMD_START
00F0EF  2  8D 60 BA           STA   DMA_CMD
00F0F2  2  AD 61 BA           LDA   DMA_STATUS
00F0F5  2  C9 01              CMP   #DMA_BUSY
00F0F7  2  F0 07              BEQ   @dmaf_ok
00F0F9  2  C9 02              CMP   #DMA_OK
00F0FB  2  F0 03              BEQ   @dmaf_ok
00F0FD  2  4C 14 D2           JMP   LAB_FCER
00F100  2               @dmaf_ok
00F100  2  60                 RTS
00F101  2               
00F101  2               ; BLITCOPY srcSpace,srcAddr,srcStride,dstSpace,dstAddr,dstStride,width,height
00F101  2               ; Address arguments are 16-bit offsets. For XRAM space (5), current XBANK
00F101  2               ; is used as the high address byte.
00F101  2               LAB_BLITCOPY
00F101  2                     ; src space
00F101  2  20 8F D7           JSR   LAB_GTBY
00F104  2  8E 83 BA           STX   BLT_SRCSPACE
00F107  2  86 11              STX   Itempl
00F109  2                     ; src addr
00F109  2  20 4D CD           JSR   LAB_1C01
00F10C  2  20 7D D7           JSR   LAB_GTWRD
00F10F  2  A5 AF              LDA   FAC1_3
00F111  2  8D 85 BA           STA   BLT_SRCL
00F114  2  A5 AE              LDA   FAC1_2
00F116  2  8D 86 BA           STA   BLT_SRCM
00F119  2  A9 00              LDA   #$00
00F11B  2  8D 87 BA           STA   BLT_SRCH
00F11E  2  A4 11              LDY   Itempl
00F120  2  C0 05              CPY   #BLT_SPACE_XRAM
00F122  2  D0 06              BNE   @bltc_srcok
00F124  2  AD 0C BA           LDA   XMC_BANK
00F127  2  8D 87 BA           STA   BLT_SRCH
00F12A  2               @bltc_srcok
00F12A  2                     ; src stride
00F12A  2  20 4D CD           JSR   LAB_1C01
00F12D  2  20 7D D7           JSR   LAB_GTWRD
00F130  2  A5 AF              LDA   FAC1_3
00F132  2  8D 8F BA           STA   BLT_SRCSTRL
00F135  2  A5 AE              LDA   FAC1_2
00F137  2  8D 90 BA           STA   BLT_SRCSTRH
00F13A  2                     ; dst space
00F13A  2  20 4D CD           JSR   LAB_1C01
00F13D  2  20 8F D7           JSR   LAB_GTBY
00F140  2  8E 84 BA           STX   BLT_DSTSPACE
00F143  2  86 11              STX   Itempl
00F145  2                     ; dst addr
00F145  2  20 4D CD           JSR   LAB_1C01
00F148  2  20 7D D7           JSR   LAB_GTWRD
00F14B  2  A5 AF              LDA   FAC1_3
00F14D  2  8D 88 BA           STA   BLT_DSTL
00F150  2  A5 AE              LDA   FAC1_2
00F152  2  8D 89 BA           STA   BLT_DSTM
00F155  2  A9 00              LDA   #$00
00F157  2  8D 8A BA           STA   BLT_DSTH
00F15A  2  A4 11              LDY   Itempl
00F15C  2  C0 05              CPY   #BLT_SPACE_XRAM
00F15E  2  D0 06              BNE   @bltc_dstok
00F160  2  AD 0C BA           LDA   XMC_BANK
00F163  2  8D 8A BA           STA   BLT_DSTH
00F166  2               @bltc_dstok
00F166  2                     ; dst stride
00F166  2  20 4D CD           JSR   LAB_1C01
00F169  2  20 7D D7           JSR   LAB_GTWRD
00F16C  2  A5 AF              LDA   FAC1_3
00F16E  2  8D 91 BA           STA   BLT_DSTSTRL
00F171  2  A5 AE              LDA   FAC1_2
00F173  2  8D 92 BA           STA   BLT_DSTSTRH
00F176  2                     ; width
00F176  2  20 4D CD           JSR   LAB_1C01
00F179  2  20 7D D7           JSR   LAB_GTWRD
00F17C  2  A5 AF              LDA   FAC1_3
00F17E  2  8D 8B BA           STA   BLT_WIDTHL
00F181  2  A5 AE              LDA   FAC1_2
00F183  2  8D 8C BA           STA   BLT_WIDTHH
00F186  2                     ; height
00F186  2  20 4D CD           JSR   LAB_1C01
00F189  2  20 7D D7           JSR   LAB_GTWRD
00F18C  2  A5 AF              LDA   FAC1_3
00F18E  2  8D 8D BA           STA   BLT_HEIGHTL
00F191  2  A5 AE              LDA   FAC1_2
00F193  2  8D 8E BA           STA   BLT_HEIGHTH
00F196  2                     ; mode = copy
00F196  2  A9 00              LDA   #$00
00F198  2  8D 93 BA           STA   BLT_MODE
00F19B  2  8D 94 BA           STA   BLT_FILL
00F19E  2  8D 95 BA           STA   BLT_CKEY
00F1A1  2                     ; start
00F1A1  2  A9 01              LDA   #BLT_CMD_START
00F1A3  2  8D 80 BA           STA   BLT_CMD
00F1A6  2  AD 81 BA           LDA   BLT_STATUS
00F1A9  2  C9 01              CMP   #BLT_BUSY
00F1AB  2  F0 07              BEQ   @bltc_ok
00F1AD  2  C9 02              CMP   #BLT_OK
00F1AF  2  F0 03              BEQ   @bltc_ok
00F1B1  2  4C 14 D2           JMP   LAB_FCER
00F1B4  2               @bltc_ok
00F1B4  2  60                 RTS
00F1B5  2               
00F1B5  2               ; BLITFILL dstSpace,dstAddr,dstStride,width,height,value
00F1B5  2               ; Address argument is a 16-bit offset. For XRAM space (5), current XBANK
00F1B5  2               ; is used as the high address byte.
00F1B5  2               LAB_BLITFILL
00F1B5  2                     ; dst space
00F1B5  2  20 8F D7           JSR   LAB_GTBY
00F1B8  2  8E 84 BA           STX   BLT_DSTSPACE
00F1BB  2  86 11              STX   Itempl
00F1BD  2                     ; dst addr
00F1BD  2  20 4D CD           JSR   LAB_1C01
00F1C0  2  20 7D D7           JSR   LAB_GTWRD
00F1C3  2  A5 AF              LDA   FAC1_3
00F1C5  2  8D 88 BA           STA   BLT_DSTL
00F1C8  2  A5 AE              LDA   FAC1_2
00F1CA  2  8D 89 BA           STA   BLT_DSTM
00F1CD  2  A9 00              LDA   #$00
00F1CF  2  8D 8A BA           STA   BLT_DSTH
00F1D2  2  A4 11              LDY   Itempl
00F1D4  2  C0 05              CPY   #BLT_SPACE_XRAM
00F1D6  2  D0 06              BNE   @bltf_dstok
00F1D8  2  AD 0C BA           LDA   XMC_BANK
00F1DB  2  8D 8A BA           STA   BLT_DSTH
00F1DE  2               @bltf_dstok
00F1DE  2                     ; dst stride
00F1DE  2  20 4D CD           JSR   LAB_1C01
00F1E1  2  20 7D D7           JSR   LAB_GTWRD
00F1E4  2  A5 AF              LDA   FAC1_3
00F1E6  2  8D 91 BA           STA   BLT_DSTSTRL
00F1E9  2  A5 AE              LDA   FAC1_2
00F1EB  2  8D 92 BA           STA   BLT_DSTSTRH
00F1EE  2                     ; width
00F1EE  2  20 4D CD           JSR   LAB_1C01
00F1F1  2  20 7D D7           JSR   LAB_GTWRD
00F1F4  2  A5 AF              LDA   FAC1_3
00F1F6  2  8D 8B BA           STA   BLT_WIDTHL
00F1F9  2  A5 AE              LDA   FAC1_2
00F1FB  2  8D 8C BA           STA   BLT_WIDTHH
00F1FE  2                     ; height
00F1FE  2  20 4D CD           JSR   LAB_1C01
00F201  2  20 7D D7           JSR   LAB_GTWRD
00F204  2  A5 AF              LDA   FAC1_3
00F206  2  8D 8D BA           STA   BLT_HEIGHTL
00F209  2  A5 AE              LDA   FAC1_2
00F20B  2  8D 8E BA           STA   BLT_HEIGHTH
00F20E  2                     ; fill value
00F20E  2  20 4D CD           JSR   LAB_1C01
00F211  2  20 8F D7           JSR   LAB_GTBY
00F214  2  8E 94 BA           STX   BLT_FILL
00F217  2                     ; source fields are ignored in fill mode; keep deterministic
00F217  2  A9 00              LDA   #$00
00F219  2  8D 83 BA           STA   BLT_SRCSPACE
00F21C  2  8D 85 BA           STA   BLT_SRCL
00F21F  2  8D 86 BA           STA   BLT_SRCM
00F222  2  8D 87 BA           STA   BLT_SRCH
00F225  2  8D 8F BA           STA   BLT_SRCSTRL
00F228  2  8D 90 BA           STA   BLT_SRCSTRH
00F22B  2  8D 95 BA           STA   BLT_CKEY
00F22E  2                     ; mode = fill
00F22E  2  A9 01              LDA   #BLT_MODE_FILL
00F230  2  8D 93 BA           STA   BLT_MODE
00F233  2                     ; start
00F233  2  A9 01              LDA   #BLT_CMD_START
00F235  2  8D 80 BA           STA   BLT_CMD
00F238  2  AD 81 BA           LDA   BLT_STATUS
00F23B  2  C9 01              CMP   #BLT_BUSY
00F23D  2  F0 07              BEQ   @bltf_ok
00F23F  2  C9 02              CMP   #BLT_OK
00F241  2  F0 03              BEQ   @bltf_ok
00F243  2  4C 14 D2           JMP   LAB_FCER
00F246  2               @bltf_ok
00F246  2  60                 RTS
00F247  2               
00F247  2               ; perform DEL "filename"
00F247  2               
00F247  2               LAB_FDEL
00F247  2  20 69 F2           JSR   LAB_FIO_GETNAME   ; parse filename expression into FIO_NAME
00F24A  2  90 03              BCC   @del_have_name
00F24C  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00F24F  2               @del_have_name
00F24F  2                     ; trigger DELETE
00F24F  2  A9 05              LDA   #FIO_CMD_DELETE
00F251  2  8D A0 B9           STA   FIO_CMD
00F254  2                     ; check status
00F254  2  AD A1 B9           LDA   FIO_STATUS
00F257  2  C9 02              CMP   #FIO_OK
00F259  2  D0 01              BNE   @del_chk_err
00F25B  2  60                 RTS
00F25C  2               @del_chk_err
00F25C  2  AD A2 B9           LDA   FIO_ERRCODE
00F25F  2  C9 01              CMP   #$01              ; not found?
00F261  2  D0 03              BNE   @del_errio
00F263  2  4C 8F F2           JMP   LAB_FIO_ERRFNF
00F266  2               @del_errio
00F266  2  4C 88 F2           JMP   LAB_FIO_ERRIO
00F269  2               
00F269  2               ; helper: evaluate filename expression and copy into FIO_NAME/FIO_NAMELEN
00F269  2               ; carry clear = success, carry set = invalid/empty/too long
00F269  2               
00F269  2               LAB_FIO_GETNAME
00F269  2  20 29 CC           JSR   LAB_EVEX
00F26C  2  20 2C D6           JSR   LAB_EVST          ; pop string: A=len, ut1_pl/ph=ptr
00F26F  2  AA                 TAX                     ; save length in X
00F270  2  F0 14              BEQ   @fio_bad_name
00F272  2  E0 40              CPX   #64               ; max 63 chars
00F274  2  B0 10              BCS   @fio_bad_name
00F276  2  8E A3 B9           STX   FIO_NAMELEN
00F279  2  A0 00              LDY   #$00
00F27B  2               @fio_cp_name
00F27B  2  B1 71              LDA   (ut1_pl),Y
00F27D  2  99 B0 B9           STA   FIO_NAME,Y
00F280  2  C8                 INY
00F281  2  CA                 DEX
00F282  2  D0 F7              BNE   @fio_cp_name
00F284  2  18                 CLC
00F285  2  60                 RTS
00F286  2               @fio_bad_name
00F286  2  38                 SEC
00F287  2  60                 RTS
00F288  2               
00F288  2               LAB_FIO_ERRIO
00F288  2  A9 99              LDA   #<ERR_FIO
00F28A  2  A0 F2              LDY   #>ERR_FIO
00F28C  2  4C 93 F2           JMP   LAB_FIO_ERRMSG
00F28F  2               
00F28F  2               LAB_FIO_ERRFNF
00F28F  2  A9 A5              LDA   #<ERR_FNF
00F291  2  A0 F2              LDY   #>ERR_FNF
00F293  2               LAB_FIO_ERRMSG
00F293  2  20 2A CA           JSR   LAB_18C3
00F296  2  4C 67 C1           JMP   LAB_1274
00F299  2               
00F299  2  0D 0A 49 2F  ERR_FIO     .byte $0D,$0A,"I/O Error",$00
00F29D  2  4F 20 45 72  
00F2A1  2  72 6F 72 00  
00F2A5  2  0D 0A 46 69  ERR_FNF     .byte $0D,$0A,"File not found",$00
00F2A9  2  6C 65 20 6E  
00F2AD  2  6F 74 20 66  
00F2B6  2               
00F2B6  2               ; perform DIR — list saved programs
00F2B6  2               
00F2B6  2               LAB_DIR
00F2B6  2                     ; trigger DirOpen
00F2B6  2  A9 03              LDA   #FIO_CMD_DIROPEN
00F2B8  2  8D A0 B9           STA   FIO_CMD
00F2BB  2                     ; check status — FIO_OK means first entry ready
00F2BB  2  AD A1 B9           LDA   FIO_STATUS
00F2BE  2  C9 02              CMP   #FIO_OK
00F2C0  2  D0 68              BNE   @dir_done         ; no files or error — done
00F2C2  2  20 E9 C9           JSR   LAB_CRLF          ; blank line after DIR command
00F2C5  2               @dir_loop
00F2C5  2                     ; --- right-justified file size in 5-column field ---
00F2C5  2                     ; Convert AX to string (reuse EhBASIC's FAC1→string)
00F2C5  2  AD A9 B9           LDA   FIO_SIZEH         ; high byte in A
00F2C8  2  AE A8 B9           LDX   FIO_SIZEL         ; low byte in X
00F2CB  2  85 AD              STA   FAC1_1            ; FAC1 mantissa1
00F2CD  2  86 AE              STX   FAC1_2            ; FAC1 mantissa2
00F2CF  2  A2 90              LDX   #$90              ; exponent = 16 bits
00F2D1  2  38                 SEC                     ; +ve flag
00F2D2  2  20 11 DC           JSR   LAB_STFA          ; normalise into FAC1
00F2D5  2  A0 00              LDY   #$00
00F2D7  2  98                 TYA
00F2D8  2  20 AC DD           JSR   LAB_297B          ; convert FAC1 → null-terminated string at Decssp1
00F2DB  2                     ; Count string length at Decssp1 (result string, skips sign byte)
00F2DB  2  A0 00              LDY   #$00
00F2DD  2               @dir_slen
00F2DD  2  B9 F0 00           LDA   Decssp1,Y
00F2E0  2  F0 03              BEQ   @dir_pad          ; null terminator found, Y = length
00F2E2  2  C8                 INY
00F2E3  2  D0 F8              BNE   @dir_slen
00F2E5  2               @dir_pad
00F2E5  2                     ; Pad with spaces until Y reaches 5
00F2E5  2  C0 05              CPY   #$05
00F2E7  2  B0 08              BCS   @dir_pnum         ; already 5+ chars, no padding
00F2E9  2  A9 20              LDA   #' '
00F2EB  2  20 44 CA           JSR   LAB_PRNA          ; print space
00F2EE  2  C8                 INY
00F2EF  2  D0 F4              BNE   @dir_pad          ; always branches
00F2F1  2               @dir_pnum
00F2F1  2                     ; Print the number string from Decssp1
00F2F1  2  A9 F0              LDA   #<Decssp1
00F2F3  2  A0 00              LDY   #>Decssp1
00F2F5  2  20 2A CA           JSR   LAB_18C3          ; print null terminated string
00F2F8  2                     ; print type based on FIO_DIRTYPE (0=PRG, 1=SID)
00F2F8  2  AD AF B9           LDA   FIO_DIRTYPE
00F2FB  2  D0 07              BNE   @dir_sid
00F2FD  2  A9 2B              LDA   #<STR_PRG
00F2FF  2  A0 F3              LDY   #>STR_PRG
00F301  2  4C 08 F3           JMP   @dir_ptype
00F304  2               @dir_sid
00F304  2  A9 33              LDA   #<STR_SID
00F306  2  A0 F3              LDY   #>STR_SID
00F308  2               @dir_ptype
00F308  2  20 2A CA           JSR   LAB_18C3          ; print null terminated string
00F30B  2                     ; print filename from FIO_NAME (length in FIO_NAMELEN)
00F30B  2  A0 00              LDY   #$00
00F30D  2               @dir_pname
00F30D  2  CC A3 B9           CPY   FIO_NAMELEN
00F310  2  B0 09              BCS   @dir_nl           ; done printing name
00F312  2  B9 B0 B9           LDA   FIO_NAME,Y
00F315  2  20 44 CA           JSR   LAB_PRNA          ; print character
00F318  2  C8                 INY
00F319  2  D0 F2              BNE   @dir_pname        ; always branches (Y won't wrap for 63 chars)
00F31B  2               @dir_nl
00F31B  2  20 E9 C9           JSR   LAB_CRLF          ; print CR/LF
00F31E  2                     ; advance to next entry
00F31E  2  A9 04              LDA   #FIO_CMD_DIRREAD
00F320  2  8D A0 B9           STA   FIO_CMD
00F323  2  AD A1 B9           LDA   FIO_STATUS
00F326  2  C9 02              CMP   #FIO_OK
00F328  2  F0 9B              BEQ   @dir_loop         ; more entries
00F32A  2               @dir_done
00F32A  2  60                 RTS
00F32B  2               
00F32B  2  20 20 50 52  STR_PRG     .byte "  PRG  ",$00
00F32F  2  47 20 20 00  
00F333  2  20 20 53 49  STR_SID     .byte "  SID  ",$00
00F337  2  44 20 20 00  
00F33B  2               
00F33B  2               ; --- XMC expansion memory handlers ---
00F33B  2               
00F33B  2               LAB_XMC_CHKOK
00F33B  2  AD 01 BA           LDA   XMC_STATUS
00F33E  2  C9 02              CMP   #XMC_OK
00F340  2  F0 03              BEQ   @xok
00F342  2  4C 14 D2           JMP   LAB_FCER
00F345  2               @xok
00F345  2  60                 RTS
00F346  2               
00F346  2               LAB_XMC_SETOFF
00F346  2  20 7D D7           JSR   LAB_GTWRD         ; parse 16-bit offset
00F349  2  A5 AF              LDA   FAC1_3
00F34B  2  8D 04 BA           STA   XMC_XAL
00F34E  2  A5 AE              LDA   FAC1_2
00F350  2  8D 05 BA           STA   XMC_XAM
00F353  2  AD 0C BA           LDA   XMC_BANK
00F356  2  8D 06 BA           STA   XMC_XAH
00F359  2  60                 RTS
00F35A  2               
00F35A  2               ; parse string expression into XMC name buffer
00F35A  2               ; carry clear = success, carry set = invalid name
00F35A  2               
00F35A  2               LAB_XMC_GETNAME
00F35A  2  20 29 CC           JSR   LAB_EVEX
00F35D  2  20 2C D6           JSR   LAB_EVST
00F360  2  AA                 TAX
00F361  2  F0 14              BEQ   @xname_bad
00F363  2  E0 1D              CPX   #XMC_NAME_MAX+1
00F365  2  B0 10              BCS   @xname_bad
00F367  2  8E 12 BA           STX   XMC_NAMELEN
00F36A  2  A0 00              LDY   #$00
00F36C  2               @xname_cp
00F36C  2  B1 71              LDA   (ut1_pl),Y
00F36E  2  99 24 BA           STA   XMC_NAME,Y
00F371  2  C8                 INY
00F372  2  CA                 DEX
00F373  2  D0 F7              BNE   @xname_cp
00F375  2  18                 CLC
00F376  2  60                 RTS
00F377  2               @xname_bad
00F377  2  38                 SEC
00F378  2  60                 RTS
00F379  2               
00F379  2               ; compute mapped window bitmask from X=0..3
00F379  2               ; out: A = bit, carry clear on success, set on invalid
00F379  2               
00F379  2               LAB_XMC_GETWINBIT
00F379  2  E0 04              CPX   #$04
00F37B  2  B0 0A              BCS   @xw_bad
00F37D  2  A9 01              LDA   #$01
00F37F  2               @xw_shl
00F37F  2  CA                 DEX
00F380  2  30 03              BMI   @xw_ok
00F382  2  0A                 ASL
00F383  2  D0 FA              BNE   @xw_shl
00F385  2               @xw_ok
00F385  2  18                 CLC
00F386  2  60                 RTS
00F387  2               @xw_bad
00F387  2  38                 SEC
00F388  2  60                 RTS
00F389  2               
00F389  2               ; set mapped window base from FAC1_3/FAC1_2 + current XMC_BANK
00F389  2               ; in: X window index 0..3
00F389  2               
00F389  2               LAB_XMC_SETWINADDR
00F389  2  E0 00              CPX   #$00
00F38B  2  D0 11              BNE   @xw_set1
00F38D  2  A5 AF              LDA   FAC1_3
00F38F  2  8D 18 BA           STA   XMC_W0AL
00F392  2  A5 AE              LDA   FAC1_2
00F394  2  8D 19 BA           STA   XMC_W0AM
00F397  2  AD 0C BA           LDA   XMC_BANK
00F39A  2  8D 1A BA           STA   XMC_W0AH
00F39D  2  60                 RTS
00F39E  2               @xw_set1
00F39E  2  E0 01              CPX   #$01
00F3A0  2  D0 11              BNE   @xw_set2
00F3A2  2  A5 AF              LDA   FAC1_3
00F3A4  2  8D 1B BA           STA   XMC_W1AL
00F3A7  2  A5 AE              LDA   FAC1_2
00F3A9  2  8D 1C BA           STA   XMC_W1AM
00F3AC  2  AD 0C BA           LDA   XMC_BANK
00F3AF  2  8D 1D BA           STA   XMC_W1AH
00F3B2  2  60                 RTS
00F3B3  2               @xw_set2
00F3B3  2  E0 02              CPX   #$02
00F3B5  2  D0 11              BNE   @xw_set3
00F3B7  2  A5 AF              LDA   FAC1_3
00F3B9  2  8D 1E BA           STA   XMC_W2AL
00F3BC  2  A5 AE              LDA   FAC1_2
00F3BE  2  8D 1F BA           STA   XMC_W2AM
00F3C1  2  AD 0C BA           LDA   XMC_BANK
00F3C4  2  8D 20 BA           STA   XMC_W2AH
00F3C7  2  60                 RTS
00F3C8  2               @xw_set3
00F3C8  2  A5 AF              LDA   FAC1_3
00F3CA  2  8D 21 BA           STA   XMC_W3AL
00F3CD  2  A5 AE              LDA   FAC1_2
00F3CF  2  8D 22 BA           STA   XMC_W3AM
00F3D2  2  AD 0C BA           LDA   XMC_BANK
00F3D5  2  8D 23 BA           STA   XMC_W3AH
00F3D8  2  60                 RTS
00F3D9  2               
00F3D9  2               ; perform XMEM
00F3D9  2               
00F3D9  2               LAB_XMEM
00F3D9  2  A9 07              LDA   #XMC_CMD_STATS
00F3DB  2  8D 00 BA           STA   XMC_CMD
00F3DE  2  A9 00              LDA   #$00              ; print "<banks>"
00F3E0  2  AE 0D BA           LDX   XMC_BANKS
00F3E3  2  20 8C DD           JSR   LAB_295E
00F3E6  2  A9 34              LDA   #<STR_XBANKS
00F3E8  2  A0 F6              LDY   #>STR_XBANKS
00F3EA  2  20 2A CA           JSR   LAB_18C3
00F3ED  2               
00F3ED  2                     ; print "<banks*64>" as KB
00F3ED  2  AD 0D BA           LDA   XMC_BANKS
00F3F0  2  85 11              STA   Itempl            ; low byte
00F3F2  2  A9 00              LDA   #$00
00F3F4  2  85 12              STA   Itemph            ; high byte
00F3F6  2  A0 06              LDY   #$06
00F3F8  2               @xmem_kb_lp
00F3F8  2  06 11              ASL   Itempl
00F3FA  2  26 12              ROL   Itemph
00F3FC  2  88                 DEY
00F3FD  2  D0 F9              BNE   @xmem_kb_lp
00F3FF  2  A5 12              LDA   Itemph            ; high byte in A
00F401  2  A6 11              LDX   Itempl            ; low byte in X
00F403  2  20 8C DD           JSR   LAB_295E
00F406  2  A9 3D              LDA   #<STR_XKB
00F408  2  A0 F6              LDY   #>STR_XKB
00F40A  2  20 2A CA           JSR   LAB_18C3
00F40D  2               
00F40D  2  A9 00              LDA   #$00              ; print selected bank
00F40F  2  AE 0C BA           LDX   XMC_BANK
00F412  2  20 8C DD           JSR   LAB_295E
00F415  2  A9 4D              LDA   #<STR_XUSED
00F417  2  A0 F6              LDY   #>STR_XUSED
00F419  2  20 2A CA           JSR   LAB_18C3
00F41C  2  AD 0F BA           LDA   XMC_USEDH
00F41F  2  AE 0E BA           LDX   XMC_USEDL
00F422  2  20 8C DD           JSR   LAB_295E
00F425  2  A9 55              LDA   #<STR_XFREE
00F427  2  A0 F6              LDY   #>STR_XFREE
00F429  2  20 2A CA           JSR   LAB_18C3
00F42C  2  AD 11 BA           LDA   XMC_FREEH
00F42F  2  AE 10 BA           LDX   XMC_FREEL
00F432  2  20 8C DD           JSR   LAB_295E
00F435  2  A9 5D              LDA   #<STR_XPAGES
00F437  2  A0 F6              LDY   #>STR_XPAGES
00F439  2  20 2A CA           JSR   LAB_18C3
00F43C  2  A9 64              LDA   #<STR_XNAMED
00F43E  2  A0 F6              LDY   #>STR_XNAMED
00F440  2  20 2A CA           JSR   LAB_18C3
00F443  2  AD 15 BA           LDA   XMC_DIRCOUNTH
00F446  2  AE 14 BA           LDX   XMC_DIRCOUNTL
00F449  2  20 8C DD           JSR   LAB_295E
00F44C  2  20 E9 C9           JSR   LAB_CRLF
00F44F  2  60                 RTS
00F450  2               
00F450  2               ; perform XBANK n
00F450  2               
00F450  2               LAB_XBANK
00F450  2  20 8F D7           JSR   LAB_GTBY
00F453  2  EC 0D BA           CPX   XMC_BANKS
00F456  2  B0 04              BCS   @xb_bad
00F458  2  8E 0C BA           STX   XMC_BANK
00F45B  2  60                 RTS
00F45C  2               @xb_bad
00F45C  2  4C 14 D2           JMP   LAB_FCER
00F45F  2               
00F45F  2               ; perform XPOKE offset, value   (offset is within current XBANK)
00F45F  2               
00F45F  2               LAB_XPOKE
00F45F  2  20 46 F3           JSR   LAB_XMC_SETOFF
00F462  2  20 4D CD           JSR   LAB_1C01
00F465  2  20 8F D7           JSR   LAB_GTBY
00F468  2  8E 0B BA           STX   XMC_DATA
00F46B  2  A9 02              LDA   #XMC_CMD_PUT
00F46D  2  8D 00 BA           STA   XMC_CMD
00F470  2  4C 3B F3           JMP   LAB_XMC_CHKOK
00F473  2               
00F473  2               ; perform STASH ramAddr, xOffset, len   (uses current XBANK)
00F473  2               ; or      STASH "name", ramAddr, len    (named allocation)
00F473  2               
00F473  2               LAB_XSTASH
00F473  2  20 C2 00           JSR   LAB_GBYT
00F476  2  C9 22              CMP   #$22              ; leading quote means named form
00F478  2  D0 30              BNE   @xstash_raw
00F47A  2  20 5A F3           JSR   LAB_XMC_GETNAME
00F47D  2  90 03              BCC   @xstash_named_ok
00F47F  2  4C 14 D2           JMP   LAB_FCER
00F482  2               @xstash_named_ok
00F482  2  20 4D CD           JSR   LAB_1C01
00F485  2  20 7D D7           JSR   LAB_GTWRD         ; RAM source address
00F488  2  A5 AF              LDA   FAC1_3
00F48A  2  8D 07 BA           STA   XMC_RAML
00F48D  2  A5 AE              LDA   FAC1_2
00F48F  2  8D 08 BA           STA   XMC_RAMH
00F492  2  20 4D CD           JSR   LAB_1C01
00F495  2  20 7D D7           JSR   LAB_GTWRD         ; transfer length
00F498  2  A5 AF              LDA   FAC1_3
00F49A  2  8D 09 BA           STA   XMC_LENL
00F49D  2  A5 AE              LDA   FAC1_2
00F49F  2  8D 0A BA           STA   XMC_LENH
00F4A2  2  A9 0B              LDA   #XMC_CMD_NSTSH
00F4A4  2  8D 00 BA           STA   XMC_CMD
00F4A7  2  4C 3B F3           JMP   LAB_XMC_CHKOK
00F4AA  2               @xstash_raw
00F4AA  2  20 7D D7           JSR   LAB_GTWRD         ; RAM source address
00F4AD  2  A5 AF              LDA   FAC1_3
00F4AF  2  8D 07 BA           STA   XMC_RAML
00F4B2  2  A5 AE              LDA   FAC1_2
00F4B4  2  8D 08 BA           STA   XMC_RAMH
00F4B7  2  20 4D CD           JSR   LAB_1C01
00F4BA  2  20 46 F3           JSR   LAB_XMC_SETOFF    ; XRAM destination offset + bank
00F4BD  2  20 4D CD           JSR   LAB_1C01
00F4C0  2  20 7D D7           JSR   LAB_GTWRD         ; transfer length
00F4C3  2  A5 AF              LDA   FAC1_3
00F4C5  2  8D 09 BA           STA   XMC_LENL
00F4C8  2  A5 AE              LDA   FAC1_2
00F4CA  2  8D 0A BA           STA   XMC_LENH
00F4CD  2  A9 03              LDA   #XMC_CMD_STASH
00F4CF  2  8D 00 BA           STA   XMC_CMD
00F4D2  2  4C 3B F3           JMP   LAB_XMC_CHKOK
00F4D5  2               
00F4D5  2               ; perform FETCH ramAddr, xOffset, len   (uses current XBANK)
00F4D5  2               ; or      FETCH "name", ramAddr         (named fetch)
00F4D5  2               
00F4D5  2               LAB_XFETCH
00F4D5  2  20 C2 00           JSR   LAB_GBYT
00F4D8  2  C9 22              CMP   #$22              ; leading quote means named form
00F4DA  2  D0 28              BNE   @xfetch_raw
00F4DC  2  20 5A F3           JSR   LAB_XMC_GETNAME
00F4DF  2  90 03              BCC   @xfetch_named_ok
00F4E1  2  4C 14 D2           JMP   LAB_FCER
00F4E4  2               @xfetch_named_ok
00F4E4  2  20 4D CD           JSR   LAB_1C01
00F4E7  2  20 7D D7           JSR   LAB_GTWRD         ; RAM destination address
00F4EA  2  A5 AF              LDA   FAC1_3
00F4EC  2  8D 07 BA           STA   XMC_RAML
00F4EF  2  A5 AE              LDA   FAC1_2
00F4F1  2  8D 08 BA           STA   XMC_RAMH
00F4F4  2  A9 00              LDA   #$00              ; len=0 means full block length
00F4F6  2  8D 09 BA           STA   XMC_LENL
00F4F9  2  8D 0A BA           STA   XMC_LENH
00F4FC  2  A9 0C              LDA   #XMC_CMD_NFETC
00F4FE  2  8D 00 BA           STA   XMC_CMD
00F501  2  4C 3B F3           JMP   LAB_XMC_CHKOK
00F504  2               @xfetch_raw
00F504  2  20 7D D7           JSR   LAB_GTWRD         ; RAM destination address
00F507  2  A5 AF              LDA   FAC1_3
00F509  2  8D 07 BA           STA   XMC_RAML
00F50C  2  A5 AE              LDA   FAC1_2
00F50E  2  8D 08 BA           STA   XMC_RAMH
00F511  2  20 4D CD           JSR   LAB_1C01
00F514  2  20 46 F3           JSR   LAB_XMC_SETOFF    ; XRAM source offset + bank
00F517  2  20 4D CD           JSR   LAB_1C01
00F51A  2  20 7D D7           JSR   LAB_GTWRD         ; transfer length
00F51D  2  A5 AF              LDA   FAC1_3
00F51F  2  8D 09 BA           STA   XMC_LENL
00F522  2  A5 AE              LDA   FAC1_2
00F524  2  8D 0A BA           STA   XMC_LENH
00F527  2  A9 04              LDA   #XMC_CMD_FETCH
00F529  2  8D 00 BA           STA   XMC_CMD
00F52C  2  4C 3B F3           JMP   LAB_XMC_CHKOK
00F52F  2               
00F52F  2               ; perform XFREE xOffset, len   (uses current XBANK)
00F52F  2               
00F52F  2               LAB_XFREE
00F52F  2  20 46 F3           JSR   LAB_XMC_SETOFF
00F532  2  20 4D CD           JSR   LAB_1C01
00F535  2  20 7D D7           JSR   LAB_GTWRD
00F538  2  A5 AF              LDA   FAC1_3
00F53A  2  8D 09 BA           STA   XMC_LENL
00F53D  2  A5 AE              LDA   FAC1_2
00F53F  2  8D 0A BA           STA   XMC_LENH
00F542  2  A9 09              LDA   #XMC_CMD_REL
00F544  2  8D 00 BA           STA   XMC_CMD
00F547  2  4C 3B F3           JMP   LAB_XMC_CHKOK
00F54A  2               
00F54A  2               ; perform XRESET   (clear XRAM usage counters)
00F54A  2               
00F54A  2               LAB_XRESET
00F54A  2  A9 08              LDA   #XMC_CMD_RSTUS
00F54C  2  8D 00 BA           STA   XMC_CMD
00F54F  2  4C 3B F3           JMP   LAB_XMC_CHKOK
00F552  2               
00F552  2               ; perform XALLOC len
00F552  2               
00F552  2               LAB_XALLOC
00F552  2  20 7D D7           JSR   LAB_GTWRD
00F555  2  A5 AF              LDA   FAC1_3
00F557  2  8D 09 BA           STA   XMC_LENL
00F55A  2  A5 AE              LDA   FAC1_2
00F55C  2  8D 0A BA           STA   XMC_LENH
00F55F  2  A9 0A              LDA   #XMC_CMD_ALLOC
00F561  2  8D 00 BA           STA   XMC_CMD
00F564  2  4C 3B F3           JMP   LAB_XMC_CHKOK
00F567  2               
00F567  2               ; perform XDIR
00F567  2               
00F567  2               LAB_XDIR
00F567  2  A9 0E              LDA   #XMC_CMD_NDIRO
00F569  2  8D 00 BA           STA   XMC_CMD
00F56C  2  AD 01 BA           LDA   XMC_STATUS
00F56F  2  C9 02              CMP   #XMC_OK
00F571  2  D0 2F              BNE   @xdir_done
00F573  2               @xdir_loop
00F573  2  AD 0A BA           LDA   XMC_LENH
00F576  2  AE 09 BA           LDX   XMC_LENL
00F579  2  20 8C DD           JSR   LAB_295E
00F57C  2  A9 6D              LDA   #<STR_XDIRBY
00F57E  2  A0 F6              LDY   #>STR_XDIRBY
00F580  2  20 2A CA           JSR   LAB_18C3
00F583  2  A0 00              LDY   #$00
00F585  2               @xdir_name
00F585  2  CC 12 BA           CPY   XMC_NAMELEN
00F588  2  B0 09              BCS   @xdir_nl
00F58A  2  B9 24 BA           LDA   XMC_NAME,Y
00F58D  2  20 44 CA           JSR   LAB_PRNA
00F590  2  C8                 INY
00F591  2  D0 F2              BNE   @xdir_name
00F593  2               @xdir_nl
00F593  2  20 E9 C9           JSR   LAB_CRLF
00F596  2  A9 0F              LDA   #XMC_CMD_NDIRR
00F598  2  8D 00 BA           STA   XMC_CMD
00F59B  2  AD 01 BA           LDA   XMC_STATUS
00F59E  2  C9 02              CMP   #XMC_OK
00F5A0  2  F0 D1              BEQ   @xdir_loop
00F5A2  2               @xdir_done
00F5A2  2  60                 RTS
00F5A3  2               
00F5A3  2               ; perform XDEL "name"
00F5A3  2               
00F5A3  2               LAB_XDEL
00F5A3  2  20 5A F3           JSR   LAB_XMC_GETNAME
00F5A6  2  90 03              BCC   @xdel_named_ok
00F5A8  2  4C 14 D2           JMP   LAB_FCER
00F5AB  2               @xdel_named_ok
00F5AB  2  A9 0D              LDA   #XMC_CMD_NDEL
00F5AD  2  8D 00 BA           STA   XMC_CMD
00F5B0  2  4C 3B F3           JMP   LAB_XMC_CHKOK
00F5B3  2               
00F5B3  2               ; perform XMAP window, offset
00F5B3  2               
00F5B3  2               LAB_XMAP
00F5B3  2  20 8F D7           JSR   LAB_GTBY          ; window 0..3
00F5B6  2  86 78              STX   TempB
00F5B8  2  20 79 F3           JSR   LAB_XMC_GETWINBIT
00F5BB  2  90 03              BCC   @xmap_wok
00F5BD  2  4C 14 D2           JMP   LAB_FCER
00F5C0  2               @xmap_wok
00F5C0  2  85 5B              STA   Temp3             ; save bit mask
00F5C2  2  20 4D CD           JSR   LAB_1C01
00F5C5  2  20 7D D7           JSR   LAB_GTWRD         ; offset within current bank
00F5C8  2  A6 78              LDX   TempB
00F5CA  2  20 89 F3           JSR   LAB_XMC_SETWINADDR
00F5CD  2  AD 16 BA           LDA   XMC_WINCTL
00F5D0  2  05 5B              ORA   Temp3
00F5D2  2  8D 16 BA           STA   XMC_WINCTL
00F5D5  2  60                 RTS
00F5D6  2               
00F5D6  2               ; perform XUNMAP window
00F5D6  2               
00F5D6  2               LAB_XUNMAP
00F5D6  2  20 8F D7           JSR   LAB_GTBY
00F5D9  2  20 79 F3           JSR   LAB_XMC_GETWINBIT
00F5DC  2  90 03              BCC   @xunmap_wok
00F5DE  2  4C 14 D2           JMP   LAB_FCER
00F5E1  2               @xunmap_wok
00F5E1  2  49 FF              EOR   #$FF
00F5E3  2  2D 16 BA           AND   XMC_WINCTL
00F5E6  2  8D 16 BA           STA   XMC_WINCTL
00F5E9  2  60                 RTS
00F5EA  2               
00F5EA  2               ; --- XMC assembly helper routines ---
00F5EA  2               ; Carry clear = success, carry set = error (A = XMC_ERRCODE)
00F5EA  2               
00F5EA  2               LAB_XM_CMDCHK
00F5EA  2  8D 00 BA           STA   XMC_CMD
00F5ED  2  AD 01 BA           LDA   XMC_STATUS
00F5F0  2  C9 02              CMP   #XMC_OK
00F5F2  2  F0 05              BEQ   @xm_ok
00F5F4  2  AD 02 BA           LDA   XMC_ERRCODE
00F5F7  2  38                 SEC
00F5F8  2  60                 RTS
00F5F9  2               @xm_ok
00F5F9  2  18                 CLC
00F5FA  2  60                 RTS
00F5FB  2               
00F5FB  2               ; set 24-bit expansion address: A=low, X=mid, Y=high
00F5FB  2               LAB_XM_SETADDR
00F5FB  2  8D 04 BA           STA   XMC_XAL
00F5FE  2  8E 05 BA           STX   XMC_XAM
00F601  2  8C 06 BA           STY   XMC_XAH
00F604  2  60                 RTS
00F605  2               
00F605  2               ; get status snapshot: A=status, X=errcode
00F605  2               LAB_XM_STATUS
00F605  2  AD 01 BA           LDA   XMC_STATUS
00F608  2  AE 02 BA           LDX   XMC_ERRCODE
00F60B  2  60                 RTS
00F60C  2               
00F60C  2               ; read byte at XADDR: carry clear and A=value on success
00F60C  2               LAB_XM_GETBYTE
00F60C  2  A9 01              LDA   #XMC_CMD_GET
00F60E  2  20 EA F5           JSR   LAB_XM_CMDCHK
00F611  2  90 01              BCC   @xm_get_ok
00F613  2  60                 RTS
00F614  2               @xm_get_ok
00F614  2  AD 0B BA           LDA   XMC_DATA
00F617  2  60                 RTS
00F618  2               
00F618  2               ; write byte at XADDR: A=value
00F618  2               LAB_XM_PUTBYTE
00F618  2  8D 0B BA           STA   XMC_DATA
00F61B  2  A9 02              LDA   #XMC_CMD_PUT
00F61D  2  4C EA F5           JMP   LAB_XM_CMDCHK
00F620  2               
00F620  2               ; run bulk commands with preloaded XMC_RAML/H, XMC_XAL/M/H, XMC_LENL/H, XMC_DATA
00F620  2               LAB_XM_STASH
00F620  2  A9 03              LDA   #XMC_CMD_STASH
00F622  2  4C EA F5           JMP   LAB_XM_CMDCHK
00F625  2               
00F625  2               LAB_XM_FETCH
00F625  2  A9 04              LDA   #XMC_CMD_FETCH
00F627  2  4C EA F5           JMP   LAB_XM_CMDCHK
00F62A  2               
00F62A  2               LAB_XM_FILL
00F62A  2  A9 05              LDA   #XMC_CMD_FILL
00F62C  2  4C EA F5           JMP   LAB_XM_CMDCHK
00F62F  2               
00F62F  2               LAB_XM_ALLOC
00F62F  2  A9 0A              LDA   #XMC_CMD_ALLOC
00F631  2  4C EA F5           JMP   LAB_XM_CMDCHK
00F634  2               
00F634  2  20 42 41 4E  STR_XBANKS  .byte " BANKS, ",$00
00F638  2  4B 53 2C 20  
00F63C  2  00           
00F63D  2  20 4B 42 20  STR_XKB     .byte " KB XRAM, BANK ",$00
00F641  2  58 52 41 4D  
00F645  2  2C 20 42 41  
00F64D  2  2C 20 55 53  STR_XUSED   .byte ", USED ",$00
00F651  2  45 44 20 00  
00F655  2  2C 20 46 52  STR_XFREE   .byte ", FREE ",$00
00F659  2  45 45 20 00  
00F65D  2  20 50 41 47  STR_XPAGES  .byte " PAGES",$00
00F661  2  45 53 00     
00F664  2  2C 20 4E 41  STR_XNAMED  .byte ", NAMED ",$00
00F668  2  4D 45 44 20  
00F66C  2  00           
00F66D  2  20 42 59 54  STR_XDIRBY  .byte " BYTES  ",$00
00F671  2  45 53 20 20  
00F675  2  00           
00F676  2               
00F676  2               ; character get subroutine for zero page
00F676  2               
00F676  2               ; For a 1.8432MHz 6502 including the JSR and RTS
00F676  2               ; fastest (>=":") =  29 cycles =  15.7uS
00F676  2               ; slowest (<":")  =  40 cycles =  21.7uS
00F676  2               ; space skip      = +21 cycles = +11.4uS
00F676  2               ; inc across page =  +4 cycles =  +2.2uS
00F676  2               
00F676  2               ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
00F676  2               ; block is copied to it's destination, any non zero page address will do at assembly
00F676  2               ; time, to assemble a three byte instruction.
00F676  2               
00F676  2               ; page 0 initialisation table from $BC
00F676  2               ; increment and scan memory
00F676  2               
00F676  2               LAB_2CEE
00F676  2  E6 C3              INC   Bpntrl            ; increment BASIC execute pointer low byte
00F678  2  D0 02              BNE   LAB_2CF4          ; branch if no carry
00F67A  2                                             ; else
00F67A  2  E6 C4              INC   Bpntrh            ; increment BASIC execute pointer high byte
00F67C  2               
00F67C  2               ; page 0 initialisation table from $C2
00F67C  2               ; scan memory
00F67C  2               
00F67C  2               LAB_2CF4
00F67C  2  AD FF FF           LDA   $FFFF             ; get byte to scan (addr set by call routine)
00F67F  2  C9 C2              CMP   #TK_ELSE          ; compare with the token for ELSE
00F681  2  F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
00F683  2               
00F683  2  C9 3A              CMP   #':'              ; compare with ":"
00F685  2  B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
00F687  2               
00F687  2  C9 20              CMP   #' '              ; compare with " "
00F689  2  F0 EB              BEQ   LAB_2CEE          ; if " " go do next
00F68B  2               
00F68B  2  38                 SEC                     ; set carry for SBC
00F68C  2  E9 30              SBC   #'0'              ; subtract "0"
00F68E  2  38                 SEC                     ; set carry for SBC
00F68F  2  E9 D0              SBC   #$D0              ; subtract -"0"
00F691  2                                             ; clear carry if byte = "0"-"9"
00F691  2               LAB_2D05
00F691  2  60                 RTS
00F692  2               
00F692  2               ; page zero initialisation table $00-$12 inclusive
00F692  2               
00F692  2               StrTab
00F692  2  4C                 .byte $4C               ; JMP opcode
00F693  2  00 C0              .word LAB_COLD          ; initial warm start vector (cold start)
00F695  2               
00F695  2  00                 .byte $00               ; these bytes are not used by BASIC
00F696  2  00 00              .word $0000             ;
00F698  2  00 00              .word $0000             ;
00F69A  2  00 00              .word $0000             ;
00F69C  2               
00F69C  2  4C                 .byte $4C               ; JMP opcode
00F69D  2  14 D2              .word LAB_FCER          ; initial user function vector ("Function call" error)
00F69F  2  00                 .byte $00               ; default NULL count
00F6A0  2  00                 .byte $00               ; clear terminal position
00F6A1  2  00                 .byte $00               ; default terminal width byte
00F6A2  2  F2                 .byte $F2               ; default limit for TAB = 14
00F6A3  2  00 03              .word Ram_base          ; start of user RAM
00F6A5  2               EndTab
00F6A5  2               
00F6A5  2               LAB_SMSG
00F6A5  2  20 42 41 53        .byte " BASIC bytes free  ",$00
00F6A9  2  49 43 20 62  
00F6AD  2  79 74 65 73  
00F6B9  2               
00F6B9  2               LAB_XMSG
00F6B9  2  4B 20 65 78        .byte "K expansion memory",$00
00F6BD  2  70 61 6E 73  
00F6C1  2  69 6F 6E 20  
00F6CC  2               
00F6CC  2               LAB_NLNL
00F6CC  2  0D 0A 0D 0A        .byte $0D,$0A,$0D,$0A,$00
00F6D0  2  00           
00F6D1  2               
00F6D1  2               ; numeric constants and series
00F6D1  2               
00F6D1  2                                             ; constants and series for LOG(n)
00F6D1  2               LAB_25A0
00F6D1  2  02                 .byte $02               ; counter
00F6D2  2  80 19 56 62        .byte $80,$19,$56,$62   ; 0.59898
00F6D6  2  80 76 22 F3        .byte $80,$76,$22,$F3   ; 0.96147
00F6DA  2               ;##   .byte $80,$76,$22,$F1   ; 0.96147
00F6DA  2  82 38 AA 40        .byte $82,$38,$AA,$40   ; 2.88539
00F6DE  2               ;##   .byte $82,$38,$AA,$45   ; 2.88539
00F6DE  2               
00F6DE  2               LAB_25AD
00F6DE  2  80 35 04 F3        .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
00F6E2  2               LAB_25B1
00F6E2  2  81 35 04 F3        .byte $81,$35,$04,$F3   ; 1.41421   root 2
00F6E6  2               LAB_25B5
00F6E6  2  80 80 00 00        .byte $80,$80,$00,$00   ; -0.5
00F6EA  2               LAB_25B9
00F6EA  2  80 31 72 18        .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
00F6EE  2               
00F6EE  2                                             ; numeric PRINT constants
00F6EE  2               LAB_2947
00F6EE  2  91 43 4F F8        .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
00F6F2  2               LAB_294B
00F6F2  2  94 74 23 F7        .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
00F6F6  2               LAB_294F
00F6F6  2  94 74 24 00        .byte $94,$74,$24,$00   ; 1000000
00F6FA  2               
00F6FA  2                                             ; EXP(n) constants and series
00F6FA  2               LAB_2AFA
00F6FA  2  81 38 AA 3B        .byte $81,$38,$AA,$3B   ; 1.4427    (1/LOG base 2 e)
00F6FE  2               LAB_2AFE
00F6FE  2  06                 .byte $06               ; counter
00F6FF  2  74 63 90 8C        .byte $74,$63,$90,$8C   ; 2.17023e-4
00F703  2  77 23 0C AB        .byte $77,$23,$0C,$AB   ; 0.00124
00F707  2  7A 1E 94 00        .byte $7A,$1E,$94,$00   ; 0.00968
00F70B  2  7C 63 42 80        .byte $7C,$63,$42,$80   ; 0.05548
00F70F  2  7E 75 FE D0        .byte $7E,$75,$FE,$D0   ; 0.24023
00F713  2  80 31 72 15        .byte $80,$31,$72,$15   ; 0.69315
00F717  2  81 00 00 00        .byte $81,$00,$00,$00   ; 1.00000
00F71B  2               
00F71B  2               ;##   .byte $07               ; counter
00F71B  2               ;##   .byte $74,$94,$2E,$40   ; -1/7! (-1/5040)
00F71B  2               ;##   .byte $77,$2E,$4F,$70   ;  1/6! ( 1/720)
00F71B  2               ;##   .byte $7A,$88,$02,$6E   ; -1/5! (-1/120)
00F71B  2               ;##   .byte $7C,$2A,$A0,$E6   ;  1/4! ( 1/24)
00F71B  2               ;##   .byte $7E,$AA,$AA,$50   ; -1/3! (-1/6)
00F71B  2               ;##   .byte $7F,$7F,$FF,$FF   ;  1/2! ( 1/2)
00F71B  2               ;##   .byte $81,$80,$00,$00   ; -1/1! (-1/1)
00F71B  2               ;##   .byte $81,$00,$00,$00   ;  1/0! ( 1/1)
00F71B  2               
00F71B  2                                             ; trigonometric constants and series
00F71B  2               LAB_2C78
00F71B  2  81 49 0F DB        .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
00F71F  2               LAB_2C84
00F71F  2  04                 .byte $04               ; counter
00F720  2  86 1E D7 FB        .byte $86,$1E,$D7,$FB   ; 39.7109
00F724  2               ;##   .byte $86,$1E,$D7,$BA   ; 39.7109
00F724  2  87 99 26 65        .byte $87,$99,$26,$65   ;-76.575
00F728  2               ;##   .byte $87,$99,$26,$64   ;-76.575
00F728  2  87 23 34 58        .byte $87,$23,$34,$58   ; 81.6022
00F72C  2  86 A5 5D E1        .byte $86,$A5,$5D,$E1   ;-41.3417
00F730  2               ;##   .byte $86,$A5,$5D,$E0   ;-41.3417
00F730  2               LAB_2C7C
00F730  2  83 49 0F DB        .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
00F734  2               ;##   .byte $83,$49,$0F,$DA   ; 6.28319 (2*pi) as floating #
00F734  2               
00F734  2               LAB_2CC9
00F734  2  08                 .byte $08               ; counter
00F735  2  78 3A C5 37        .byte $78,$3A,$C5,$37   ; 0.00285
00F739  2  7B 83 A2 5C        .byte $7B,$83,$A2,$5C   ;-0.0160686
00F73D  2  7C 2E DD 4D        .byte $7C,$2E,$DD,$4D   ; 0.0426915
00F741  2  7D 99 B0 1E        .byte $7D,$99,$B0,$1E   ;-0.0750429
00F745  2  7D 59 ED 24        .byte $7D,$59,$ED,$24   ; 0.106409
00F749  2  7E 91 72 00        .byte $7E,$91,$72,$00   ;-0.142036
00F74D  2  7E 4C B9 73        .byte $7E,$4C,$B9,$73   ; 0.199926
00F751  2  7F AA AA 53        .byte $7F,$AA,$AA,$53   ;-0.333331
00F755  2               
00F755  2               ;##   .byte $08               ; counter
00F755  2               ;##   .byte $78,$3B,$D7,$4A   ; 1/17
00F755  2               ;##   .byte $7B,$84,$6E,$02   ;-1/15
00F755  2               ;##   .byte $7C,$2F,$C1,$FE   ; 1/13
00F755  2               ;##   .byte $7D,$9A,$31,$74   ;-1/11
00F755  2               ;##   .byte $7D,$5A,$3D,$84   ; 1/9
00F755  2               ;##   .byte $7E,$91,$7F,$C8   ;-1/7
00F755  2               ;##   .byte $7E,$4C,$BB,$E4   ; 1/5
00F755  2               ;##   .byte $7F,$AA,$AA,$6C   ;-1/3
00F755  2               
00F755  2               LAB_1D96    = *+1             ; $00,$00 used for undefined variables
00F755  2               LAB_259C
00F755  2  81 00 00 00        .byte $81,$00,$00,$00   ; 1.000000, used for INC
00F759  2               LAB_2AFD
00F759  2  81 80 00 00        .byte $81,$80,$00,$00   ; -1.00000, used for DEC. must be on the same page as +1.00
00F75D  2               
00F75D  2                                             ; misc constants
00F75D  2               LAB_1DF7
00F75D  2  90                 .byte $90               ;-32768 (uses first three bytes from 0.5)
00F75E  2               LAB_2A96
00F75E  2  80 00 00 00        .byte $80,$00,$00,$00   ; 0.5
00F762  2               LAB_2C80
00F762  2  7F 00 00 00        .byte $7F,$00,$00,$00   ; 0.25
00F766  2               LAB_26B5
00F766  2  84 20 00 00        .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
00F76A  2               
00F76A  2               ; This table is used in converting numbers to ASCII.
00F76A  2               
00F76A  2               LAB_2A9A
00F76A  2               LAB_2A9B = LAB_2A9A+1
00F76A  2               LAB_2A9C = LAB_2A9B+1
00F76A  2  FE 79 60           .byte $FE,$79,$60       ; -100000
00F76D  2  00 27 10           .byte $00,$27,$10       ; 10000
00F770  2  FF FC 18           .byte $FF,$FC,$18       ; -1000
00F773  2  00 00 64           .byte $00,$00,$64       ; 100
00F776  2  FF FF F6           .byte $FF,$FF,$F6       ; -10
00F779  2  00 00 01           .byte $00,$00,$01       ; 1
00F77C  2               
00F77C  2               LAB_CTBL
00F77C  2  74 C6              .word LAB_END-1         ; END
00F77E  2  F8 C4              .word LAB_FOR-1         ; FOR
00F780  2  AC CB              .word LAB_NEXT-1        ; NEXT
00F782  2  DF C7              .word LAB_DATA-1        ; DATA
00F784  2  8F CA              .word LAB_INPUT-1       ; INPUT
00F786  2  49 D0              .word LAB_DIM-1         ; DIM
00F788  2  AE CA              .word LAB_READ-1        ; READ
00F78A  2  0A C9              .word LAB_LET-1         ; LET
00F78C  2  DC C8              .word LAB_DEC-1         ; DEC             new command
00F78E  2  3E C7              .word LAB_GOTO-1        ; GOTO
00F790  2  FD C6              .word LAB_RUN-1         ; RUN
00F792  2  0D C8              .word LAB_IF-1          ; IF
00F794  2  95 C6              .word LAB_RESTORE-1     ; RESTORE         modified command
00F796  2  21 C7              .word LAB_GOSUB-1       ; GOSUB
00F798  2  61 E3              .word LAB_RETIRQ-1      ; RETIRQ          new command
00F79A  2  6D E3              .word LAB_RETNMI-1      ; RETNMI          new command
00F79C  2  CA C7              .word LAB_RETURN-1      ; RETURN
00F79E  2  74 C8              .word LAB_REM-1         ; REM
00F7A0  2  72 C6              .word LAB_STOP-1        ; STOP
00F7A2  2  7D C8              .word LAB_ON-1          ; ON              modified command
00F7A4  2  D3 C6              .word LAB_NULL-1        ; NULL            modified command
00F7A6  2  DF C8              .word LAB_INC-1         ; INC             new command
00F7A8  2  92 D8              .word LAB_WAIT-1        ; WAIT
00F7AA  2  B8 E6              .word V_LOAD-1          ; LOAD
00F7AC  2  BB E6              .word V_SAVE-1          ; SAVE
00F7AE  2  5E D3              .word LAB_DEF-1         ; DEF
00F7B0  2  09 D8              .word LAB_POKE-1        ; POKE
00F7B2  2  25 D8              .word LAB_DOKE-1        ; DOKE            new command
00F7B4  2  72 D8              .word LAB_CALL-1        ; CALL            new command
00F7B6  2  07 C7              .word LAB_DO-1          ; DO              new command
00F7B8  2  70 C7              .word LAB_LOOP-1        ; LOOP            new command
00F7BA  2  AB C9              .word LAB_PRINT-1       ; PRINT
00F7BC  2  D7 C6              .word LAB_CONT-1        ; CONT
00F7BE  2  06 C4              .word LAB_LIST-1        ; LIST
00F7C0  2  03 C4              .word LAB_CLEAR-1       ; CLEAR
00F7C2  2  B3 C3              .word LAB_NEW-1         ; NEW
00F7C4  2  E2 E3              .word LAB_WDTH-1        ; WIDTH           new command
00F7C6  2  7A C9              .word LAB_GET-1         ; GET             new command
00F7C8  2  4A D8              .word LAB_SWAP-1        ; SWAP            new command
00F7CA  2  8B E0              .word LAB_BITSET-1      ; BITSET          new command
00F7CC  2  96 E0              .word LAB_BITCLR-1      ; BITCLR          new command
00F7CE  2  10 E3              .word LAB_IRQ-1         ; IRQ             new command
00F7D0  2  13 E3              .word LAB_NMI-1         ; NMI             new command
00F7D2  2  3A E7              .word LAB_CLS-1         ; CLS             VGC command
00F7D4  2  40 E7              .word LAB_COLOR-1       ; COLOR           VGC command
00F7D6  2  57 E7              .word LAB_LOCATE-1      ; LOCATE          VGC command
00F7D8  2  85 E7              .word LAB_PLOT-1         ; PLOT            VGC command
00F7DA  2  A6 E7              .word LAB_UNPLOT-1      ; UNPLOT          VGC command
00F7DC  2  C7 E7              .word LAB_GLINE-1       ; LINE            VGC command
00F7DE  2  06 E8              .word LAB_CIRCLE-1      ; CIRCLE          VGC command
00F7E0  2  37 E8              .word LAB_RECT-1         ; RECT            VGC command
00F7E2  2  76 E8              .word LAB_FILLRECT-1    ; FILL            VGC command
00F7E4  2  B5 E8              .word LAB_PAINT-1       ; PAINT           VGC command
00F7E6  2  67 E7              .word LAB_GMODE-1       ; MODE            VGC command
00F7E8  2  6E E7              .word LAB_GCLS-1        ; GCLS            VGC command
00F7EA  2  74 E7              .word LAB_GCOLOR-1      ; GCOLOR          VGC command
00F7EC  2  D6 E8              .word LAB_SPRCMD-1      ; SPRITE          VGC command
00F7EE  2  2D E9              .word LAB_SPRSHAPE-1    ; SPRITESHAPE     VGC command
00F7F0  2  40 E9              .word LAB_SPRCOLOR-1    ; SPRITESET       VGC command
00F7F2  2  8F E9              .word LAB_SPRDATA-1     ; SPRITEDATA      VGC command
00F7F4  2  30 EA              .word LAB_SOUND-1       ; SOUND           VGC command
00F7F6  2  5A EA              .word LAB_VOLUME-1      ; VOLUME          VGC command
00F7F8  2  66 EA              .word LAB_ENVELOPE-1    ; ENVELOPE        VGC command
00F7FA  2  9F EA              .word LAB_WAVE-1         ; WAVE            VGC command
00F7FC  2  A2 EA              .word LAB_VSYNC-1        ; VSYNC           wait for vblank
00F7FE  2               
00F7FE  2               ; function pre process routine table
00F7FE  2               
00F7FE  2               LAB_FTPL
00F7FE  2               LAB_FTPM    = LAB_FTPL+$01
00F7FE  2  4F CF              .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
00F800  2  4F CF              .word LAB_PPFN-1        ; INT(n)          "
00F802  2  4F CF              .word LAB_PPFN-1        ; ABS(n)          "
00F804  2  30 CC              .word LAB_EVEZ-1        ; USR(x)    process any expression
00F806  2  3A CD              .word LAB_1BF7-1        ; FRE(x)          "
00F808  2  3A CD              .word LAB_1BF7-1        ; POS(x)          "
00F80A  2  4F CF              .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
00F80C  2  4F CF              .word LAB_PPFN-1        ; RND(n)          "
00F80E  2  4F CF              .word LAB_PPFN-1        ; LOG(n)          "
00F810  2  4F CF              .word LAB_PPFN-1        ; EXP(n)          "
00F812  2  4F CF              .word LAB_PPFN-1        ; COS(n)          "
00F814  2  4F CF              .word LAB_PPFN-1        ; SIN(n)          "
00F816  2  4F CF              .word LAB_PPFN-1        ; TAN(n)          "
00F818  2  4F CF              .word LAB_PPFN-1        ; ATN(n)          "
00F81A  2  4F CF              .word LAB_PPFN-1        ; PEEK(n)         "
00F81C  2  4F CF              .word LAB_PPFN-1        ; DEEK(n)         "
00F81E  2  00 00              .word $0000             ; SADD()    none
00F820  2  49 CF              .word LAB_PPFS-1        ; LEN($)    process string expression in ()
00F822  2  4F CF              .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
00F824  2  49 CF              .word LAB_PPFS-1        ; VAL($)    process string expression in ()
00F826  2  49 CF              .word LAB_PPFS-1        ; ASC($)          "
00F828  2  49 CF              .word LAB_PPFS-1        ; UCASE$($)       "
00F82A  2  49 CF              .word LAB_PPFS-1        ; LCASE$($)       "
00F82C  2  4F CF              .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
00F82E  2  76 CF              .word LAB_BHSS-1        ; HEX$(n)         "
00F830  2  76 CF              .word LAB_BHSS-1        ; BIN$(n)         "
00F832  2  00 00              .word $0000             ; BITTST()  none
00F834  2  79 E3              .word LAB_MMPP-1        ; MAX()     process numeric expression
00F836  2  79 E3              .word LAB_MMPP-1        ; MIN()           "
00F838  2  55 CF              .word LAB_PPBI-1        ; PI        advance pointer
00F83A  2  55 CF              .word LAB_PPBI-1        ; TWOPI           "
00F83C  2  00 00              .word $0000             ; VARPTR()  none
00F83E  2  5A CF              .word LAB_LRMS-1        ; LEFT$()   process string expression
00F840  2  5A CF              .word LAB_LRMS-1        ; RIGHT$()        "
00F842  2  5A CF              .word LAB_LRMS-1        ; MID$()          "
00F844  2  4F CF              .word LAB_PPFN-1        ; SPRITEX(n)      VGC function
00F846  2  4F CF              .word LAB_PPFN-1        ; SPRITEY(n)      VGC function
00F848  2  4F CF              .word LAB_PPFN-1        ; COLLISION(n)    VGC function
00F84A  2  4F CF              .word LAB_PPFN-1        ; BUMPED(n)       VGC function
00F84C  2               
00F84C  2               ; action addresses for functions
00F84C  2               
00F84C  2               LAB_FTBL
00F84C  2               LAB_FTBM    = LAB_FTBL+$01
00F84C  2  00 DC              .word LAB_SGN-1         ; SGN()
00F84E  2  8A DC              .word LAB_INT-1         ; INT()
00F850  2  1D DC              .word LAB_ABS-1         ; ABS()
00F852  2  56 E0              .word LAB_USR-1         ; USR()
00F854  2  2F D3              .word LAB_FRE-1         ; FRE()
00F856  2  4E D3              .word LAB_POS-1         ; POS()
00F858  2  38 E4              .word LAB_SQR-1         ; SQR()
00F85A  2  A6 DF              .word LAB_RND-1         ; RND()           modified function
00F85C  2  04 DA              .word LAB_LOG-1         ; LOG()
00F85E  2  08 DF              .word LAB_EXP-1         ; EXP()
00F860  2  DA DF              .word LAB_COS-1         ; COS()
00F862  2  E1 DF              .word LAB_SIN-1         ; SIN()
00F864  2  2A E0              .word LAB_TAN-1         ; TAN()
00F866  2  5C E0              .word LAB_ATN-1         ; ATN()
00F868  2  FE D7              .word LAB_PEEK-1        ; PEEK()
00F86A  2  12 D8              .word LAB_DEEK-1        ; DEEK()          new function
00F86C  2  45 D7              .word LAB_SADD-1        ; SADD()          new function
00F86E  2  5E D7              .word LAB_LENS-1        ; LEN()
00F870  2  10 D4              .word LAB_STRS-1        ; STR$()
00F872  2  9D D7              .word LAB_VAL-1         ; VAL()
00F874  2  69 D7              .word LAB_ASC-1         ; ASC()
00F876  2  23 D7              .word LAB_UCASE-1       ; UCASE$()        new function
00F878  2  02 D7              .word LAB_LCASE-1       ; LCASE$()        new function
00F87A  2  74 D6              .word LAB_CHRS-1        ; CHR$()
00F87C  2  1D E2              .word LAB_HEXS-1        ; HEX$()          new function
00F87E  2  CE E1              .word LAB_BINS-1        ; BIN$()          new function
00F880  2  A6 E1              .word LAB_BTST-1        ; BITTST()        new function
00F882  2  7F E3              .word LAB_MAX-1         ; MAX()           new function
00F884  2  8F E3              .word LAB_MIN-1         ; MIN()           new function
00F886  2  D5 E4              .word LAB_PI-1          ; PI              new function
00F888  2  DF E4              .word LAB_TWOPI-1       ; TWOPI           new function
00F88A  2  C5 E4              .word LAB_VARPTR-1      ; VARPTR()        new function
00F88C  2  86 D6              .word LAB_LEFT-1        ; LEFT$()
00F88E  2  8F D6              .word LAB_RIGHT-1       ; RIGHT$()
00F890  2  BE D6              .word LAB_MIDS-1        ; MID$()
00F892  2  AB EA              .word LAB_SPRITEX-1     ; SPRITEX()       VGC function
00F894  2  BD EA              .word LAB_SPRITEY-1     ; SPRITEY()       VGC function
00F896  2  CF EA              .word LAB_COLLISION-1   ; COLLISION()     VGC function
00F898  2  D7 EA              .word LAB_BUMPED-1      ; BUMPED()        VGC function
00F89A  2               
00F89A  2               ; hierarchy and action addresses for operator
00F89A  2               
00F89A  2               LAB_OPPT
00F89A  2  79                 .byte $79               ; +
00F89B  2  CA D8              .word LAB_ADD-1
00F89D  2  79                 .byte $79               ; -
00F89E  2  AF D8              .word LAB_SUBTRACT-1
00F8A0  2  7B                 .byte $7B               ; *
00F8A1  2  45 DA              .word LAB_MULTIPLY-1
00F8A3  2  7B                 .byte $7B               ; /
00F8A4  2  0D DB              .word LAB_DIVIDE-1
00F8A6  2  7F                 .byte $7F               ; ^
00F8A7  2  C4 DE              .word LAB_POWER-1
00F8A9  2  50                 .byte $50               ; AND
00F8AA  2  BF CF              .word LAB_AND-1
00F8AC  2  46                 .byte $46               ; EOR             new operator
00F8AD  2  A5 CF              .word LAB_EOR-1
00F8AF  2  46                 .byte $46               ; OR
00F8B0  2  B2 CF              .word LAB_OR-1
00F8B2  2  56                 .byte $56               ; >>              new operator
00F8B3  2  6B D0              .word LAB_RSHIFT-1
00F8B5  2  56                 .byte $56               ; <<              new operator
00F8B6  2  53 D0              .word LAB_LSHIFT-1
00F8B8  2  7D                 .byte $7D               ; >
00F8B9  2  FD DE              .word LAB_GTHAN-1
00F8BB  2  5A                 .byte $5A               ; =
00F8BC  2  69 CD              .word LAB_EQUAL-1
00F8BE  2  64                 .byte $64               ; <
00F8BF  2  E0 CF              .word LAB_LTHAN-1
00F8C1  2               
00F8C1  2               ; keywords start with ..
00F8C1  2               ; this is the first character table and must be in alphabetic order
00F8C1  2               
00F8C1  2               TAB_1STC
00F8C1  2  2A                 .byte "*"
00F8C2  2  2B                 .byte "+"
00F8C3  2  2D                 .byte "-"
00F8C4  2  2F                 .byte "/"
00F8C5  2  3C                 .byte "<"
00F8C6  2  3D                 .byte "="
00F8C7  2  3E                 .byte ">"
00F8C8  2  3F                 .byte "?"
00F8C9  2  41                 .byte "A"
00F8CA  2  42                 .byte "B"
00F8CB  2  43                 .byte "C"
00F8CC  2  44                 .byte "D"
00F8CD  2  45                 .byte "E"
00F8CE  2  46                 .byte "F"
00F8CF  2  47                 .byte "G"
00F8D0  2  48                 .byte "H"
00F8D1  2  49                 .byte "I"
00F8D2  2  4C                 .byte "L"
00F8D3  2  4D                 .byte "M"
00F8D4  2  4E                 .byte "N"
00F8D5  2  4F                 .byte "O"
00F8D6  2  50                 .byte "P"
00F8D7  2  52                 .byte "R"
00F8D8  2  53                 .byte "S"
00F8D9  2  54                 .byte "T"
00F8DA  2  55                 .byte "U"
00F8DB  2  56                 .byte "V"
00F8DC  2  57                 .byte "W"
00F8DD  2  5E                 .byte "^"
00F8DE  2  00                 .byte $00               ; table terminator
00F8DF  2               
00F8DF  2               ; pointers to keyword tables
00F8DF  2               
00F8DF  2               TAB_CHRT
00F8DF  2  19 F9              .word TAB_STAR          ; table for "*"
00F8E1  2  1B F9              .word TAB_PLUS          ; table for "+"
00F8E3  2  1D F9              .word TAB_MNUS          ; table for "-"
00F8E5  2  1F F9              .word TAB_SLAS          ; table for "/"
00F8E7  2  21 F9              .word TAB_LESS          ; table for "<"
00F8E9  2  25 F9              .word TAB_EQUL          ; table for "="
00F8EB  2  27 F9              .word TAB_MORE          ; table for ">"
00F8ED  2  2B F9              .word TAB_QEST          ; table for "?"
00F8EF  2  2D F9              .word TAB_ASCA          ; table for "A"
00F8F1  2  3D F9              .word TAB_ASCB          ; table for "B"
00F8F3  2  5D F9              .word TAB_ASCC          ; table for "C"
00F8F5  2  8C F9              .word TAB_ASCD          ; table for "D"
00F8F7  2  A5 F9              .word TAB_ASCE          ; table for "E"
00F8F9  2  B4 F9              .word TAB_ASCF          ; table for "F"
00F8FB  2  C2 F9              .word TAB_ASCG          ; table for "G"
00F8FD  2  D9 F9              .word TAB_ASCH          ; table for "H"
00F8FF  2  DF F9              .word TAB_ASCI          ; table for "I"
00F901  2  FB F9              .word TAB_ASCL          ; table for "L"
00F903  2  2A FA              .word TAB_ASCM          ; table for "M"
00F905  2  3C FA              .word TAB_ASCN          ; table for "N"
00F907  2  4E FA              .word TAB_ASCO          ; table for "O"
00F909  2  56 FA              .word TAB_ASCP          ; table for "P"
00F90B  2  74 FA              .word TAB_ASCR          ; table for "R"
00F90D  2  A7 FA              .word TAB_ASCS          ; table for "S"
00F90F  2  0B FB              .word TAB_ASCT          ; table for "T"
00F911  2  1F FB              .word TAB_ASCU          ; table for "U"
00F913  2  36 FB              .word TAB_ASCV          ; table for "V"
00F915  2  4D FB              .word TAB_ASCW          ; table for "W"
00F917  2  60 FB              .word TAB_POWR          ; table for "^"
00F919  2               
00F919  2               ; tables for each start character, note if a longer keyword with the same start
00F919  2               ; letters as a shorter one exists then it must come first, else the list is in
00F919  2               ; alphabetical order as follows ..
00F919  2               
00F919  2               ; [keyword,token
00F919  2               ; [keyword,token]]
00F919  2               ; end marker (#$00)
00F919  2               
00F919  2               TAB_STAR
00F919  2  CE 00              .byte TK_MUL,$00        ; *
00F91B  2               TAB_PLUS
00F91B  2  CC 00              .byte TK_PLUS,$00       ; +
00F91D  2               TAB_MNUS
00F91D  2  CD 00              .byte TK_MINUS,$00      ; -
00F91F  2               TAB_SLAS
00F91F  2  CF 00              .byte TK_DIV,$00        ; /
00F921  2               TAB_LESS
00F921  2               LBB_LSHIFT
00F921  2  3C D5              .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
00F923  2  D8                 .byte TK_LT             ; <
00F924  2  00                 .byte $00
00F925  2               TAB_EQUL
00F925  2  D7 00              .byte TK_EQUAL,$00      ; =
00F927  2               TAB_MORE
00F927  2               LBB_RSHIFT
00F927  2  3E D4              .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
00F929  2  D6                 .byte TK_GT             ; >
00F92A  2  00                 .byte $00
00F92B  2               TAB_QEST
00F92B  2  9F 00              .byte TK_PRINT,$00      ; ?
00F92D  2               TAB_ASCA
00F92D  2               LBB_ABS
00F92D  2  42 53 28 DB        .byte "BS(",TK_ABS      ; ABS(
00F931  2               LBB_AND
00F931  2  4E 44 D1           .byte "ND",TK_AND       ; AND
00F934  2               LBB_ASC
00F934  2  53 43 28 ED        .byte "SC(",TK_ASC      ; ASC(
00F938  2               LBB_ATN
00F938  2  54 4E 28 E6        .byte "TN(",TK_ATN      ; ATN(
00F93C  2  00                 .byte $00
00F93D  2               TAB_ASCB
00F93D  2               LBB_BINS
00F93D  2  49 4E 24 28        .byte "IN$(",TK_BINS    ; BIN$(
00F941  2  F2           
00F942  2               LBB_BITCLR
00F942  2  49 54 43 4C        .byte "ITCLR",TK_BITCLR ; BITCLR
00F946  2  52 A8        
00F948  2               LBB_BITSET
00F948  2  49 54 53 45        .byte "ITSET",TK_BITSET ; BITSET
00F94C  2  54 A7        
00F94E  2               LBB_BITTST
00F94E  2  49 54 54 53        .byte "ITTST(",TK_BITTST
00F952  2  54 28 F3     
00F955  2                                             ; BITTST(
00F955  2               LBB_BUMPED
00F955  2  55 4D 50 45        .byte "UMPED(",TK_BUMPED ; BUMPED(
00F959  2  44 28 FF     
00F95C  2  00                 .byte $00
00F95D  2               TAB_ASCC
00F95D  2               LBB_CALL
00F95D  2  41 4C 4C 9C        .byte "ALL",TK_CALL     ; CALL
00F961  2               LBB_CHRS
00F961  2  48 52 24 28        .byte "HR$(",TK_CHRS    ; CHR$(
00F965  2  F0           
00F966  2               LBB_CIRCLE
00F966  2  49 52 43 4C        .byte "IRCLE",TK_CIRCLE ; CIRCLE
00F96A  2  45 B1        
00F96C  2               LBB_CLEAR
00F96C  2  4C 45 41 52        .byte "LEAR",TK_CLEAR   ; CLEAR
00F970  2  A2           
00F971  2               LBB_CLS
00F971  2  4C 53 AB           .byte "LS",TK_CLS       ; CLS
00F974  2               LBB_COLLISION
00F974  2  4F 4C 4C 49        .byte "OLLISION(",TK_COLLISION
00F978  2  53 49 4F 4E  
00F97C  2  28 FE        
00F97E  2                                             ; COLLISION(
00F97E  2               LBB_COLOR
00F97E  2  4F 4C 4F 52        .byte "OLOR",TK_COLOR   ; COLOR
00F982  2  AC           
00F983  2               LBB_CONT
00F983  2  4F 4E 54 A0        .byte "ONT",TK_CONT     ; CONT
00F987  2               LBB_COS
00F987  2  4F 53 28 E3        .byte "OS(",TK_COS      ; COS(
00F98B  2  00                 .byte $00
00F98C  2               TAB_ASCD
00F98C  2               LBB_DATA
00F98C  2  41 54 41 83        .byte "ATA",TK_DATA     ; DATA
00F990  2               LBB_DEC
00F990  2  45 43 88           .byte "EC",TK_DEC       ; DEC
00F993  2               LBB_DEEK
00F993  2  45 45 4B 28        .byte "EEK(",TK_DEEK    ; DEEK(
00F997  2  E8           
00F998  2               LBB_DEF
00F998  2  45 46 99           .byte "EF",TK_DEF       ; DEF
00F99B  2               LBB_DIM
00F99B  2  49 4D 85           .byte "IM",TK_DIM       ; DIM
00F99E  2               LBB_DOKE
00F99E  2  4F 4B 45 9B        .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
00F9A2  2               LBB_DO
00F9A2  2  4F 9D              .byte "O",TK_DO         ; DO
00F9A4  2  00                 .byte $00
00F9A5  2               TAB_ASCE
00F9A5  2               LBB_ELSE
00F9A5  2  4C 53 45 C2        .byte "LSE",TK_ELSE     ; ELSE
00F9A9  2               LBB_END
00F9A9  2  4E 44 80           .byte "ND",TK_END       ; END
00F9AC  2               LBB_EOR
00F9AC  2  4F 52 D2           .byte "OR",TK_EOR       ; EOR
00F9AF  2               LBB_EXP
00F9AF  2  58 50 28 E2        .byte "XP(",TK_EXP      ; EXP(
00F9B3  2  00                 .byte $00
00F9B4  2               TAB_ASCF
00F9B4  2               LBB_FILL
00F9B4  2  49 4C 4C B3        .byte "ILL",TK_FILLRECT ; FILL
00F9B8  2               LBB_FN
00F9B8  2  4E C4              .byte "N",TK_FN         ; FN
00F9BA  2               LBB_FOR
00F9BA  2  4F 52 81           .byte "OR",TK_FOR       ; FOR
00F9BD  2               LBB_FRE
00F9BD  2  52 45 28 DD        .byte "RE(",TK_FRE      ; FRE(
00F9C1  2  00                 .byte $00
00F9C2  2               TAB_ASCG
00F9C2  2               LBB_GET
00F9C2  2  45 54 A5           .byte "ET",TK_GET       ; GET
00F9C5  2               LBB_GOSUB
00F9C5  2  4F 53 55 42        .byte "OSUB",TK_GOSUB   ; GOSUB
00F9C9  2  8D           
00F9CA  2               LBB_GOTO
00F9CA  2  4F 54 4F 89        .byte "OTO",TK_GOTO     ; GOTO
00F9CE  2               LBB_GCLS
00F9CE  2  43 4C 53 B6        .byte "CLS",TK_GCLS     ; GCLS
00F9D2  2               LBB_GCOLOR
00F9D2  2  43 4F 4C 4F        .byte "COLOR",TK_GCOLOR ; GCOLOR
00F9D6  2  52 B7        
00F9D8  2  00                 .byte $00
00F9D9  2               TAB_ASCH
00F9D9  2               LBB_HEXS
00F9D9  2  45 58 24 28        .byte "EX$(",TK_HEXS    ; HEX$(
00F9DD  2  F1           
00F9DE  2  00                 .byte $00
00F9DF  2               TAB_ASCI
00F9DF  2               LBB_IF
00F9DF  2  46 8B              .byte "F",TK_IF         ; IF
00F9E1  2               LBB_INC
00F9E1  2  4E 43 95           .byte "NC",TK_INC       ; INC
00F9E4  2               LBB_INPUT
00F9E4  2  4E 50 55 54        .byte "NPUT",TK_INPUT   ; INPUT
00F9E8  2  84           
00F9E9  2               LBB_INSTRUMENT
00F9E9  2  4E 53 54 52        .byte "NSTRUMENT",TK_ENVELOPE
00F9ED  2  55 4D 45 4E  
00F9F1  2  54 BE        
00F9F3  2                                             ; INSTRUMENT
00F9F3  2               LBB_INT
00F9F3  2  4E 54 28 DA        .byte "NT(",TK_INT      ; INT(
00F9F7  2               LBB_IRQ
00F9F7  2  52 51 A9           .byte "RQ",TK_IRQ       ; IRQ
00F9FA  2  00                 .byte $00
00F9FB  2               TAB_ASCL
00F9FB  2               LBB_LCASES
00F9FB  2  43 41 53 45        .byte "CASE$(",TK_LCASES
00F9FF  2  24 28 EF     
00FA02  2                                             ; LCASE$(
00FA02  2               LBB_LEFTS
00FA02  2  45 46 54 24        .byte "EFT$(",TK_LEFTS  ; LEFT$(
00FA06  2  28 F9        
00FA08  2               LBB_LEN
00FA08  2  45 4E 28 EA        .byte "EN(",TK_LEN      ; LEN(
00FA0C  2               LBB_LET
00FA0C  2  45 54 87           .byte "ET",TK_LET       ; LET
00FA0F  2               LBB_LINE
00FA0F  2  49 4E 45 B0        .byte "INE",TK_LINE     ; LINE
00FA13  2               LBB_LIST
00FA13  2  49 53 54 A1        .byte "IST",TK_LIST     ; LIST
00FA17  2               LBB_LOAD
00FA17  2  4F 41 44 97        .byte "OAD",TK_LOAD     ; LOAD
00FA1B  2               LBB_LOCATE
00FA1B  2  4F 43 41 54        .byte "OCATE",TK_LOCATE ; LOCATE
00FA1F  2  45 AD        
00FA21  2               LBB_LOG
00FA21  2  4F 47 28 E1        .byte "OG(",TK_LOG      ; LOG(
00FA25  2               LBB_LOOP
00FA25  2  4F 4F 50 9E        .byte "OOP",TK_LOOP     ; LOOP
00FA29  2  00                 .byte $00
00FA2A  2               TAB_ASCM
00FA2A  2               LBB_MAX
00FA2A  2  41 58 28 F4        .byte "AX(",TK_MAX      ; MAX(
00FA2E  2               LBB_MIDS
00FA2E  2  49 44 24 28        .byte "ID$(",TK_MIDS    ; MID$(
00FA32  2  FB           
00FA33  2               LBB_MIN
00FA33  2  49 4E 28 F5        .byte "IN(",TK_MIN      ; MIN(
00FA37  2               LBB_MODE
00FA37  2  4F 44 45 B5        .byte "ODE",TK_GMODE    ; MODE
00FA3B  2  00                 .byte $00
00FA3C  2               TAB_ASCN
00FA3C  2               LBB_NEW
00FA3C  2  45 57 A3           .byte "EW",TK_NEW       ; NEW
00FA3F  2               LBB_NEXT
00FA3F  2  45 58 54 82        .byte "EXT",TK_NEXT     ; NEXT
00FA43  2               LBB_NMI
00FA43  2  4D 49 AA           .byte "MI",TK_NMI       ; NMI
00FA46  2               LBB_NOT
00FA46  2  4F 54 C7           .byte "OT",TK_NOT       ; NOT
00FA49  2               LBB_NULL
00FA49  2  55 4C 4C 94        .byte "ULL",TK_NULL     ; NULL
00FA4D  2  00                 .byte $00
00FA4E  2               TAB_ASCO
00FA4E  2               LBB_OFF
00FA4E  2  46 46 CB           .byte "FF",TK_OFF       ; OFF
00FA51  2               LBB_ON
00FA51  2  4E 93              .byte "N",TK_ON         ; ON
00FA53  2               LBB_OR
00FA53  2  52 D3              .byte "R",TK_OR         ; OR
00FA55  2  00                 .byte $00
00FA56  2               TAB_ASCP
00FA56  2               LBB_PAINT
00FA56  2  41 49 4E 54        .byte "AINT",TK_PAINT   ; PAINT
00FA5A  2  B4           
00FA5B  2               LBB_PEEK
00FA5B  2  45 45 4B 28        .byte "EEK(",TK_PEEK    ; PEEK(
00FA5F  2  E7           
00FA60  2               LBB_PI
00FA60  2  49 F6              .byte "I",TK_PI         ; PI
00FA62  2               LBB_PLOT
00FA62  2  4C 4F 54 AE        .byte "LOT",TK_PLOT     ; PLOT
00FA66  2               LBB_POKE
00FA66  2  4F 4B 45 9A        .byte "OKE",TK_POKE     ; POKE
00FA6A  2               LBB_POS
00FA6A  2  4F 53 28 DE        .byte "OS(",TK_POS      ; POS(
00FA6E  2               LBB_PRINT
00FA6E  2  52 49 4E 54        .byte "RINT",TK_PRINT   ; PRINT
00FA72  2  9F           
00FA73  2  00                 .byte $00
00FA74  2               TAB_ASCR
00FA74  2               LBB_READ
00FA74  2  45 41 44 86        .byte "EAD",TK_READ     ; READ
00FA78  2               LBB_RECT
00FA78  2  45 43 54 B2        .byte "ECT",TK_RECT     ; RECT
00FA7C  2               LBB_REM
00FA7C  2  45 4D 91           .byte "EM",TK_REM       ; REM
00FA7F  2               LBB_RESTORE
00FA7F  2  45 53 54 4F        .byte "ESTORE",TK_RESTORE
00FA83  2  52 45 8C     
00FA86  2                                             ; RESTORE
00FA86  2               LBB_RETIRQ
00FA86  2  45 54 49 52        .byte "ETIRQ",TK_RETIRQ ; RETIRQ
00FA8A  2  51 8E        
00FA8C  2               LBB_RETNMI
00FA8C  2  45 54 4E 4D        .byte "ETNMI",TK_RETNMI ; RETNMI
00FA90  2  49 8F        
00FA92  2               LBB_RETURN
00FA92  2  45 54 55 52        .byte "ETURN",TK_RETURN ; RETURN
00FA96  2  4E 90        
00FA98  2               LBB_RIGHTS
00FA98  2  49 47 48 54        .byte "IGHT$(",TK_RIGHTS
00FA9C  2  24 28 FA     
00FA9F  2                                             ; RIGHT$(
00FA9F  2               LBB_RND
00FA9F  2  4E 44 28 E0        .byte "ND(",TK_RND      ; RND(
00FAA3  2               LBB_RUN
00FAA3  2  55 4E 8A           .byte "UN",TK_RUN       ; RUN
00FAA6  2  00                 .byte $00
00FAA7  2               TAB_ASCS
00FAA7  2               LBB_SADD
00FAA7  2  41 44 44 28        .byte "ADD(",TK_SADD    ; SADD(
00FAAB  2  E9           
00FAAC  2               LBB_SAVE
00FAAC  2  41 56 45 98        .byte "AVE",TK_SAVE     ; SAVE
00FAB0  2               LBB_SGN
00FAB0  2  47 4E 28 D9        .byte "GN(",TK_SGN      ; SGN(
00FAB4  2               LBB_SIN
00FAB4  2  49 4E 28 E4        .byte "IN(",TK_SIN      ; SIN(
00FAB8  2               LBB_SOUND
00FAB8  2  4F 55 4E 44        .byte "OUND",TK_SOUND   ; SOUND
00FABC  2  BC           
00FABD  2               LBB_SPC
00FABD  2  50 43 28 C5        .byte "PC(",TK_SPC      ; SPC(
00FAC1  2               LBB_SPRITESET
00FAC1  2  50 52 49 54        .byte "PRITESET",TK_SPRCOLOR
00FAC5  2  45 53 45 54  
00FAC9  2  BA           
00FACA  2                                             ; SPRITESET
00FACA  2               LBB_SPRITEDATA
00FACA  2  50 52 49 54        .byte "PRITEDATA",TK_SPRDATA
00FACE  2  45 44 41 54  
00FAD2  2  41 BB        
00FAD4  2                                             ; SPRITEDATA
00FAD4  2               LBB_SPRITESHAPE
00FAD4  2  50 52 49 54        .byte "PRITESHAPE",TK_SPRSHAPE
00FAD8  2  45 53 48 41  
00FADC  2  50 45 B9     
00FADF  2                                             ; SPRITESHAPE
00FADF  2               LBB_SPRITEX
00FADF  2  50 52 49 54        .byte "PRITEX(",TK_SPRITEX
00FAE3  2  45 58 28 FC  
00FAE7  2                                             ; SPRITEX(
00FAE7  2               LBB_SPRITEY
00FAE7  2  50 52 49 54        .byte "PRITEY(",TK_SPRITEY
00FAEB  2  45 59 28 FD  
00FAEF  2                                             ; SPRITEY(
00FAEF  2               LBB_SPRITE
00FAEF  2  50 52 49 54        .byte "PRITE",TK_SPRCMD ; SPRITE
00FAF3  2  45 B8        
00FAF5  2               LBB_SQR
00FAF5  2  51 52 28 DF        .byte "QR(",TK_SQR      ; SQR(
00FAF9  2               LBB_STEP
00FAF9  2  54 45 50 C8        .byte "TEP",TK_STEP     ; STEP
00FAFD  2               LBB_STOP
00FAFD  2  54 4F 50 92        .byte "TOP",TK_STOP     ; STOP
00FB01  2               LBB_STRS
00FB01  2  54 52 24 28        .byte "TR$(",TK_STRS    ; STR$(
00FB05  2  EB           
00FB06  2               LBB_SWAP
00FB06  2  57 41 50 A6        .byte "WAP",TK_SWAP     ; SWAP
00FB0A  2  00                 .byte $00
00FB0B  2               TAB_ASCT
00FB0B  2               LBB_TAB
00FB0B  2  41 42 28 C1        .byte "AB(",TK_TAB      ; TAB(
00FB0F  2               LBB_TAN
00FB0F  2  41 4E 28 E5        .byte "AN(",TK_TAN      ; TAN(
00FB13  2               LBB_THEN
00FB13  2  48 45 4E C6        .byte "HEN",TK_THEN     ; THEN
00FB17  2               LBB_TO
00FB17  2  4F C3              .byte "O",TK_TO         ; TO
00FB19  2               LBB_TWOPI
00FB19  2  57 4F 50 49        .byte "WOPI",TK_TWOPI   ; TWOPI
00FB1D  2  F7           
00FB1E  2  00                 .byte $00
00FB1F  2               TAB_ASCU
00FB1F  2               LBB_UCASES
00FB1F  2  43 41 53 45        .byte "CASE$(",TK_UCASES
00FB23  2  24 28 EE     
00FB26  2                                             ; UCASE$(
00FB26  2               LBB_UNPLOT
00FB26  2  4E 50 4C 4F        .byte "NPLOT",TK_UNPLOT ; UNPLOT
00FB2A  2  54 AF        
00FB2C  2               LBB_UNTIL
00FB2C  2  4E 54 49 4C        .byte "NTIL",TK_UNTIL   ; UNTIL
00FB30  2  C9           
00FB31  2               LBB_USR
00FB31  2  53 52 28 DC        .byte "SR(",TK_USR      ; USR(
00FB35  2  00                 .byte $00
00FB36  2               TAB_ASCV
00FB36  2               LBB_VAL
00FB36  2  41 4C 28 EC        .byte "AL(",TK_VAL      ; VAL(
00FB3A  2               LBB_VPTR
00FB3A  2  41 52 50 54        .byte "ARPTR(",TK_VPTR  ; VARPTR(
00FB3E  2  52 28 F8     
00FB41  2               LBB_VOLUME
00FB41  2  4F 4C 55 4D        .byte "OLUME",TK_VOLUME ; VOLUME
00FB45  2  45 BD        
00FB47  2               LBB_VSYNC
00FB47  2  53 59 4E 43        .byte "SYNC",TK_VSYNC   ; VSYNC
00FB4B  2  C0           
00FB4C  2  00                 .byte $00
00FB4D  2               TAB_ASCW
00FB4D  2               LBB_WAIT
00FB4D  2  41 49 54 96        .byte "AIT",TK_WAIT     ; WAIT
00FB51  2               LBB_WAVE
00FB51  2  41 56 45 BF        .byte "AVE",TK_WAVE     ; WAVE
00FB55  2               LBB_WHILE
00FB55  2  48 49 4C 45        .byte "HILE",TK_WHILE   ; WHILE
00FB59  2  CA           
00FB5A  2               LBB_WIDTH
00FB5A  2  49 44 54 48        .byte "IDTH",TK_WIDTH   ; WIDTH
00FB5E  2  A4           
00FB5F  2  00                 .byte $00
00FB60  2               TAB_POWR
00FB60  2  D0 00              .byte TK_POWER,$00      ; ^
00FB62  2               
00FB62  2               ; new decode table for LIST
00FB62  2               ; Table is ..
00FB62  2               ; byte - keyword length, keyword first character
00FB62  2               ; word - pointer to rest of keyword from dictionary
00FB62  2               
00FB62  2               ; note if length is 1 then the pointer is ignored
00FB62  2               
00FB62  2               LAB_KEYT
00FB62  2  03 45              .byte 3,'E'
00FB64  2  A9 F9              .word LBB_END           ; END
00FB66  2  03 46              .byte 3,'F'
00FB68  2  BA F9              .word LBB_FOR           ; FOR
00FB6A  2  04 4E              .byte 4,'N'
00FB6C  2  3F FA              .word LBB_NEXT          ; NEXT
00FB6E  2  04 44              .byte 4,'D'
00FB70  2  8C F9              .word LBB_DATA          ; DATA
00FB72  2  05 49              .byte 5,'I'
00FB74  2  E4 F9              .word LBB_INPUT         ; INPUT
00FB76  2  03 44              .byte 3,'D'
00FB78  2  9B F9              .word LBB_DIM           ; DIM
00FB7A  2  04 52              .byte 4,'R'
00FB7C  2  74 FA              .word LBB_READ          ; READ
00FB7E  2  03 4C              .byte 3,'L'
00FB80  2  0C FA              .word LBB_LET           ; LET
00FB82  2  03 44              .byte 3,'D'
00FB84  2  90 F9              .word LBB_DEC           ; DEC
00FB86  2  04 47              .byte 4,'G'
00FB88  2  CA F9              .word LBB_GOTO          ; GOTO
00FB8A  2  03 52              .byte 3,'R'
00FB8C  2  A3 FA              .word LBB_RUN           ; RUN
00FB8E  2  02 49              .byte 2,'I'
00FB90  2  DF F9              .word LBB_IF            ; IF
00FB92  2  07 52              .byte 7,'R'
00FB94  2  7F FA              .word LBB_RESTORE       ; RESTORE
00FB96  2  05 47              .byte 5,'G'
00FB98  2  C5 F9              .word LBB_GOSUB         ; GOSUB
00FB9A  2  06 52              .byte 6,'R'
00FB9C  2  86 FA              .word LBB_RETIRQ        ; RETIRQ
00FB9E  2  06 52              .byte 6,'R'
00FBA0  2  8C FA              .word LBB_RETNMI        ; RETNMI
00FBA2  2  06 52              .byte 6,'R'
00FBA4  2  92 FA              .word LBB_RETURN        ; RETURN
00FBA6  2  03 52              .byte 3,'R'
00FBA8  2  7C FA              .word LBB_REM           ; REM
00FBAA  2  04 53              .byte 4,'S'
00FBAC  2  FD FA              .word LBB_STOP          ; STOP
00FBAE  2  02 4F              .byte 2,'O'
00FBB0  2  51 FA              .word LBB_ON            ; ON
00FBB2  2  04 4E              .byte 4,'N'
00FBB4  2  49 FA              .word LBB_NULL          ; NULL
00FBB6  2  03 49              .byte 3,'I'
00FBB8  2  E1 F9              .word LBB_INC           ; INC
00FBBA  2  04 57              .byte 4,'W'
00FBBC  2  4D FB              .word LBB_WAIT          ; WAIT
00FBBE  2  04 4C              .byte 4,'L'
00FBC0  2  17 FA              .word LBB_LOAD          ; LOAD
00FBC2  2  04 53              .byte 4,'S'
00FBC4  2  AC FA              .word LBB_SAVE          ; SAVE
00FBC6  2  03 44              .byte 3,'D'
00FBC8  2  98 F9              .word LBB_DEF           ; DEF
00FBCA  2  04 50              .byte 4,'P'
00FBCC  2  66 FA              .word LBB_POKE          ; POKE
00FBCE  2  04 44              .byte 4,'D'
00FBD0  2  9E F9              .word LBB_DOKE          ; DOKE
00FBD2  2  04 43              .byte 4,'C'
00FBD4  2  5D F9              .word LBB_CALL          ; CALL
00FBD6  2  02 44              .byte 2,'D'
00FBD8  2  A2 F9              .word LBB_DO            ; DO
00FBDA  2  04 4C              .byte 4,'L'
00FBDC  2  25 FA              .word LBB_LOOP          ; LOOP
00FBDE  2  05 50              .byte 5,'P'
00FBE0  2  6E FA              .word LBB_PRINT         ; PRINT
00FBE2  2  04 43              .byte 4,'C'
00FBE4  2  83 F9              .word LBB_CONT          ; CONT
00FBE6  2  04 4C              .byte 4,'L'
00FBE8  2  13 FA              .word LBB_LIST          ; LIST
00FBEA  2  05 43              .byte 5,'C'
00FBEC  2  6C F9              .word LBB_CLEAR         ; CLEAR
00FBEE  2  03 4E              .byte 3,'N'
00FBF0  2  3C FA              .word LBB_NEW           ; NEW
00FBF2  2  05 57              .byte 5,'W'
00FBF4  2  5A FB              .word LBB_WIDTH         ; WIDTH
00FBF6  2  03 47              .byte 3,'G'
00FBF8  2  C2 F9              .word LBB_GET           ; GET
00FBFA  2  04 53              .byte 4,'S'
00FBFC  2  06 FB              .word LBB_SWAP          ; SWAP
00FBFE  2  06 42              .byte 6,'B'
00FC00  2  48 F9              .word LBB_BITSET        ; BITSET
00FC02  2  06 42              .byte 6,'B'
00FC04  2  42 F9              .word LBB_BITCLR        ; BITCLR
00FC06  2  03 49              .byte 3,'I'
00FC08  2  F7 F9              .word LBB_IRQ           ; IRQ
00FC0A  2  03 4E              .byte 3,'N'
00FC0C  2  43 FA              .word LBB_NMI           ; NMI
00FC0E  2  03 43              .byte 3,'C'
00FC10  2  71 F9              .word LBB_CLS           ; CLS
00FC12  2  05 43              .byte 5,'C'
00FC14  2  7E F9              .word LBB_COLOR         ; COLOR
00FC16  2  06 4C              .byte 6,'L'
00FC18  2  1B FA              .word LBB_LOCATE        ; LOCATE
00FC1A  2  04 50              .byte 4,'P'
00FC1C  2  62 FA              .word LBB_PLOT          ; PLOT
00FC1E  2  06 55              .byte 6,'U'
00FC20  2  26 FB              .word LBB_UNPLOT        ; UNPLOT
00FC22  2  04 4C              .byte 4,'L'
00FC24  2  0F FA              .word LBB_LINE          ; LINE
00FC26  2  06 43              .byte 6,'C'
00FC28  2  66 F9              .word LBB_CIRCLE        ; CIRCLE
00FC2A  2  04 52              .byte 4,'R'
00FC2C  2  78 FA              .word LBB_RECT          ; RECT
00FC2E  2  04 46              .byte 4,'F'
00FC30  2  B4 F9              .word LBB_FILL          ; FILL
00FC32  2  05 50              .byte 5,'P'
00FC34  2  56 FA              .word LBB_PAINT         ; PAINT
00FC36  2  04 4D              .byte 4,'M'
00FC38  2  37 FA              .word LBB_MODE          ; MODE
00FC3A  2  04 47              .byte 4,'G'
00FC3C  2  CE F9              .word LBB_GCLS          ; GCLS
00FC3E  2  06 47              .byte 6,'G'
00FC40  2  D2 F9              .word LBB_GCOLOR        ; GCOLOR
00FC42  2  06 53              .byte 6,'S'
00FC44  2  EF FA              .word LBB_SPRITE        ; SPRITE
00FC46  2  0B 53              .byte 11,'S'
00FC48  2  D4 FA              .word LBB_SPRITESHAPE   ; SPRITESHAPE
00FC4A  2  09 53              .byte 9,'S'
00FC4C  2  C1 FA              .word LBB_SPRITESET     ; SPRITESET
00FC4E  2  0A 53              .byte 10,'S'
00FC50  2  CA FA              .word LBB_SPRITEDATA    ; SPRITEDATA
00FC52  2  05 53              .byte 5,'S'
00FC54  2  B8 FA              .word LBB_SOUND         ; SOUND
00FC56  2  06 56              .byte 6,'V'
00FC58  2  41 FB              .word LBB_VOLUME        ; VOLUME
00FC5A  2  0A 49              .byte 10,'I'
00FC5C  2  E9 F9              .word LBB_INSTRUMENT    ; INSTRUMENT
00FC5E  2  04 57              .byte 4,'W'
00FC60  2  51 FB              .word LBB_WAVE          ; WAVE
00FC62  2  05 56              .byte 5,'V'
00FC64  2  47 FB              .word LBB_VSYNC         ; VSYNC
00FC66  2               
00FC66  2               ; secondary commands (can't start a statement)
00FC66  2               
00FC66  2  04 54              .byte 4,'T'
00FC68  2  0B FB              .word LBB_TAB           ; TAB
00FC6A  2  04 45              .byte 4,'E'
00FC6C  2  A5 F9              .word LBB_ELSE          ; ELSE
00FC6E  2  02 54              .byte 2,'T'
00FC70  2  17 FB              .word LBB_TO            ; TO
00FC72  2  02 46              .byte 2,'F'
00FC74  2  B8 F9              .word LBB_FN            ; FN
00FC76  2  04 53              .byte 4,'S'
00FC78  2  BD FA              .word LBB_SPC           ; SPC
00FC7A  2  04 54              .byte 4,'T'
00FC7C  2  13 FB              .word LBB_THEN          ; THEN
00FC7E  2  03 4E              .byte 3,'N'
00FC80  2  46 FA              .word LBB_NOT           ; NOT
00FC82  2  04 53              .byte 4,'S'
00FC84  2  F9 FA              .word LBB_STEP          ; STEP
00FC86  2  05 55              .byte 5,'U'
00FC88  2  2C FB              .word LBB_UNTIL         ; UNTIL
00FC8A  2  05 57              .byte 5,'W'
00FC8C  2  55 FB              .word LBB_WHILE         ; WHILE
00FC8E  2  03 4F              .byte 3,'O'
00FC90  2  4E FA              .word LBB_OFF           ; OFF
00FC92  2               
00FC92  2               ; opperators
00FC92  2               
00FC92  2  01 2B              .byte 1,'+'
00FC94  2  00 00              .word $0000             ; +
00FC96  2  01 2D              .byte 1,'-'
00FC98  2  00 00              .word $0000             ; -
00FC9A  2  01 2A              .byte 1,'*'
00FC9C  2  00 00              .word $0000             ; *
00FC9E  2  01 2F              .byte 1,'/'
00FCA0  2  00 00              .word $0000             ; /
00FCA2  2  01 5E              .byte 1,'^'
00FCA4  2  00 00              .word $0000             ; ^
00FCA6  2  03 41              .byte 3,'A'
00FCA8  2  31 F9              .word LBB_AND           ; AND
00FCAA  2  03 45              .byte 3,'E'
00FCAC  2  AC F9              .word LBB_EOR           ; EOR
00FCAE  2  02 4F              .byte 2,'O'
00FCB0  2  53 FA              .word LBB_OR            ; OR
00FCB2  2  02 3E              .byte 2,'>'
00FCB4  2  27 F9              .word LBB_RSHIFT        ; >>
00FCB6  2  02 3C              .byte 2,'<'
00FCB8  2  21 F9              .word LBB_LSHIFT        ; <<
00FCBA  2  01 3E              .byte 1,'>'
00FCBC  2  00 00              .word $0000             ; >
00FCBE  2  01 3D              .byte 1,'='
00FCC0  2  00 00              .word $0000             ; =
00FCC2  2  01 3C              .byte 1,'<'
00FCC4  2  00 00              .word $0000             ; <
00FCC6  2               
00FCC6  2               ; functions
00FCC6  2               
00FCC6  2  04 53              .byte 4,'S'             ;
00FCC8  2  B0 FA              .word LBB_SGN           ; SGN
00FCCA  2  04 49              .byte 4,'I'             ;
00FCCC  2  F3 F9              .word LBB_INT           ; INT
00FCCE  2  04 41              .byte 4,'A'             ;
00FCD0  2  2D F9              .word LBB_ABS           ; ABS
00FCD2  2  04 55              .byte 4,'U'             ;
00FCD4  2  31 FB              .word LBB_USR           ; USR
00FCD6  2  04 46              .byte 4,'F'             ;
00FCD8  2  BD F9              .word LBB_FRE           ; FRE
00FCDA  2  04 50              .byte 4,'P'             ;
00FCDC  2  6A FA              .word LBB_POS           ; POS
00FCDE  2  04 53              .byte 4,'S'             ;
00FCE0  2  F5 FA              .word LBB_SQR           ; SQR
00FCE2  2  04 52              .byte 4,'R'             ;
00FCE4  2  9F FA              .word LBB_RND           ; RND
00FCE6  2  04 4C              .byte 4,'L'             ;
00FCE8  2  21 FA              .word LBB_LOG           ; LOG
00FCEA  2  04 45              .byte 4,'E'             ;
00FCEC  2  AF F9              .word LBB_EXP           ; EXP
00FCEE  2  04 43              .byte 4,'C'             ;
00FCF0  2  87 F9              .word LBB_COS           ; COS
00FCF2  2  04 53              .byte 4,'S'             ;
00FCF4  2  B4 FA              .word LBB_SIN           ; SIN
00FCF6  2  04 54              .byte 4,'T'             ;
00FCF8  2  0F FB              .word LBB_TAN           ; TAN
00FCFA  2  04 41              .byte 4,'A'             ;
00FCFC  2  38 F9              .word LBB_ATN           ; ATN
00FCFE  2  05 50              .byte 5,'P'             ;
00FD00  2  5B FA              .word LBB_PEEK          ; PEEK
00FD02  2  05 44              .byte 5,'D'             ;
00FD04  2  93 F9              .word LBB_DEEK          ; DEEK
00FD06  2  05 53              .byte 5,'S'             ;
00FD08  2  A7 FA              .word LBB_SADD          ; SADD
00FD0A  2  04 4C              .byte 4,'L'             ;
00FD0C  2  08 FA              .word LBB_LEN           ; LEN
00FD0E  2  05 53              .byte 5,'S'             ;
00FD10  2  01 FB              .word LBB_STRS          ; STR$
00FD12  2  04 56              .byte 4,'V'             ;
00FD14  2  36 FB              .word LBB_VAL           ; VAL
00FD16  2  04 41              .byte 4,'A'             ;
00FD18  2  34 F9              .word LBB_ASC           ; ASC
00FD1A  2  07 55              .byte 7,'U'             ;
00FD1C  2  1F FB              .word LBB_UCASES        ; UCASE$
00FD1E  2  07 4C              .byte 7,'L'             ;
00FD20  2  FB F9              .word LBB_LCASES        ; LCASE$
00FD22  2  05 43              .byte 5,'C'             ;
00FD24  2  61 F9              .word LBB_CHRS          ; CHR$
00FD26  2  05 48              .byte 5,'H'             ;
00FD28  2  D9 F9              .word LBB_HEXS          ; HEX$
00FD2A  2  05 42              .byte 5,'B'             ;
00FD2C  2  3D F9              .word LBB_BINS          ; BIN$
00FD2E  2  07 42              .byte 7,'B'             ;
00FD30  2  4E F9              .word LBB_BITTST        ; BITTST
00FD32  2  04 4D              .byte 4,'M'             ;
00FD34  2  2A FA              .word LBB_MAX           ; MAX
00FD36  2  04 4D              .byte 4,'M'             ;
00FD38  2  33 FA              .word LBB_MIN           ; MIN
00FD3A  2  02 50              .byte 2,'P'             ;
00FD3C  2  60 FA              .word LBB_PI            ; PI
00FD3E  2  05 54              .byte 5,'T'             ;
00FD40  2  19 FB              .word LBB_TWOPI         ; TWOPI
00FD42  2  07 56              .byte 7,'V'             ;
00FD44  2  3A FB              .word LBB_VPTR          ; VARPTR
00FD46  2  06 4C              .byte 6,'L'             ;
00FD48  2  02 FA              .word LBB_LEFTS         ; LEFT$
00FD4A  2  07 52              .byte 7,'R'             ;
00FD4C  2  98 FA              .word LBB_RIGHTS        ; RIGHT$
00FD4E  2  05 4D              .byte 5,'M'             ;
00FD50  2  2E FA              .word LBB_MIDS          ; MID$
00FD52  2  08 53              .byte 8,'S'             ;
00FD54  2  DF FA              .word LBB_SPRITEX       ; SPRITEX(
00FD56  2  08 53              .byte 8,'S'             ;
00FD58  2  E7 FA              .word LBB_SPRITEY       ; SPRITEY(
00FD5A  2  0A 43              .byte 10,'C'            ;
00FD5C  2  74 F9              .word LBB_COLLISION     ; COLLISION(
00FD5E  2  07 42              .byte 7,'B'             ;
00FD60  2  55 F9              .word LBB_BUMPED        ; BUMPED(
00FD62  2               
00FD62  2               ; BASIC messages, mostly error messages
00FD62  2               
00FD62  2               LAB_BAER
00FD62  2  86 FD              .word ERR_NF            ;$00 NEXT without FOR
00FD64  2  97 FD              .word ERR_SN            ;$02 syntax
00FD66  2  9E FD              .word ERR_RG            ;$04 RETURN without GOSUB
00FD68  2  B3 FD              .word ERR_OD            ;$06 out of data
00FD6A  2  BF FD              .word ERR_FC            ;$08 function call
00FD6C  2  CD FD              .word ERR_OV            ;$0A overflow
00FD6E  2  D6 FD              .word ERR_OM            ;$0C out of memory
00FD70  2  E4 FD              .word ERR_US            ;$0E undefined statement
00FD72  2  F8 FD              .word ERR_BS            ;$10 array bounds
00FD74  2  05 FE              .word ERR_DD            ;$12 double dimension array
00FD76  2  16 FE              .word ERR_D0            ;$14 divide by 0
00FD78  2  25 FE              .word ERR_ID            ;$16 illegal direct
00FD7A  2  34 FE              .word ERR_TM            ;$18 type mismatch
00FD7C  2  42 FE              .word ERR_LS            ;$1A long string
00FD7E  2  52 FE              .word ERR_ST            ;$1C string too complex
00FD80  2  65 FE              .word ERR_CN            ;$1E continue error
00FD82  2  74 FE              .word ERR_UF            ;$20 undefined function
00FD84  2  87 FE              .word ERR_LD            ;$22 LOOP without DO
00FD86  2               
00FD86  2               ; I may implement these two errors to force definition of variables and
00FD86  2               ; dimensioning of arrays before use.
00FD86  2               
00FD86  2               ;     .word ERR_UV            ;$24 undefined variable
00FD86  2               
00FD86  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00FD86  2               
00FD86  2               ;     .word ERR_UA            ;$26 undimensioned array
00FD86  2               
00FD86  2  4E 45 58 54  ERR_NF      .byte "NEXT without FOR",$00
00FD8A  2  20 77 69 74  
00FD8E  2  68 6F 75 74  
00FD97  2  53 79 6E 74  ERR_SN      .byte "Syntax",$00
00FD9B  2  61 78 00     
00FD9E  2  52 45 54 55  ERR_RG      .byte "RETURN without GOSUB",$00
00FDA2  2  52 4E 20 77  
00FDA6  2  69 74 68 6F  
00FDB3  2  4F 75 74 20  ERR_OD      .byte "Out of DATA",$00
00FDB7  2  6F 66 20 44  
00FDBB  2  41 54 41 00  
00FDBF  2  46 75 6E 63  ERR_FC      .byte "Function call",$00
00FDC3  2  74 69 6F 6E  
00FDC7  2  20 63 61 6C  
00FDCD  2  4F 76 65 72  ERR_OV      .byte "Overflow",$00
00FDD1  2  66 6C 6F 77  
00FDD5  2  00           
00FDD6  2  4F 75 74 20  ERR_OM      .byte "Out of memory",$00
00FDDA  2  6F 66 20 6D  
00FDDE  2  65 6D 6F 72  
00FDE4  2  55 6E 64 65  ERR_US      .byte "Undefined statement",$00
00FDE8  2  66 69 6E 65  
00FDEC  2  64 20 73 74  
00FDF8  2  41 72 72 61  ERR_BS      .byte "Array bounds",$00
00FDFC  2  79 20 62 6F  
00FE00  2  75 6E 64 73  
00FE05  2  44 6F 75 62  ERR_DD      .byte "Double dimension",$00
00FE09  2  6C 65 20 64  
00FE0D  2  69 6D 65 6E  
00FE16  2  44 69 76 69  ERR_D0      .byte "Divide by zero",$00
00FE1A  2  64 65 20 62  
00FE1E  2  79 20 7A 65  
00FE25  2  49 6C 6C 65  ERR_ID      .byte "Illegal direct",$00
00FE29  2  67 61 6C 20  
00FE2D  2  64 69 72 65  
00FE34  2  54 79 70 65  ERR_TM      .byte "Type mismatch",$00
00FE38  2  20 6D 69 73  
00FE3C  2  6D 61 74 63  
00FE42  2  53 74 72 69  ERR_LS      .byte "String too long",$00
00FE46  2  6E 67 20 74  
00FE4A  2  6F 6F 20 6C  
00FE52  2  53 74 72 69  ERR_ST      .byte "String too complex",$00
00FE56  2  6E 67 20 74  
00FE5A  2  6F 6F 20 63  
00FE65  2  43 61 6E 27  ERR_CN      .byte "Can't continue",$00
00FE69  2  74 20 63 6F  
00FE6D  2  6E 74 69 6E  
00FE74  2  55 6E 64 65  ERR_UF      .byte "Undefined function",$00
00FE78  2  66 69 6E 65  
00FE7C  2  64 20 66 75  
00FE87  2  4C 4F 4F 50  ERR_LD      .byte "LOOP without DO",$00
00FE8B  2  20 77 69 74  
00FE8F  2  68 6F 75 74  
00FE97  2               
00FE97  2               ;ERR_UV     .byte "Undefined variable",$00
00FE97  2               
00FE97  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00FE97  2               
00FE97  2               ;ERR_UA     .byte "Undimensioned array",$00
00FE97  2               
00FE97  2  0D 0A 42 72  LAB_BMSG    .byte $0D,$0A,"Break",$00
00FE9B  2  65 61 6B 00  
00FE9F  2  20 45 72 72  LAB_EMSG    .byte " Error",$00
00FEA3  2  6F 72 00     
00FEA6  2  20 69 6E 20  LAB_LMSG    .byte " in line ",$00
00FEAA  2  6C 69 6E 65  
00FEAE  2  20 00        
00FEB0  2  0D 0A 52 65  LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
00FEB4  2  61 64 79 0D  
00FEB8  2  0A 00        
00FEBA  2               
00FEBA  2  20 45 78 74  LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
00FEBE  2  72 61 20 69  
00FEC2  2  67 6E 6F 72  
00FECB  2  20 52 65 64  LAB_REDO    .byte " Redo from start",$0D,$0A,$00
00FECF  2  6F 20 66 72  
00FED3  2  6F 6D 20 73  
00FEDE  2               
00FEDE  2               AA_end_basic
00FEDE  2               
00FEDE  1               
00FEDE  1               ; put the IRQ and MNI code in RAM so that it can be changed
00FEDE  1               
00FEDE  1               IRQ_vec     = VEC_SV+2        ; IRQ code vector
00FEDE  1               NMI_vec     = IRQ_vec+$0A     ; NMI code vector
00FEDE  1               
00FEDE  1               ; setup for the 6502 simulator environment
00FEDE  1               
00FEDE  1               IO_AREA     = $F000           ; set I/O area for this monitor
00FEDE  1               
00FEDE  1               ACIAsimwr   = $A00E           ; VGC CHAROUT
00FEDE  1               ACIAsimrd   = $A00F           ; VGC CHARIN
00FEDE  1               
00FEDE  1               ; now the code. all this does is set up the vectors and interrupt code
00FEDE  1               ; then jump directly to BASIC cold start.
00FEDE  1               
00FEDE  1                     .segment "MONITOR"
00FEDE  1                     .org    $FF80
00FF80  1               
00FF80  1               ; reset vector points here
00FF80  1               
00FF80  1               RES_vec
00FF80  1  D8                 CLD                     ; clear decimal mode
00FF81  1  A2 FF              LDX   #$FF              ; empty stack
00FF83  1  9A                 TXS                     ; set the stack
00FF84  1               
00FF84  1               ; set up vectors and interrupt code, copy them to page 2
00FF84  1               
00FF84  1  A0 1C              LDY   #END_CODE-LAB_vec ; set index/count
00FF86  1               LAB_stlp
00FF86  1  B9 9E FF           LDA   LAB_vec-1,Y       ; get byte from interrupt code
00FF89  1  99 04 02           STA   VEC_IN-1,Y        ; save to RAM
00FF8C  1  88                 DEY                     ; decrement index/count
00FF8D  1  D0 F7              BNE   LAB_stlp          ; loop if more to do
00FF8F  1               
00FF8F  1  4C 00 C0           JMP   LAB_COLD          ; always do EhBASIC cold start
00FF92  1               
00FF92  1               ; byte out to simulated ACIA
00FF92  1               
00FF92  1               ACIAout
00FF92  1  8D 0E A0           STA   ACIAsimwr         ; save byte to simulated ACIA
00FF95  1  60                 RTS
00FF96  1               
00FF96  1               ; byte in from simulated ACIA
00FF96  1               
00FF96  1               ACIAin
00FF96  1  AD 0F A0           LDA   ACIAsimrd         ; get byte from simulated ACIA
00FF99  1  F0 02              BEQ   LAB_nobyw         ; branch if no byte waiting
00FF9B  1               
00FF9B  1  38                 SEC                     ; flag byte received
00FF9C  1  60                 RTS
00FF9D  1               
00FF9D  1               LAB_nobyw
00FF9D  1  18                 CLC                     ; flag no byte received
00FF9E  1  60                 RTS
00FF9F  1               
00FF9F  1               ; vector tables
00FF9F  1               
00FF9F  1               LAB_vec
00FF9F  1  96 FF              .word ACIAin            ; byte in from simulated ACIA
00FFA1  1  92 FF              .word ACIAout           ; byte out to simulated ACIA
00FFA3  1  3D EB              .word LAB_FLOAD         ; load vector for EhBASIC
00FFA5  1  E0 EA              .word LAB_FSAVE         ; save vector for EhBASIC
00FFA7  1               
00FFA7  1               ; EhBASIC IRQ support
00FFA7  1               
00FFA7  1               IRQ_CODE
00FFA7  1  48                 PHA                     ; save A
00FFA8  1  A5 DF              LDA   IrqBase           ; get the IRQ flag byte
00FFAA  1  4A                 LSR                     ; shift the set b7 to b6, and on down ...
00FFAB  1  05 DF              ORA   IrqBase           ; OR the original back in
00FFAD  1  85 DF              STA   IrqBase           ; save the new IRQ flag byte
00FFAF  1  68                 PLA                     ; restore A
00FFB0  1  40                 RTI
00FFB1  1               
00FFB1  1               ; EhBASIC NMI support
00FFB1  1               
00FFB1  1               NMI_CODE
00FFB1  1  48                 PHA                     ; save A
00FFB2  1  A5 DC              LDA   NmiBase           ; get the NMI flag byte
00FFB4  1  4A                 LSR                     ; shift the set b7 to b6, and on down ...
00FFB5  1  05 DC              ORA   NmiBase           ; OR the original back in
00FFB7  1  85 DC              STA   NmiBase           ; save the new NMI flag byte
00FFB9  1  68                 PLA                     ; restore A
00FFBA  1  40                 RTI
00FFBB  1               
00FFBB  1               END_CODE
00FFBB  1               
00FFBB  1               ; system vectors
00FFBB  1               
00FFBB  1                     .segment "VECTORS"
00FFBB  1                     .org    $FFFA
00FFFA  1               
00FFFA  1  17 02              .word NMI_vec           ; NMI vector
00FFFC  1  80 FF              .word RES_vec           ; RESET vector
00FFFE  1  0D 02              .word IRQ_vec           ; IRQ vector
00FFFE  1               
