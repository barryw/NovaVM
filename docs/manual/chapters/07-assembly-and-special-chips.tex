\chapter{Assembly and Special Chips}

\begin{retrobox}
\textit{``To understand what the machine is actually doing, you have to speak \\
its language --- and that language is always closer to the metal \\
than any other abstraction on top of it.''}
\end{retrobox}

\bigskip

NovaBASIC is built on a 6502 core and runs on top of a set of memory-mapped
coprocessors. Most programs never need to touch hardware registers directly, but
knowing where everything lives gives you the full picture: why certain address ranges
are reserved, what BASIC commands actually do at the hardware level, and how to write
assembly routines that cooperate cleanly with the BASIC runtime.

%% ============================================================
\section{The Memory Map}
%% ============================================================

The full 64 KB address space is partitioned as follows:

\begin{center}
\begin{tabular}{llll}
\textbf{Range} & \textbf{Size} & \textbf{Purpose} & \textbf{Access} \\
\hline
\texttt{\$0000}--\texttt{\$00FF} & 256 B  & Zero Page                       & R/W \\
\texttt{\$0100}--\texttt{\$01FF} & 256 B  & Stack                           & R/W \\
\texttt{\$0200}--\texttt{\$027F} & 128 B  & System Vectors                  & R/W \\
\texttt{\$0280}--\texttt{\$9FFF} & ~39 KB & BASIC RAM                       & R/W \\
\texttt{\$A000}--\texttt{\$A01E} &  31 B  & VGC Registers                   & R/W \\
\texttt{\$A100}--\texttt{\$A1FF} & 256 B  & Sound Controller (VSC)          & R/W \\
\texttt{\$AA00}--\texttt{\$B1CF} & 2000 B & Character RAM (80$\times$25)    & R/W \\
\texttt{\$B1D0}--\texttt{\$B99F} & 2000 B & Color RAM (80$\times$25)        & R/W \\
\texttt{\$B9A0}--\texttt{\$B9EF} &  80 B  & File I/O Controller (FIO)       & R/W \\
\texttt{\$BA00}--\texttt{\$BA3F} &  64 B  & Expansion Memory Controller (XMC) & R/W \\
\texttt{\$BC00}--\texttt{\$BFFF} & 1024 B & XRAM Windows (when mapped)      & R/W \\
\texttt{\$C000}--\texttt{\$FFFF} &  16 KB & ROM (NovaBASIC)                 & R only \\
\end{tabular}
\end{center}

Everything from \texttt{\$A000} upward through \texttt{\$BFFF} is hardware I/O or
managed window space. Writing to ROM (\texttt{\$C000}+) has no effect.

\subsection*{System Vectors at \texttt{\$0200}}

At boot, NovaBASIC initializes a vector table at page \texttt{\$02} with the base
addresses of each hardware controller. Assembly code can read these rather than
hard-coding addresses, so programs remain compatible if the memory map is adjusted
in a future ROM version:

\begin{center}
\begin{tabular}{lll}
\textbf{Address} & \textbf{Value} & \textbf{Meaning} \\
\hline
\texttt{\$0200}--\texttt{\$0201} & \texttt{\$A000} & VGC base \\
\texttt{\$0202}--\texttt{\$0203} & \texttt{\$A010} & VGC command register \\
\texttt{\$0204}--\texttt{\$0205} & \texttt{\$AA00} & Character RAM base \\
\texttt{\$0206}--\texttt{\$0207} & \texttt{\$B1D0} & Color RAM base \\
\texttt{\$0208}--\texttt{\$0209} & \texttt{\$A100} & VSC base \\
\texttt{\$020A}--\texttt{\$020B} & \texttt{\$B9A0} & FIO base \\
\texttt{\$020C}--\texttt{\$020D} & \texttt{\$BA00} & XMC base \\
\end{tabular}
\end{center}

Each entry is a 16-bit little-endian address stored at the indicated pair.

%% ============================================================
\section{Talking to Hardware from BASIC}
%% ============================================================

Because the hardware controllers are memory-mapped, you can read and write their
registers with ordinary \cmd{PEEK} and \cmd{POKE} calls from BASIC. This is the
simplest way to experiment with hardware state or build lightweight diagnostic tools.

\subsection*{Reading the frame counter}

The VGC increments a frame counter register at \texttt{\$A008} on every display
frame. Reading it gives you a running frame tick useful for timing and animation:

\begin{retrobox}
\texttt{PRINT PEEK(40968)}
\end{retrobox}

\texttt{\$A008} = 40968 decimal. The counter wraps from 255 to 0 (it is an 8-bit
register).

\subsection*{Checking the active sprite count}

\begin{retrobox}
\texttt{PRINT "SPRITES: ";PEEK(40969)}
\end{retrobox}

\texttt{\$A009} = 40969 decimal. This read-only register holds the number of
currently enabled sprites.

\subsection*{Reading keyboard input}

\begin{retrobox}
\texttt{K = PEEK(40975)}
\end{retrobox}

\texttt{\$A00F} = 40975 decimal. This is the VGC character input register. Reading
it returns the last character received, or 0 if none. BASIC's own \cmd{INKEY\$}
command uses the same register.

\subsection*{Character output}

Writing a character code to \texttt{\$A00E} (40974 decimal) emits that character to
the current cursor position, exactly as BASIC's \cmd{PRINT} does internally:

\begin{retrobox}
\texttt{POKE 40974,65}\\
\texttt{REM prints the letter A}
\end{retrobox}

%% ============================================================
\section{The CALL and USR Interface}
%% ============================================================

NovaBASIC provides two ways to execute machine code from within a BASIC program.

\subsection*{\cmd{CALL addr}}

Performs a \texttt{JSR} to \emph{addr}. Execution resumes in BASIC after the
machine-code routine executes an \texttt{RTS}. There is no parameter passing;
\cmd{CALL} is a simple subroutine jump. You are responsible for preserving
CPU registers if the routine will return to BASIC in a clean state.

\begin{retrobox}
\texttt{10 CALL 49152}\\
\texttt{REM jumps to machine code at \$C000}
\end{retrobox}

\subsection*{\cmd{USR(x)}}

Calls a user-defined machine-code routine, passing the numeric value \emph{x}
through the 6502 floating-point accumulator (FAC). The routine can read, modify,
and return a value through the same register. \cmd{USR(x)} is a numeric function
and its result can be used in an expression:

\begin{retrobox}
\texttt{10 V = USR(42)}\\
\texttt{20 PRINT "RESULT: ";V}
\end{retrobox}

The address of the USR routine is set by storing a 16-bit pointer in the
appropriate zero-page location before calling. Consult the EhBASIC 2.22
documentation for the exact zero-page addresses used by the USR vector.

%% ============================================================
\section{Interrupts}
%% ============================================================

The 6502 supports two interrupt lines: the maskable IRQ and the non-maskable NMI.
NovaBASIC lets you handle both from within a BASIC program, which is useful for
writing interrupt-driven input handlers, timing routines, and co-operative
multitasking sketches.

\subsection*{Setting up a handler: \cmd{IRQ linenumber} and \cmd{NMI linenumber}}

\begin{retrobox}
\texttt{10 IRQ 1000}\\
\texttt{20 NMI 2000}
\end{retrobox}

When an IRQ fires, execution branches to line 1000. When an NMI fires, execution
branches to line 2000. The handlers are ordinary BASIC subroutines.

\subsection*{Returning from a handler: \cmd{RETIRQ} and \cmd{RETNMI}}

The last statement in an IRQ handler must be \cmd{RETIRQ}; the last statement in
an NMI handler must be \cmd{RETNMI}. These are not interchangeable with
\cmd{RETURN} --- they restore the correct CPU state and re-enable the interrupt
flag.

\begin{retrobox}
\texttt{1000 REM IRQ handler}\\
\texttt{1010 PRINT "IRQ FIRED"}\\
\texttt{1020 RETIRQ}\\[4pt]
\texttt{2000 REM NMI handler}\\
\texttt{2010 PRINT "NMI FIRED"}\\
\texttt{2020 RETNMI}
\end{retrobox}

\begin{warningbox}
Interrupt handlers run in the context of the BASIC interpreter. Keep them short.
Avoid file I/O, heavy computation, or anything that re-enters the interpreter in
an unexpected state. Long handlers can cause instability.
\end{warningbox}

%% ============================================================
\section{XMC Assembly Helpers}
%% ============================================================

The NovaBASIC ROM exports a set of labelled helper routines for accessing the XMC
from assembly code. Using these helpers instead of writing to XMC registers directly
keeps your code clean and gives you error detection for free.

All helpers follow the same convention: on return, \textbf{carry clear} means
success and \textbf{carry set} means an error occurred, with the XMC error code
in the accumulator.

\begin{center}
\begin{tabular}{lp{8cm}}
\textbf{Label} & \textbf{Purpose} \\
\hline
\texttt{LAB\_XM\_SETADDR} & Set the 24-bit XRAM address: A = low byte, X = mid byte, Y = high byte. \\
\texttt{LAB\_XM\_STATUS}  & Read status snapshot: A = status register, X = error code. \\
\texttt{LAB\_XM\_GETBYTE} & Read byte at current XADDR: A = value on success. \\
\texttt{LAB\_XM\_PUTBYTE} & Write byte at current XADDR: A = value to write. \\
\texttt{LAB\_XM\_STASH}   & Bulk copy RAM to XRAM (preload XMC\_RAML/H, XMC\_LENL/H). \\
\texttt{LAB\_XM\_FETCH}   & Bulk copy XRAM to RAM (preload XMC\_RAML/H, XMC\_LENL/H). \\
\texttt{LAB\_XM\_FILL}    & Fill XRAM range with a byte value (preload XMC\_DATA, XMC\_LENL/H). \\
\texttt{LAB\_XM\_ALLOC}   & Allocate a block: preload XMC\_LENL/H; XADDR and handle returned in registers. \\
\end{tabular}
\end{center}

\subsection*{Example: reading one byte from XRAM in assembly}

\begin{retrobox}
\texttt{; Set 24-bit address 0x010000 (bank 1, offset 0)}\\
\texttt{LDA \#\$00}\\
\texttt{LDX \#\$00}\\
\texttt{LDY \#\$01}\\
\texttt{JSR LAB\_XM\_SETADDR}\\[4pt]
\texttt{JSR LAB\_XM\_GETBYTE}\\
\texttt{BCS error}\\
\texttt{; A now holds the byte value}
\end{retrobox}

\begin{notebox}
The ROM helper labels are defined in the NovaBASIC assembly source
(\texttt{ehbasic/basic.asm}). If you assemble custom ROM extensions or overlays,
link against the same symbol file to pick up these addresses.
\end{notebox}

%% ============================================================
\section{VGC Register-Level Programming}
%% ============================================================

The VGC command pipeline works by writing parameters to registers
\texttt{\$A011}--\texttt{\$A01E}, then writing the command byte to \texttt{\$A010}.
The VGC executes the command synchronously. This is exactly what every graphics
BASIC command does under the hood.

From assembly you can issue any VGC command directly:

\begin{retrobox}
\texttt{; Issue GCLS command (clear graphics layer)}\\
\texttt{LDA \#\$07}\\
\texttt{STA \$A010}
\end{retrobox}

The full VGC command code reference, including copper commands
(\$1B--\$1E) and memory I/O commands (\$19--\$1A), is documented in
Appendix~\ref{chap:memmap}.

%% ============================================================
\section{SID Chip Access}
%% ============================================================

The SID chip registers at \$D400--\$D41C are write-intercepted within the ROM
address range. Assembly code can write to them directly:

\begin{retrobox}
\texttt{; Set voice 0 to sawtooth waveform, gate on}\\
\texttt{LDA \#\$21}\\
\texttt{STA \$D404}
\end{retrobox}

The SID register layout matches the MOS 6581. Per-voice registers occupy 7
bytes each (voice~0 at \$D400, voice~1 at \$D407, voice~2 at \$D40E). Filter
and volume registers are at \$D415--\$D418. See Appendix~\ref{chap:memmap}
for the full register map.

\begin{warningbox}
The BASIC \cmd{INSTRUMENT}, \cmd{SOUND}, and \cmd{MUSIC} commands manage
SID registers automatically. Direct SID register writes from assembly will
conflict with the music engine unless you stop all music and SFX first.
\end{warningbox}

%% ============================================================
\section{Copper Programming from Assembly}
%% ============================================================

From BASIC, the \texttt{COPPER} keyword provides high-level access
(see Chapter~\ref{chap:graphics}). From assembly, write parameters to
\$A011--\$A016 and the command code to \$A010:

\begin{retrobox}
\texttt{; Add copper event: at Y=50, X=0, set BgCol to color 5}\\
\texttt{LDA \#\$00 : STA \$A011}\\
\texttt{LDA \#\$00 : STA \$A012}\\
\texttt{LDA \#50  : STA \$A013}\\
\texttt{LDA \#\$01 : STA \$A014}\\
\texttt{LDA \#\$00 : STA \$A015}\\
\texttt{LDA \#\$05 : STA \$A016}\\
\texttt{LDA \#\$1B : STA \$A010}\\[4pt]
\texttt{; Enable copper}\\
\texttt{LDA \#\$1D : STA \$A010}
\end{retrobox}

See the Copper section in Chapter~\ref{chap:graphics} for a full explanation
of writable registers, the COPPER keyword syntax, and programming patterns.

%% ============================================================
\section{DMA Controller from Assembly}
\label{sec:asm-dma}
%% ============================================================

The DMA controller at \$BA60 transfers data between six unified memory
spaces. The pattern is: load parameters into registers, then write \$01
to the command register to start.

\begin{lstlisting}[style=basiclisting]
10 REM -- DMA copy 2000 bytes from CPU $6000 to char RAM --
20 POKE $BA63, 0   : REM source space = CPU RAM
30 POKE $BA64, 1   : REM dest space = Char RAM
40 POKE $BA65, 0   : POKE $BA66, $60 : POKE $BA67, 0
50 REM source addr = $6000 (low, mid, high)
60 POKE $BA68, 0   : POKE $BA69, 0  : POKE $BA6A, 0
70 REM dest addr = 0 (start of char RAM)
80 POKE $BA6B, $D0 : POKE $BA6C, $07 : POKE $BA6D, 0
90 REM length = 2000 ($07D0)
100 POKE $BA6E, 0  : REM mode = copy (not fill)
110 POKE $BA60, 1  : REM start!
120 IF PEEK($BA61) = 1 THEN 120 : REM poll until not busy
130 IF PEEK($BA61) <> 2 THEN PRINT "Error:"; PEEK($BA62)
\end{lstlisting}

For fill mode, set bit 0 of \texttt{DmaMode} (\$BA6E) and load the fill byte
into \texttt{DmaFillValue} (\$BA6F).

%% ============================================================
\section{Blitter from Assembly}
\label{sec:asm-blitter}
%% ============================================================

The blitter at \$BA80 performs 2D rectangular copies and fills with row
stride. Set up source and destination addresses, width, height, and stride,
then write \$01 to \texttt{BltCmd}.

\begin{lstlisting}[style=basiclisting]
10 REM -- Scroll color RAM up by 1 row using blitter --
20 REM Source: row 1 (offset 80), Dest: row 0 (offset 0)
30 REM Width: 80, Height: 24, Stride: 80
40 POKE $BA83, 2  : POKE $BA84, 2   : REM src/dst = color RAM
50 POKE $BA85, 80 : POKE $BA86, 0   : POKE $BA87, 0
60 REM source offset = 80 (row 1)
70 POKE $BA88, 0  : POKE $BA89, 0   : POKE $BA8A, 0
80 REM dest offset = 0 (row 0)
90 POKE $BA8B, 80 : POKE $BA8C, 0   : REM width = 80
100 POKE $BA8D, 24 : POKE $BA8E, 0  : REM height = 24
110 POKE $BA8F, 80 : POKE $BA90, 0  : REM src stride = 80
120 POKE $BA91, 80 : POKE $BA92, 0  : REM dst stride = 80
130 POKE $BA93, 0  : REM mode = copy
140 POKE $BA80, 1  : REM start!
150 IF PEEK($BA81) = 1 THEN 150
\end{lstlisting}

Color-key mode: set bit 1 of \texttt{BltMode} (\$BA93) and load the
transparent color into \texttt{BltColorKey} (\$BA95). Source pixels
matching the color key are skipped.

%% ============================================================
\section{Network Controller from Assembly}
\label{sec:asm-nic}
%% ============================================================

The NIC at \$A100 provides TCP networking. To connect as a client from
register-level code:

\begin{lstlisting}[style=basiclisting]
10 REM -- Connect to 127.0.0.1 port 8080 --
20 POKE $A102, 0          : REM slot 0
30 REM Write hostname to name buffer ($A120+)
40 H$ = "127.0.0.1"
50 FOR I = 1 TO LEN(H$)
60   POKE $A11F + I, ASC(MID$(H$, I, 1))
70 NEXT I
80 POKE $A11F + LEN(H$) + 1, 0 : REM null terminate
90 POKE $A108, $90 : POKE $A109, $1F : REM port 8080
100 POKE $A100, 1  : REM connect command
110 REM Poll slot status for connected bit
120 IF (PEEK($A118) AND 1) = 0 THEN 120
\end{lstlisting}

To send data, copy the message into CPU RAM, then set \texttt{NicDmaAddrL/H}
and \texttt{NicDmaLen}, and write \$03 to \texttt{NicCmd}. To receive, write
\$04 and read \texttt{NicMsgLen} for the actual length.

%% ============================================================
\section{Timer from Assembly}
\label{sec:asm-timer}
%% ============================================================

The timer at \$BA40 fires an IRQ every \textit{N} video frames.
To set up a 1-second timer (60 frames):

\begin{lstlisting}[style=basiclisting]
10 IRQ 1000
20 POKE $BA42, 60 : POKE $BA43, 0  : REM divisor = 60
30 POKE $BA40, 1                    : REM enable timer
40 GOTO 40
1000 PRINT "TICK ";
1010 RETIRQ
\end{lstlisting}

Reading \texttt{TimerStatus} (\$BA41) clears the pending IRQ flag. The
timer must be disabled with \cmd{POKE \$BA40, 0} before changing the divisor.

%% ============================================================
\section{Try It Now}
%% ============================================================

\begin{retrobox}
\textbf{Read the frame counter via PEEK}\\[4pt]
\texttt{10 REM Read frame counter via PEEK}\\
\texttt{20 FOR I=1 TO 60:VSYNC:NEXT I}\\
\texttt{30 PRINT "FRAMES: ";PEEK(40968)}
\end{retrobox}

\texttt{\$A008} = 40968 decimal. After 60 \cmd{VSYNC} waits (approximately one
second at 60 Hz), the frame counter register reflects the elapsed frame ticks.
The value will be somewhere in the range 0--255 because the counter wraps after
256 frames. Run the program several times and observe how the value changes.
