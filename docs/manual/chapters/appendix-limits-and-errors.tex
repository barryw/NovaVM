% =============================================================================
% Appendix: Limits, Errors, and Edge Cases
% NovaBASIC v1.0 User Guide
% Source of truth: ehbasic/basic.asm
%                  e6502.Avalonia/Hardware/FileIoController.cs
%                  e6502.Avalonia/Hardware/VirtualGraphicsController.cs
%                  e6502.Avalonia/Hardware/VirtualDmaController.cs
%                  e6502.Avalonia/Hardware/VirtualBlitterController.cs
%                  e6502.Avalonia/Hardware/VirtualNetworkController.cs
%                  e6502.Avalonia/Hardware/VirtualExpansionMemoryController.cs
% =============================================================================
\chapter{Limits, Errors, and Edge Cases}

This appendix documents all known numeric limits, argument validation rules,
and edge-case behaviors derived from a direct audit of the ROM source and the
Avalonia hardware controller implementations.
Where ROM behavior and host behavior differ, both are noted.

% =============================================================================
\section{Numeric Argument Conversion Rules}
% =============================================================================

Most command arguments are passed through one of two shared ROM helpers
before reaching the hardware layer.
Understanding their constraints prevents unexpected function-call errors.

\begin{longtable}{>{\ttfamily\raggedright\arraybackslash}p{0.26\textwidth} p{0.64\textwidth}}
\toprule
\normalfont\textbf{Helper} & \textbf{Behavior} \\
\midrule
\endhead
\bottomrule
\endfoot
LAB\_GTBY & Converts the FAC (floating-point accumulator) to an unsigned byte.
             Accepts values 0--255.
             Any value outside this range, or any negative value, raises a
             function-call error before the command reaches the hardware. \\
LAB\_GTWRD & Converts the FAC to an unsigned 16-bit integer.
              Accepts values 0--65535.
              Negative values or values above 65535 raise a function-call error. \\
\end{longtable}

\begin{warningbox}
Commands that accept addresses (\cmd{POKE}, \cmd{DOKE}, \cmd{CALL}, \cmd{WAIT}, \cmd{STASH}, \cmd{FETCH}\ldots)
route through \cmd{LAB\_GTWRD}.
Passing a value such as \texttt{-1} will raise an error rather than
wrapping to \texttt{\$FFFF}.
\end{warningbox}

% =============================================================================
\section{File Command Limits}
% =============================================================================

\begin{longtable}{p{0.30\textwidth} p{0.60\textwidth}}
\toprule
\textbf{Topic} & \textbf{Behavior} \\
\midrule
\endhead
\bottomrule
\endfoot
Filename length &
  The ROM filename parser accepts 1--63 characters.
  A length of 0 or greater than 63 causes the FIO controller to return an
  I/O error (the \cmd{ReadFilename} guard in \texttt{FileIoController.cs}). \\
Allowed filename characters &
  The host implementation enforces the pattern \texttt{[A-Za-z0-9\_.\textbackslash-]+}.
  Any character outside this set causes \cmd{ReadFilename} to return \texttt{null}
  and the operation to fail with \cmd{FioErrIo}. \\
\texttt{.bas} extension &
  If the filename does not already end in \texttt{.bas} (case-insensitive),
  the host appends it automatically before forming the filesystem path. \\
Missing file &
  \cmd{LOAD "name"} and \cmd{DEL "name"} on a non-existent file set
  \texttt{FioStatus=\$03} and \texttt{FioErrCode=\$01} (\cmd{FioErrNotFound}).
  The ROM interprets this as ``File not found''. \\
I/O fault &
  Any OS-level exception during \cmd{SAVE}/\cmd{LOAD}/\cmd{DEL} sets
  \texttt{FioStatus=\$03} and \texttt{FioErrCode=\$02} (\cmd{FioErrIo}).
  The ROM surfaces this as ``I/O Error''. \\
\cmd{SAVE} end address &
  If \texttt{FioEndH:FioEndL} $\leq$ \texttt{FioSrcH:FioSrcL}, the save
  is rejected immediately with \cmd{FioErrIo} before the file is opened. \\
\cmd{DIR} on empty catalog &
  \cmd{DirOpen} sets \texttt{FioStatus=\$03}/\texttt{FioErrCode=\$03}
  (\cmd{FioErrEndOfDir}) when no \texttt{.bas} files exist.
  The ROM \cmd{DIR} handler treats this as a silent empty listing. \\
\cmd{DIR} after last entry &
  Each \cmd{DirRead} beyond the final file sets \cmd{FioErrEndOfDir};
  the ROM stops iterating. \\
\end{longtable}

% =============================================================================
\section{Graphics and Sprite Edge Cases}
% =============================================================================

\begin{longtable}{p{0.32\textwidth} p{0.58\textwidth}}
\toprule
\textbf{Command / Feature} & \textbf{Limit and edge behavior} \\
\midrule
\endhead
\bottomrule
\endfoot
\cmd{GCOLOR c} &
  Only the low nibble of \textit{c} is used (\texttt{c \& 0x0F}).
  Values 0--15 are valid; values above 15 wrap silently into the 0--15 range. \\
Color 0 on the graphics layer &
  Color index 0 means transparent on the graphics bitmap.
  \cmd{UNPLOT x,y} explicitly sets a pixel to 0 to restore transparency. \\
\cmd{PLOT}/\cmd{UNPLOT}/\cmd{PAINT} bounds &
  The ROM dispatches coordinates without host-side pre-clipping.
  The host \texttt{BlockGraphics} implementation performs pixel-level bounds
  checks; out-of-range coordinates are silently ignored. \\
\cmd{LINE}/\cmd{RECT}/\cmd{CIRCLE}/\cmd{FILL} bounds &
  Drawing operations are clipped by the host renderer (\texttt{BlockGraphics.cs}).
  Portions of the shape outside the 320$\times$200 pixel area are dropped;
  no error is raised. \\
\cmd{FILL} rectangle &
  Coordinates are clamped to the screen boundary before drawing;
  the swap of x0/x1 or y0/y1 to ensure a positive rectangle is handled by
  the host. \\
\cmd{SPRITE n,\ldots} invalid index &
  Sprite index \textit{n} must be 0--15.
  The VGC command handlers check \texttt{n >= MaxSprites} and return immediately
  without error; no ROM-level error is raised. \\
\cmd{SPRITEDATA n,row,\ldots} &
  Row must be 0--15.
  The \texttt{CmdSprRow} handler checks both sprite index and row; an invalid
  row causes the command to be silently ignored. \\
\cmd{SPRITESHAPE}/\cmd{SPRITECOLOR} &
  These are tokenised and recognised by the ROM parser.
  However, the ROM handlers for both commands currently perform no hardware
  action.
  They exist for source compatibility; no VGC command is issued. \\
\cmd{SPRITEX(n)}/\cmd{SPRITEY(n)} &
  The ROM functions return 0 in v1.0.
  Sprite position read-back from the VGC is not yet implemented. \\
\cmd{COLLISION(n)}/\cmd{BUMPED(n)} &
  The VGC updates \texttt{RegColSt} and \texttt{RegColBg} each frame;
  the ROM reads the appropriate register and clears it on read.
  A given bit is set if sprite \textit{n} participated in a collision that frame. \\
Default sprite priority &
  On reset all sprites default to priority 2 (in front of everything).
  This matches the \texttt{SpritePriInFront} constant. \\
\cmd{CmdSprFlip} flags &
  Only bits 0--1 of the flags byte are used (\texttt{flags \& 0x03}):
  bit 0 = horizontal flip, bit 1 = vertical flip. \\
\cmd{CmdSprPri} clamping &
  Priority values above 2 are clamped to 2 (\texttt{Math.Min(value, 2)}).
  Values 0, 1, and 2 are the only meaningful levels. \\
\end{longtable}

% =============================================================================
\section{Sound and Music Limits}
% =============================================================================

\begin{longtable}{p{0.32\textwidth} p{0.58\textwidth}}
\toprule
\textbf{Command / Feature} & \textbf{Limit and edge behavior} \\
\midrule
\endhead
\bottomrule
\endfoot
\cmd{SOUND note,dur{[},inst{]}} &
  \textit{note} is a MIDI note number (0--127 byte range).
  \textit{dur} is duration in 1/60-second frames (0--255 byte range).
  \textit{inst} is instrument slot (0--15, default 0).
  If \textit{note} or \textit{dur} is 0, the sound is stopped. \\
Master volume &
  Only the low nibble of the volume byte is used (\texttt{level \& 0x0F}).
  The default master volume on power-on is 12. \\
\cmd{INSTRUMENT} parameters &
  All six parameters are bytes (0--255). Waveform should be one of
  \$10, \$20, \$40, \$80. ADSR values 0--15 are meaningful; higher values
  use the low nibble only for sustain. \\
\cmd{INSTRUMENT} slots &
  16 slots (0--15). Slot 0 is pre-initialized at boot. All other slots
  start as copies of slot 0. \\
\cmd{MUSIC voice,\ldots} &
  Voice must be 1--6. The MML string is read from CPU memory via pointer;
  maximum practical length limited by available RAM. \\
\cmd{MUSIC TEMPO} &
  BPM is a 16-bit value (0--65535). Default is 120. \\
\cmd{MUSIC PRIORITY} &
  1--3 voice numbers. Controls which voice is stolen first for SFX. \\
MML pulse width &
  Range 0--4095. Default 2048. PWM sweep step: $\pm$32 per frame. \\
MML filter cutoff &
  Range 0--2047. Resonance 0--15. Filter sweep step: $\pm$8 per frame. \\
MML vibrato &
  Depth is any positive integer; 0 = off. Oscillates at $\sim$2.9 Hz. \\
MML loops &
  Non-nesting. Maximum practical depth limited by string expansion. \\
Copper events &
  Maximum 256 events per list; 128 lists available. Events at duplicate position/register
  replace existing values. \\
\cmd{WAVE} &
  Deprecated. Raises a syntax error. Use \cmd{INSTRUMENT} instead. \\
\cmd{SIDPLAY} &
  Loads \texttt{.sid} files from \texttt{\textasciitilde/e6502-programs}.
  Song number is 1-based (default 1). \\
\end{longtable}

% =============================================================================
\section{XRAM Limits and Failure Modes}
% =============================================================================

\begin{longtable}{p{0.32\textwidth} p{0.58\textwidth}}
\toprule
\textbf{Command / Feature} & \textbf{Limit and edge behavior} \\
\midrule
\endhead
\bottomrule
\endfoot
\cmd{XBANK n} &
  The ROM verifies that \textit{n} is less than the value stored at
  \texttt{XmcBanks} (\$BA0D).
  An out-of-range bank number triggers a function-call error in the ROM
  before any XMC command is issued. \\
Window number (\cmd{XMAP}/\cmd{XUNMAP}) &
  Window must be 0--3.
  The ROM validates this; an invalid window triggers a function-call error. \\
Window address space &
  The four CPU-visible windows occupy \$BC00--\$BFFF (4 $\times$ 256 bytes).
  Window 0 maps to \$BC00, window 1 to \$BD00, window 2 to \$BE00,
  window 3 to \$BF00. \\
Unmapped window reads/writes &
  If a window is not enabled in \texttt{XmcWinCtl}, the XMC does not own that
  address and the read/write falls through to flat RAM.
  No error is returned. \\
Named block name length &
  The ROM enforces a 1--28 byte name (\texttt{XmcNameLen} is capped at 28 by
  the name buffer size: \$BA24--\$BA3F = 28 bytes).
  The host trims whitespace; a blank name after trimming is rejected with
  \cmd{XmcErrName}. \\
Named block name case &
  Name lookup is case-insensitive in the host
  (\texttt{StringComparer.OrdinalIgnoreCase}).
  Storing ``\texttt{SPRITE}'' and retrieving ``\texttt{sprite}'' will succeed. \\
\cmd{XALLOC len} with \texttt{len<=0} &
  The ROM passes zero through \cmd{LAB\_GTWRD}, which itself rejects negative
  values.
  The XMC command handler rejects \texttt{len<=0} with \cmd{XmcErrBadArgs}. \\
\cmd{XALLOC} with no free space &
  If no contiguous run of the required pages exists, or the handle pool (1--255)
  is exhausted, the command fails with \cmd{XmcErrNoSpace}. \\
\cmd{STASH}/\cmd{FETCH} (raw) with \texttt{len=0} &
  The XMC host treats a zero-length raw transfer as a no-op and returns
  \cmd{XmcStatusOk}.
  No data is moved and no pages are marked. \\
\cmd{FETCH "name",ram} (named fetch) &
  The ROM sends \texttt{XmcLenL/H = 0} for the named-fetch command.
  The host interprets \texttt{requested=0} as ``fetch the entire stored block'':
  \texttt{len = (requested <= 0) ? block.Length : min(requested, block.Length)}. \\
\cmd{STASH "name",ram,len} over existing block &
  If the named block already exists and the new length fits in the allocated
  pages, only \texttt{block.Length} is updated (no reallocation).
  If it does not fit, the old block is freed and a new allocation is attempted. \\
\cmd{XRESET} &
  Clears the \texttt{\_usedPages} array, resets \texttt{\_usedPageCount} to 0,
  and removes all block and name records.
  The raw XRAM byte array is \emph{not} zeroed; data remains but is inaccessible
  through the allocation system. \\
\cmd{XFREE off,len} &
  Frees all usage-tracking pages in the given range and removes any tracked
  blocks (named or unnamed) whose page range overlaps with the freed region. \\
\cmd{XPOKE}/\cmd{XPEEK} bank offset &
  The ROM constructs the XRAM address as
  \texttt{bank * 65536 + offset}.
  The host validates the resulting 24-bit address against the total XRAM size;
  out-of-range addresses return \cmd{XmcErrRange}. \\
RAM range validation for STASH/FETCH &
  The host prevents writes to ROM space: any \cmd{FETCH} operation whose
  destination range would extend into \$C000 or above is rejected with
  \cmd{XmcErrRange}.
  Reads (\cmd{STASH}) may source from ROM addresses, allowing code capture. \\
\end{longtable}

% =============================================================================
\section{DMA and Blitter Limits}
% =============================================================================

\begin{longtable}{p{0.32\textwidth} p{0.58\textwidth}}
\toprule
\textbf{Command / Feature} & \textbf{Limit and edge behavior} \\
\midrule
\endhead
\bottomrule
\endfoot
Memory space IDs &
  Valid range: 0--5 (CPU RAM, Char, Color, Gfx, Sprite, XRAM).
  An invalid space ID sets the error code to \cmd{BadSpace} (\$02). \\
24-bit addressing &
  All DMA and blitter addresses are 24-bit (low/mid/high byte).
  For XRAM (space 5), the current \cmd{XBANK} value is used as the
  high address byte automatically by the BASIC commands. \\
\cmd{DMACOPY}/\cmd{DMAFILL} &
  Length is 24-bit; zero-length transfers are rejected with \cmd{BadArgs} (\$04).
  Out-of-range addresses set \cmd{Range} (\$03).
  Writes to ROM space set \cmd{WriteProt} (\$05). \\
\cmd{BLITCOPY}/\cmd{BLITFILL} &
  Width and height are 16-bit (1--65535 each).
  Zero width or height is rejected with \cmd{BadArgs} (\$04).
  Stride is the byte offset between row starts; it may be larger than width. \\
Color-key mode (blitter) &
  When bit 1 of \texttt{BltMode} is set, source bytes matching
  \texttt{BltColorKey} are skipped.
  In fill mode, color-key is ignored. \\
Row buffer &
  When source and destination overlap in the same space, the blitter uses
  a temporary row buffer to prevent read-after-write corruption. \\
\cmd{DMASTATUS}/\cmd{BLITSTATUS} &
  Returns the raw status register value: 0=idle, 1=busy, 2=ok, 3=error.
  BASIC commands check status automatically and raise a function-call
  error if the operation fails. \\
\end{longtable}

% =============================================================================
\section{Network Limits}
% =============================================================================

\begin{longtable}{p{0.32\textwidth} p{0.58\textwidth}}
\toprule
\textbf{Feature} & \textbf{Limit and edge behavior} \\
\midrule
\endhead
\bottomrule
\endfoot
Connection slots &
  4 slots (0--3). Each slot is independent and may be a client or server. \\
Message size &
  Maximum 256 bytes per message. Messages are length-prefixed on the wire
  (1 byte: \$00 = 256, \$01--\$FF = 1--255). \\
Receive queue &
  Up to 16 messages per slot. If the queue overflows, new messages are
  dropped and the slot error flag is set. \\
Hostname length &
  Maximum 31 characters (32-byte buffer, null-terminated). \\
Port range &
  1--65535 (16-bit). \\
Connect timeout &
  10 seconds. If the remote host does not respond, the slot error flag
  is set. \\
\cmd{NRECV\$(slot)} &
  Returns a string of up to 255 characters. If no message is queued,
  returns an empty string. \\
\cmd{NSTATUS(slot)} &
  Returns the slot status byte. Bit 4 (RemoteClosed) indicates the remote
  peer has disconnected; the slot should be closed with \cmd{NCLOSE}. \\
\cmd{NREADY(slot)} &
  Returns $-1$ (true) if at least one message is in the receive queue,
  0 (false) otherwise. \\
\cmd{NLISTEN} binding &
  TCP server binds to 127.0.0.1 (localhost). External connections require
  the remote end to connect to the host machine's loopback address. \\
\end{longtable}

% =============================================================================
\section{Status and Error Code Quick Reference}
% =============================================================================

\subsection*{File I/O Controller (FIO) Codes}

\begin{longtable}{>{\ttfamily\raggedright\arraybackslash}p{0.12\textwidth} >{\ttfamily\raggedright\arraybackslash}p{0.26\textwidth} p{0.50\textwidth}}
\toprule
\normalfont\textbf{Value} & \normalfont\textbf{Symbol} & \textbf{Meaning} \\
\midrule
\endhead
\bottomrule
\endfoot
\multicolumn{3}{l}{\normalfont\textit{Status codes (\$B9A1)}} \\
\midrule
\$00 & FioStatusIdle  & No operation has been issued since last reset. \\
\$02 & FioStatusOk    & Last operation succeeded. \\
\$03 & FioStatusError & Last operation failed; check error code. \\
\midrule
\multicolumn{3}{l}{\normalfont\textit{Error codes (\$B9A2)}} \\
\midrule
\$00 & FioErrNone     & No error. \\
\$01 & FioErrNotFound & File not found on disk. \\
\$02 & FioErrIo       & Host I/O error (bad name, OS exception, end address $\leq$ start). \\
\$03 & FioErrEndOfDir & Directory enumeration exhausted. \\
\end{longtable}

\subsection*{Expansion Memory Controller (XMC) Codes}

\begin{longtable}{>{\ttfamily\raggedright\arraybackslash}p{0.12\textwidth} >{\ttfamily\raggedright\arraybackslash}p{0.26\textwidth} p{0.50\textwidth}}
\toprule
\normalfont\textbf{Value} & \normalfont\textbf{Symbol} & \textbf{Meaning} \\
\midrule
\endhead
\bottomrule
\endfoot
\multicolumn{3}{l}{\normalfont\textit{Status codes (\$BA01)}} \\
\midrule
\$00 & XmcStatusIdle  & No operation in progress. \\
\$02 & XmcStatusOk    & Last operation succeeded. \\
\$03 & XmcStatusError & Last operation failed; check error code. \\
\midrule
\multicolumn{3}{l}{\normalfont\textit{Error codes (\$BA02)}} \\
\midrule
\$00 & XmcErrNone     & No error. \\
\$01 & XmcErrRange    & XRAM address or transfer endpoint out of XRAM bounds, or FETCH would write into ROM. \\
\$02 & XmcErrBadArgs  & Invalid argument (\texttt{len<=0} for Alloc, unknown command byte). \\
\$03 & XmcErrNotFound & Named block not found in directory. \\
\$04 & XmcErrNoSpace  & No contiguous free pages available, or handle pool (1--255) exhausted. \\
\$05 & XmcErrName     & Name length 0 or $>$28, or name is blank after trimming. \\
\$06 & XmcErrEndOfDir & No more named-block directory entries. \\
\end{longtable}

\subsection*{DMA Controller Codes}

\begin{longtable}{>{\ttfamily\raggedright\arraybackslash}p{0.12\textwidth} >{\ttfamily\raggedright\arraybackslash}p{0.26\textwidth} p{0.50\textwidth}}
\toprule
\normalfont\textbf{Value} & \normalfont\textbf{Symbol} & \textbf{Meaning} \\
\midrule
\endhead
\bottomrule
\endfoot
\multicolumn{3}{l}{\normalfont\textit{Status codes (\$BA61)}} \\
\midrule
\$00 & DmaStatusIdle  & No operation in progress. \\
\$01 & DmaStatusBusy  & Transfer is executing. \\
\$02 & DmaStatusOk    & Last transfer succeeded. \\
\$03 & DmaStatusError & Last transfer failed; check error code. \\
\midrule
\multicolumn{3}{l}{\normalfont\textit{Error codes (\$BA62)}} \\
\midrule
\$00 & DmaErrNone      & No error. \\
\$01 & DmaErrBadCmd    & Invalid command byte. \\
\$02 & DmaErrBadSpace  & Invalid source or destination space ID. \\
\$03 & DmaErrRange     & Address out of bounds for the given space. \\
\$04 & DmaErrBadArgs   & Invalid arguments (e.g., length $\leq$ 0). \\
\$05 & DmaErrWriteProt & Destination is write-protected (ROM). \\
\end{longtable}

\subsection*{Blitter Controller Codes}

\begin{longtable}{>{\ttfamily\raggedright\arraybackslash}p{0.12\textwidth} >{\ttfamily\raggedright\arraybackslash}p{0.26\textwidth} p{0.50\textwidth}}
\toprule
\normalfont\textbf{Value} & \normalfont\textbf{Symbol} & \textbf{Meaning} \\
\midrule
\endhead
\bottomrule
\endfoot
\multicolumn{3}{l}{\normalfont\textit{Status codes (\$BA81)}} \\
\midrule
\$00 & BltStatusIdle  & No operation in progress. \\
\$01 & BltStatusBusy  & Blit is executing. \\
\$02 & BltStatusOk    & Last blit succeeded. \\
\$03 & BltStatusError & Last blit failed; check error code. \\
\midrule
\multicolumn{3}{l}{\normalfont\textit{Error codes (\$BA82)}} \\
\midrule
\$00 & BltErrNone      & No error. \\
\$01 & BltErrBadCmd    & Invalid command byte. \\
\$02 & BltErrBadSpace  & Invalid source or destination space ID. \\
\$03 & BltErrRange     & Rectangular region extends out of bounds. \\
\$04 & BltErrBadArgs   & Invalid arguments (width $\leq$ 0, height $\leq$ 0). \\
\$05 & BltErrWriteProt & Destination is write-protected (ROM). \\
\end{longtable}

\begin{tipbox}
The BASIC runtime maps FIO, XMC, DMA, and Blitter error returns to one of
three user-visible messages: ``\texttt{File not found}'',
``\texttt{I/O Error}'', or a function-call error.
For low-level programs that \cmd{POKE} the controller registers directly,
use the tables above to interpret the raw status and error bytes.
\end{tipbox}
