% =============================================================================
% Chapter 4 â€” Graphics and Sprites
% NovaBASIC v1.0 User Guide
% =============================================================================
\chapter{Graphics and Sprites}
\label{chap:graphics}

\epigraph{\itshape ``A blank screen is a canvas waiting to be claimed.''}%
         {--- e6502 Virtual Computer Design Notes}

\noindent
NovaBASIC gives you direct access to a 320$\times$200 pixel bitmap and a
hardware sprite layer. Drawing commands operate on 16 colors; sprites add
independently positioned, independently animated 16$\times$16 objects on top
of or behind the bitmap and text layers. This chapter covers the full
graphics pipeline from mode selection to collision detection.

% -----------------------------------------------------------------------------
\section{Display Modes}
\label{sec:display-modes}
% -----------------------------------------------------------------------------

The virtual display has two independent layers: a text layer and a graphics
bitmap layer. \cmd{MODE} selects how they are composited.

\begin{center}
\begin{tabular}{>{\ttfamily}c l}
\toprule
\textbf{Mode} & \textbf{Description} \\
\midrule
0 & Text only. The graphics bitmap is not rendered. \\
1 & Graphics over text. Bitmap is drawn on top of text characters. \\
2 & Text over graphics. Text characters are drawn on top of the bitmap. \\
3 & Graphics and sprites only. No text layer is rendered. \\
\bottomrule
\end{tabular}
\end{center}

\medskip
The typical starting sequence for any graphics program is:

\begin{lstlisting}[style=basiclisting]
10 MODE 1
20 GCLS
30 GCOLOR 7
\end{lstlisting}

\cmd{MODE 1} activates pixel rendering. \cmd{GCLS} clears the bitmap to
transparent (color~0). \cmd{GCOLOR} sets the active drawing color for all
subsequent drawing commands.

\begin{notebox}
Color 0 is transparent in the graphics layer. Setting a pixel to color~0
with \cmd{PLOT 0} or \cmd{FILL} erases it, letting the text layer or
background show through. This is equivalent to \cmd{UNPLOT}.
\end{notebox}

To return to plain text output, switch back to \cmd{MODE 0}. You do not
need to clear the bitmap when switching modes; the pixel data is preserved
and will reappear if you switch back to \cmd{MODE 1} or \cmd{MODE 2}.

% -----------------------------------------------------------------------------
\section{Drawing Commands}
\label{sec:drawing-commands}
% -----------------------------------------------------------------------------

All drawing commands use the color set by \cmd{GCOLOR}. Coordinates must
fall within the screen boundaries of X~=~0--319 and Y~=~0--199; pixels
outside that range are silently clipped and no error is raised.

\subsection*{Command reference}

\begin{longtable}{>{\ttfamily\small}p{0.36\textwidth} p{0.54\textwidth}}
\toprule
\textbf{Command} & \textbf{Description} \\
\midrule
\endhead
\bottomrule
\endfoot
GCOLOR c            & Set the active drawing color. \cmd{c} is 0--15.
                      If \cmd{c}~=~0, NovaBASIC uses the current text
                      foreground color instead of transparent. \\[4pt]
GCLS                & Clear the entire graphics bitmap to transparent
                      (color~0). Does not affect the text layer. \\[4pt]
PLOT x,y            & Set the pixel at (\cmd{x},\cmd{y}) to the current
                      drawing color. \\[4pt]
UNPLOT x,y          & Set the pixel at (\cmd{x},\cmd{y}) to transparent
                      (color~0), effectively erasing it. \\[4pt]
LINE x0,y0,x1,y1    & Draw a straight line from (\cmd{x0},\cmd{y0}) to
                      (\cmd{x1},\cmd{y1}) in the current drawing color. \\[4pt]
RECT x0,y0,x1,y1    & Draw a rectangle outline. (\cmd{x0},\cmd{y0}) is the
                      top-left corner; (\cmd{x1},\cmd{y1}) is the
                      bottom-right corner. \\[4pt]
FILL x0,y0,x1,y1    & Draw a solid filled rectangle using the same corner
                      convention as \cmd{RECT}. \\[4pt]
CIRCLE cx,cy,r      & Draw a circle outline centered at (\cmd{cx},\cmd{cy})
                      with radius \cmd{r} pixels. \\[4pt]
PAINT x,y           & Flood-fill from seed point (\cmd{x},\cmd{y}),
                      replacing all connected pixels of the same color
                      with the current drawing color. \\
\end{longtable}

\subsection*{A drawing example}

The following program draws a diagonal cross, a circle, and then fills the
circle interior:

\begin{lstlisting}[style=basiclisting]
10 MODE 1 : GCLS
20 GCOLOR 9
30 LINE 0,0,319,199
40 LINE 319,0,0,199
50 GCOLOR 14
60 CIRCLE 160,100,60
70 GCOLOR 10
80 PAINT 160,100
90 VSYNC
\end{lstlisting}

Line~30--40 draws a white cross from corner to corner. Lines~60--80 add a
yellow circle outline and then flood-fill the interior with green. \cmd{VSYNC}
on line~90 holds the image for one frame before the program ends; without it
the display may update before you see the result.

\begin{tipbox}
\cmd{PAINT} stops at pixel boundaries of a different color. Make sure the
circle or region you want to fill has no gaps, otherwise the fill will leak
out into the surrounding area. If in doubt, draw the boundary in one step and
fill immediately after.
\end{tipbox}

% -----------------------------------------------------------------------------
\section{Animation with VSYNC}
\label{sec:vsync-animation}
% -----------------------------------------------------------------------------

The virtual display runs at 60~Hz. \cmd{VSYNC} suspends program execution
until the start of the next video frame. One \cmd{VSYNC} call therefore
consumes exactly one frame period ($\approx 16.7$~ms). This is the correct
tool for controlling animation speed.

A minimal animation loop that moves a point across the screen:

\begin{lstlisting}[style=basiclisting]
10 MODE 1 : GCLS : GCOLOR 11
20 X = 0 : Y = 100
30 VSYNC
40 UNPLOT X, Y
50 X = X + 2
60 IF X > 319 THEN X = 0
70 PLOT X, Y
80 GOTO 30
\end{lstlisting}

The pattern is always: wait for VSYNC, erase the old position, update
coordinates, draw the new position. Erasing before moving eliminates the
ghost trail that builds up if you draw without erasing.

\begin{tipbox}
For smooth movement, do all erase operations for a frame, update all
positions, and do all draw operations --- all within a single VSYNC period.
Never call \cmd{VSYNC} between the erase and redraw steps for the same
object; that produces a one-frame flicker every cycle.
\end{tipbox}

% -----------------------------------------------------------------------------
\section{Sprites}
\label{sec:sprites}
% -----------------------------------------------------------------------------

Sprites are hardware-accelerated 16$\times$16 pixel objects that move
independently of the bitmap. NovaBASIC supports 16 sprites (indices 0--15),
each with its own shape, position, priority, and flip state. Sprites do not
modify the bitmap; they are composited at render time.

\subsection*{Enabling and positioning sprites}

A sprite must be enabled before it becomes visible:

\begin{lstlisting}[style=basiclisting]
10 SPRITE 0, ON
20 SPRITE 0, 160, 100
\end{lstlisting}

\cmd{SPRITE n,ON} activates sprite \cmd{n}. \cmd{SPRITE n,x,y} sets its
screen position. Positions are in the same coordinate space as the bitmap
(X~=~0--319, Y~=~0--199). Sprites may be positioned partially or fully
off-screen; they are simply clipped without error.

To hide a sprite, use \cmd{SPRITE n,OFF}. This makes the sprite invisible
without erasing its shape data. You can re-enable it later with
\cmd{SPRITE n,ON} and it will reappear at its last recorded position.

\subsection*{Sprite priority}

Priority controls which layer a sprite is drawn on:

\begin{center}
\begin{tabular}{cl}
\toprule
\textbf{Priority} & \textbf{Layer position} \\
\midrule
0 & Behind all layers (below text and graphics) \\
1 & Between the text and graphics layers \\
2 & In front of all layers (above text and graphics) \\
\bottomrule
\end{tabular}
\end{center}

Priority is set via the MCP sprite tools when building shapes interactively;
it can also be arranged by designing your program so that background sprites
are enabled first and foreground sprites last.

\subsection*{Defining sprite pixels with SPRITEDATA}

Each sprite is 16~pixels wide by 16~pixels tall. Pixel data is loaded one
row at a time using \cmd{SPRITEDATA}:

\begin{center}
\cmd{SPRITEDATA n, row, b1, b2, b3, b4, b5, b6, b7, b8}
\end{center}

\begin{itemize}
  \item \cmd{n} is the sprite index (0--15).
  \item \cmd{row} is the row to define (0--15, top to bottom).
  \item \cmd{b1}--\cmd{b8} are eight byte values (0--255).
\end{itemize}

Each byte encodes \emph{two} pixels. The high nibble (upper four bits) is the
left pixel; the low nibble (lower four bits) is the right pixel. Color~0 is
transparent; colors 1--15 are the standard 16-color palette. With eight bytes
per row and two pixels per byte, each row is exactly 16 pixels wide.

\medskip
\textbf{Example:} a byte value of \cmd{\$AC} (decimal 172) draws pixel color
10 (\cmd{A} in hex) on the left and pixel color 12 (\cmd{C} in hex) on the
right. A value of \cmd{\$00} leaves both pixels transparent.

\medskip
The following example defines a simple 16$\times$16 diamond shape in color~11
(cyan) and displays it:

\begin{lstlisting}[style=basiclisting]
10 REM DEFINE A DIAMOND SPRITE
20 SPRITEDATA 0,  0, 0,   0,   0,  0,  0,   0,   0,  0
30 SPRITEDATA 0,  1, 0,   0,   0, 11,  0,   0,   0,  0
40 SPRITEDATA 0,  2, 0,   0, 177,177,  0,   0,   0,  0
50 SPRITEDATA 0,  3, 0, 187, 187,187,187,   0,   0,  0
60 SPRITEDATA 0,  4, 0, 187, 187,187,187,   0,   0,  0
70 SPRITEDATA 0,  5, 0,   0, 177,177,  0,   0,   0,  0
80 SPRITEDATA 0,  6, 0,   0,   0, 11,  0,   0,   0,  0
90 SPRITEDATA 0,  7, 0,   0,   0,  0,  0,   0,   0,  0
100 REM ROWS 8-15 REMAIN TRANSPARENT (NO SPRITEDATA = NO CHANGE)
110 SPRITE 0, ON
120 SPRITE 0, 152, 92
130 VSYNC
\end{lstlisting}

\begin{notebox}
Any row not explicitly defined by \cmd{SPRITEDATA} retains its previous pixel
data. If you are reusing a sprite slot for a new shape, define all 16 rows
(or clear the slot first). Rows you intentionally leave all-zero produce a
fully transparent row.
\end{notebox}

The bytes in lines~30--80 use decimal notation. Working with hex notation is
often more readable: \cmd{0xBB} = decimal~187, which encodes color~11 in both
nibbles (solid cyan on both pixels of that byte). In NovaBASIC you can write
hex literals directly in expressions using \cmd{\&HBB} notation.

% -----------------------------------------------------------------------------
\section{Sprite Collision Detection}
\label{sec:collision}
% -----------------------------------------------------------------------------

NovaBASIC provides two collision functions that report when sprites overlap
each other or touch non-transparent pixels on the background bitmap.

\begin{center}
\begin{tabular}{>{\ttfamily}p{0.22\textwidth} p{0.65\textwidth}}
\toprule
\textbf{Function} & \textbf{Returns} \\
\midrule
COLLISION(n) & Bitmask of other sprites currently overlapping sprite \cmd{n}. \\[4pt]
BUMPED(n)    & Bitmask indicating that sprite \cmd{n} has touched a
               non-transparent pixel in the graphics bitmap. \\
\bottomrule
\end{tabular}
\end{center}

Both functions return an integer bitmask. Bit \cmd{k} being set means sprite
\cmd{k} is involved in the collision. For \cmd{COLLISION(n)}, if the result
is non-zero then at least one other sprite overlaps sprite~\cmd{n}; use
\cmd{AND} with the appropriate bit to test for a specific sprite. For
\cmd{BUMPED(n)}, a non-zero result means sprite~\cmd{n} is touching a
non-transparent pixel in the graphics bitmap.

\begin{warningbox}
Both collision registers clear automatically when read. Read each register
exactly once per frame and store the result in a variable. If you call
\cmd{COLLISION(n)} or \cmd{BUMPED(n)} a second time in the same frame you
will get zero, missing collisions that occurred between reads.
\end{warningbox}

A practical collision loop pattern:

\begin{lstlisting}[style=basiclisting]
100 VSYNC
110 C = COLLISION(0)
120 B = BUMPED(0)
130 IF C <> 0 THEN GOSUB 500
140 IF B <> 0 THEN GOSUB 600
150 REM UPDATE POSITIONS HERE
160 GOTO 100
\end{lstlisting}

Lines~110--120 read both registers once and store them. Lines~130--140 branch
to handler routines only if a collision has occurred. All position updates
happen after the collision check so that the same frame's register values are
used consistently.

To test whether sprite~\cmd{n} specifically collided with sprite~2, check bit
2 of the \cmd{COLLISION} result:

\begin{lstlisting}[style=basiclisting]
200 C = COLLISION(0)
210 IF (C AND 4) <> 0 THEN PRINT "HIT SPRITE 2"
\end{lstlisting}

% -----------------------------------------------------------------------------
\section{Color Palette}
\label{sec:color-palette}
% -----------------------------------------------------------------------------

NovaBASIC uses a fixed 16-color palette inspired by the Commodore~64.
All graphics, text, sprite, background, and border colors use the same
indices.

\begin{center}
\begin{tabular}{clcl}
\toprule
\textbf{Index} & \textbf{Color} & \textbf{Index} & \textbf{Color} \\
\midrule
 0 & Black       &  8 & Orange \\
 1 & White       &  9 & Brown \\
 2 & Red         & 10 & Light Red \\
 3 & Cyan        & 11 & Dark Grey \\
 4 & Purple      & 12 & Medium Grey \\
 5 & Green       & 13 & Light Green \\
 6 & Blue        & 14 & Light Blue \\
 7 & Yellow      & 15 & Light Grey \\
\bottomrule
\end{tabular}
\end{center}

The background color defaults to 6~(blue), the text foreground to 1~(white),
and the border to 6~(blue). Use \cmd{COLOR fg{[},bg{]}} for text colors.
The border color can be changed via \cmd{POKE 40973, c} where \cmd{c} is
0--15 (\$A00D is the border color register).

% -----------------------------------------------------------------------------
\section{The Copper (Raster Effects)}
\label{sec:copper}
% -----------------------------------------------------------------------------

The copper is a per-pixel register-write system inspired by the Amiga's
Copper coprocessor. It lets you change display registers at precise screen
positions, enabling effects like color gradient backgrounds, split-screen
modes, and parallax scrolling --- all without any CPU involvement.

\subsection*{How it works}

The VGC stores up to 128 independent copper \emph{lists}. Each list is a
program of up to 256 events, each specifying:

\begin{itemize}
  \item A screen position (X~=~0--319, Y~=~0--199).
  \item A target register.
  \item A value to write to that register.
\end{itemize}

When copper is enabled, the renderer checks for copper events at every pixel
position. When it reaches a pixel that has a scheduled event, the register
write fires immediately and affects all subsequent pixels on that frame.

\subsection*{Writable registers}

The copper can write to four VGC registers:

\begin{center}
\begin{tabular}{>{\ttfamily}l>{\ttfamily}ll}
\toprule
\textbf{Register} & \textbf{Address} & \textbf{Effect} \\
\midrule
RegMode    & \$A000 & Change display mode mid-screen \\
RegBgCol   & \$A001 & Change background color mid-screen \\
RegScrollX & \$A005 & Shift horizontal scroll offset \\
RegScrollY & \$A006 & Shift vertical scroll offset \\
\bottomrule
\end{tabular}
\end{center}

\subsection*{COPPER BASIC keyword}

The \texttt{COPPER} keyword provides direct access to the copper system:

\begin{center}
\begin{tabular}{>{\ttfamily\raggedright\arraybackslash}p{0.46\textwidth} p{0.44\textwidth}}
\toprule
\normalfont\textbf{Syntax} & \textbf{Purpose} \\
\midrule
COPPER ADD x, y, BGCOL, value  & Add event: set background color at position. \\
COPPER ADD x, y, MODE, value   & Add event: set display mode at position. \\
COPPER ADD x, y, SCROLLX, value & Add event: set horizontal scroll at position. \\
COPPER ADD x, y, SCROLLY, value & Add event: set vertical scroll at position. \\
COPPER CLEAR                   & Remove all events from the current target list. \\
COPPER ON                      & Enable copper execution each frame. \\
COPPER OFF                     & Disable copper execution. \\
COPPER LIST n                  & Set target list to \textit{n} (0--127). Subsequent ADD/CLEAR edit this list. \\
COPPER LIST END                & Reset target list back to the active list. \\
COPPER USE n                   & Switch the active list to \textit{n} at the next vblank. \\
\bottomrule
\end{tabular}
\end{center}

If an event at the same position for the same register already exists, the
value is replaced. Each list holds up to 256 events.

\textbf{Multiple lists.}\enspace
The VGC stores 128 copper lists (0--127). By default everything operates on
list~0. Use \texttt{COPPER LIST n} to direct subsequent \texttt{ADD}/\texttt{CLEAR}
commands to list~\textit{n}. Use \texttt{COPPER USE n} to tell the renderer to
switch to list~\textit{n} at the next vertical blank --- this avoids tearing
because the swap happens atomically between frames. Editing a list and
swapping the active pointer are independent, so you can build one list while
the renderer displays another (double buffering).

\subsection*{Low-level copper control via POKE}

You can also control the copper by writing directly to the VGC command
registers (\$A010--\$A016) and then writing the command byte to \$A010.

\begin{center}
\begin{tabular}{>{\ttfamily}cp{0.70\textwidth}}
\toprule
\textbf{Code} & \textbf{Command} \\
\midrule
\$1B & \textbf{Copper Add} --- add an event to the target list. P0/P1~=~X (16-bit), P2~=~Y,
       P3/P4~=~register (0--15 or \$A000--\$A00F), P5~=~value. \\[4pt]
\$1C & \textbf{Copper Clear} --- remove all events from the target list. \\[4pt]
\$1D & \textbf{Copper Enable} --- start executing the active copper list each
       frame. \\[4pt]
\$1E & \textbf{Copper Disable} --- stop executing the copper program. \\[4pt]
\$20 & \textbf{Copper List} --- set target list. P0~=~list index (0--127). \\[4pt]
\$21 & \textbf{Copper Use} --- set pending active list. P0~=~list index (0--127).
       Takes effect at next vblank. \\[4pt]
\$22 & \textbf{Copper List End} --- reset target list back to the active list. \\
\bottomrule
\end{tabular}
\end{center}

\subsection*{Example: background color gradient}

The following program creates a vertical color gradient by scheduling a
background color change at the start of each group of rows:

\begin{lstlisting}[style=basiclisting]
10 COPPER CLEAR
20 FOR I = 0 TO 12
30   COPPER ADD 0, I * 15, BGCOL, I + 2
40 NEXT I
50 COPPER ON
\end{lstlisting}

The loop on lines~20--40 adds 13~events, each changing the background color
at Y positions 0, 15, 30, \ldots{}, 180 to successive color indices. Line~50
enables the copper. Each frame the background will display as a gradient of
bands.

\begin{tipbox}
Copper events fire at per-pixel granularity. Setting X~=~0 for all events
produces clean horizontal bands. Setting different X values within the same
row creates vertical split effects.
\end{tipbox}

\begin{notebox}
Each copper list holds up to 256 events. Events are sorted by position
automatically. Multiple events at the same position are applied in
register-index order. The VGC stores 128 lists; all data is host-side and
consumes no 6502 address space.
\end{notebox}

% -----------------------------------------------------------------------------
\section{Compatibility Notes}
\label{sec:sprite-compat}
% -----------------------------------------------------------------------------

\begin{warningbox}
The following commands and functions are parsed by NovaBASIC for source
compatibility but currently have no effect at runtime:

\begin{itemize}
  \item \cmd{SPRITESHAPE} --- accepted without error, silently ignored.
  \item \cmd{SPRITECOLOR} --- accepted without error, silently ignored.
  \item \cmd{SPRITEX(n)} --- always returns 0; does not reflect actual
        sprite X position.
  \item \cmd{SPRITEY(n)} --- always returns 0; does not reflect actual
        sprite Y position.
\end{itemize}

Programs that read sprite position back via \cmd{SPRITEX}/\cmd{SPRITEY} must
instead track coordinates in their own variables.
\end{warningbox}

% -----------------------------------------------------------------------------
\section{Try It Now}
\label{sec:graphics-tryit}
% -----------------------------------------------------------------------------

\begin{tryitbox}
Type and run the following program to see \cmd{MODE}, \cmd{GCLS},
\cmd{GCOLOR}, \cmd{RECT}, \cmd{CIRCLE}, and \cmd{PAINT} working together:

\begin{lstlisting}[style=basiclisting]
10 MODE 1 : GCLS : GCOLOR 10
20 RECT 10, 10, 309, 189
30 GCOLOR 14 : CIRCLE 160, 100, 50
40 GCOLOR 12 : PAINT 160, 100
\end{lstlisting}

Expected result: a green rectangle border frames the screen; inside it a
yellow circle outline encloses a solid red filled region.

\medskip
Try modifying \cmd{GCOLOR} values (1--15) and the \cmd{CIRCLE} radius to
explore the coordinate system. Then add a second \cmd{CIRCLE} call on a new
line and re-run to see both circles on the same canvas.
\end{tryitbox}
