% =============================================================================
% Chapter 4 â€” Graphics and Sprites
% NovaBASIC v1.0 User Guide
% =============================================================================
\chapter{Graphics and Sprites}
\label{chap:graphics}

\epigraph{\itshape ``A blank screen is a canvas waiting to be claimed.''}%
         {--- e6502 Virtual Computer Design Notes}

\noindent
NovaBASIC gives you direct access to a 320$\times$200 pixel bitmap and a
hardware sprite layer. Drawing commands operate on 16 colors; sprites add
independently positioned, independently animated 16$\times$16 objects on top
of or behind the bitmap and text layers. This chapter covers the full
graphics pipeline from mode selection to collision detection.

% -----------------------------------------------------------------------------
\section{Display Modes}
\label{sec:display-modes}
% -----------------------------------------------------------------------------

The virtual display has two independent layers: a text layer and a graphics
bitmap layer. \cmd{MODE} selects how they are composited.

\begin{center}
\begin{tabular}{>{\ttfamily}c l}
\toprule
\textbf{Mode} & \textbf{Description} \\
\midrule
0 & Text only. The graphics bitmap is not rendered. \\
1 & Graphics over text. Bitmap is drawn on top of text characters. \\
2 & Text over graphics. Text characters are drawn on top of the bitmap. \\
\bottomrule
\end{tabular}
\end{center}

\medskip
The typical starting sequence for any graphics program is:

\begin{lstlisting}[style=basiclisting]
10 MODE 1
20 GCLS
30 GCOLOR 7
\end{lstlisting}

\cmd{MODE 1} activates pixel rendering. \cmd{GCLS} clears the bitmap to
transparent (color~0). \cmd{GCOLOR} sets the active drawing color for all
subsequent drawing commands.

\begin{notebox}
Color 0 is transparent in the graphics layer. Setting a pixel to color~0
with \cmd{PLOT 0} or \cmd{FILL} erases it, letting the text layer or
background show through. This is equivalent to \cmd{UNPLOT}.
\end{notebox}

To return to plain text output, switch back to \cmd{MODE 0}. You do not
need to clear the bitmap when switching modes; the pixel data is preserved
and will reappear if you switch back to \cmd{MODE 1} or \cmd{MODE 2}.

% -----------------------------------------------------------------------------
\section{Drawing Commands}
\label{sec:drawing-commands}
% -----------------------------------------------------------------------------

All drawing commands use the color set by \cmd{GCOLOR}. Coordinates must
fall within the screen boundaries of X~=~0--319 and Y~=~0--199; pixels
outside that range are silently clipped and no error is raised.

\subsection*{Command reference}

\begin{longtable}{>{\ttfamily\small}p{0.36\textwidth} p{0.54\textwidth}}
\toprule
\textbf{Command} & \textbf{Description} \\
\midrule
\endhead
\bottomrule
\endfoot
GCOLOR c            & Set the active drawing color. \cmd{c} is 0--15.
                      If \cmd{c}~=~0, NovaBASIC uses the current text
                      foreground color instead of transparent. \\[4pt]
GCLS                & Clear the entire graphics bitmap to transparent
                      (color~0). Does not affect the text layer. \\[4pt]
PLOT x,y            & Set the pixel at (\cmd{x},\cmd{y}) to the current
                      drawing color. \\[4pt]
UNPLOT x,y          & Set the pixel at (\cmd{x},\cmd{y}) to transparent
                      (color~0), effectively erasing it. \\[4pt]
LINE x0,y0,x1,y1    & Draw a straight line from (\cmd{x0},\cmd{y0}) to
                      (\cmd{x1},\cmd{y1}) in the current drawing color. \\[4pt]
RECT x0,y0,x1,y1    & Draw a rectangle outline. (\cmd{x0},\cmd{y0}) is the
                      top-left corner; (\cmd{x1},\cmd{y1}) is the
                      bottom-right corner. \\[4pt]
FILL x0,y0,x1,y1    & Draw a solid filled rectangle using the same corner
                      convention as \cmd{RECT}. \\[4pt]
CIRCLE cx,cy,r      & Draw a circle outline centered at (\cmd{cx},\cmd{cy})
                      with radius \cmd{r} pixels. \\[4pt]
PAINT x,y           & Flood-fill from seed point (\cmd{x},\cmd{y}),
                      replacing all connected pixels of the same color
                      with the current drawing color. \\
\end{longtable}

\subsection*{A drawing example}

The following program draws a diagonal cross, a circle, and then fills the
circle interior:

\begin{lstlisting}[style=basiclisting]
10 MODE 1 : GCLS
20 GCOLOR 9
30 LINE 0,0,319,199
40 LINE 319,0,0,199
50 GCOLOR 14
60 CIRCLE 160,100,60
70 GCOLOR 10
80 PAINT 160,100
90 VSYNC
\end{lstlisting}

Line~30--40 draws a white cross from corner to corner. Lines~60--80 add a
yellow circle outline and then flood-fill the interior with green. \cmd{VSYNC}
on line~90 holds the image for one frame before the program ends; without it
the display may update before you see the result.

\begin{tipbox}
\cmd{PAINT} stops at pixel boundaries of a different color. Make sure the
circle or region you want to fill has no gaps, otherwise the fill will leak
out into the surrounding area. If in doubt, draw the boundary in one step and
fill immediately after.
\end{tipbox}

% -----------------------------------------------------------------------------
\section{Animation with VSYNC}
\label{sec:vsync-animation}
% -----------------------------------------------------------------------------

The virtual display runs at 60~Hz. \cmd{VSYNC} suspends program execution
until the start of the next video frame. One \cmd{VSYNC} call therefore
consumes exactly one frame period ($\approx 16.7$~ms). This is the correct
tool for controlling animation speed.

A minimal animation loop that moves a point across the screen:

\begin{lstlisting}[style=basiclisting]
10 MODE 1 : GCLS : GCOLOR 11
20 X = 0 : Y = 100
30 VSYNC
40 UNPLOT X, Y
50 X = X + 2
60 IF X > 319 THEN X = 0
70 PLOT X, Y
80 GOTO 30
\end{lstlisting}

The pattern is always: wait for VSYNC, erase the old position, update
coordinates, draw the new position. Erasing before moving eliminates the
ghost trail that builds up if you draw without erasing.

\begin{tipbox}
For smooth movement, do all erase operations for a frame, update all
positions, and do all draw operations --- all within a single VSYNC period.
Never call \cmd{VSYNC} between the erase and redraw steps for the same
object; that produces a one-frame flicker every cycle.
\end{tipbox}

% -----------------------------------------------------------------------------
\section{Sprites}
\label{sec:sprites}
% -----------------------------------------------------------------------------

Sprites are hardware-accelerated 16$\times$16 pixel objects that move
independently of the bitmap. NovaBASIC supports 16 sprites (indices 0--15),
each with its own shape, position, priority, and flip state. Sprites do not
modify the bitmap; they are composited at render time.

\subsection*{Enabling and positioning sprites}

A sprite must be enabled before it becomes visible:

\begin{lstlisting}[style=basiclisting]
10 SPRITE 0, ON
20 SPRITE 0, 160, 100
\end{lstlisting}

\cmd{SPRITE n,ON} activates sprite \cmd{n}. \cmd{SPRITE n,x,y} sets its
screen position. Positions are in the same coordinate space as the bitmap
(X~=~0--319, Y~=~0--199). Sprites may be positioned partially or fully
off-screen; they are simply clipped without error.

To hide a sprite, use \cmd{SPRITE n,OFF}. This makes the sprite invisible
without erasing its shape data. You can re-enable it later with
\cmd{SPRITE n,ON} and it will reappear at its last recorded position.

\subsection*{Sprite priority}

Priority controls which layer a sprite is drawn on:

\begin{center}
\begin{tabular}{cl}
\toprule
\textbf{Priority} & \textbf{Layer position} \\
\midrule
0 & Behind all layers (below text and graphics) \\
1 & Between the text and graphics layers \\
2 & In front of all layers (above text and graphics) \\
\bottomrule
\end{tabular}
\end{center}

Priority is set via the MCP sprite tools when building shapes interactively;
it can also be arranged by designing your program so that background sprites
are enabled first and foreground sprites last.

\subsection*{Defining sprite pixels with SPRITEDATA}

Each sprite is 16~pixels wide by 16~pixels tall. Pixel data is loaded one
row at a time using \cmd{SPRITEDATA}:

\begin{center}
\cmd{SPRITEDATA n, row, b1, b2, b3, b4, b5, b6, b7, b8}
\end{center}

\begin{itemize}
  \item \cmd{n} is the sprite index (0--15).
  \item \cmd{row} is the row to define (0--15, top to bottom).
  \item \cmd{b1}--\cmd{b8} are eight byte values (0--255).
\end{itemize}

Each byte encodes \emph{two} pixels. The high nibble (upper four bits) is the
left pixel; the low nibble (lower four bits) is the right pixel. Color~0 is
transparent; colors 1--15 are the standard 16-color palette. With eight bytes
per row and two pixels per byte, each row is exactly 16 pixels wide.

\medskip
\textbf{Example:} a byte value of \cmd{\$AC} (decimal 172) draws pixel color
10 (\cmd{A} in hex) on the left and pixel color 12 (\cmd{C} in hex) on the
right. A value of \cmd{\$00} leaves both pixels transparent.

\medskip
The following example defines a simple 16$\times$16 diamond shape in color~11
(cyan) and displays it:

\begin{lstlisting}[style=basiclisting]
10 REM DEFINE A DIAMOND SPRITE
20 SPRITEDATA 0,  0, 0,   0,   0,  0,  0,   0,   0,  0
30 SPRITEDATA 0,  1, 0,   0,   0, 11,  0,   0,   0,  0
40 SPRITEDATA 0,  2, 0,   0, 177,177,  0,   0,   0,  0
50 SPRITEDATA 0,  3, 0, 187, 187,187,187,   0,   0,  0
60 SPRITEDATA 0,  4, 0, 187, 187,187,187,   0,   0,  0
70 SPRITEDATA 0,  5, 0,   0, 177,177,  0,   0,   0,  0
80 SPRITEDATA 0,  6, 0,   0,   0, 11,  0,   0,   0,  0
90 SPRITEDATA 0,  7, 0,   0,   0,  0,  0,   0,   0,  0
100 REM ROWS 8-15 REMAIN TRANSPARENT (NO SPRITEDATA = NO CHANGE)
110 SPRITE 0, ON
120 SPRITE 0, 152, 92
130 VSYNC
\end{lstlisting}

\begin{notebox}
Any row not explicitly defined by \cmd{SPRITEDATA} retains its previous pixel
data. If you are reusing a sprite slot for a new shape, define all 16 rows
(or clear the slot first). Rows you intentionally leave all-zero produce a
fully transparent row.
\end{notebox}

The bytes in lines~30--80 use decimal notation. Working with hex notation is
often more readable: \cmd{0xBB} = decimal~187, which encodes color~11 in both
nibbles (solid cyan on both pixels of that byte). In NovaBASIC you can write
hex literals directly in expressions using \cmd{\&HBB} notation.

% -----------------------------------------------------------------------------
\section{Sprite Collision Detection}
\label{sec:collision}
% -----------------------------------------------------------------------------

NovaBASIC provides two collision functions that report when sprites overlap
each other or touch non-transparent pixels on the background bitmap.

\begin{center}
\begin{tabular}{>{\ttfamily}p{0.22\textwidth} p{0.65\textwidth}}
\toprule
\textbf{Function} & \textbf{Returns} \\
\midrule
COLLISION(n) & Bitmask of other sprites currently overlapping sprite \cmd{n}. \\[4pt]
BUMPED(n)    & Bitmask indicating that sprite \cmd{n} has touched a
               non-transparent pixel in the graphics bitmap. \\
\bottomrule
\end{tabular}
\end{center}

Both functions return an integer bitmask. Bit \cmd{k} being set means sprite
\cmd{k} is involved in the collision. For \cmd{COLLISION(n)}, if the result
is non-zero then at least one other sprite overlaps sprite~\cmd{n}; use
\cmd{AND} with the appropriate bit to test for a specific sprite. For
\cmd{BUMPED(n)}, a non-zero result means sprite~\cmd{n} is touching a
non-transparent pixel in the graphics bitmap.

\begin{warningbox}
Both collision registers clear automatically when read. Read each register
exactly once per frame and store the result in a variable. If you call
\cmd{COLLISION(n)} or \cmd{BUMPED(n)} a second time in the same frame you
will get zero, missing collisions that occurred between reads.
\end{warningbox}

A practical collision loop pattern:

\begin{lstlisting}[style=basiclisting]
100 VSYNC
110 C = COLLISION(0)
120 B = BUMPED(0)
130 IF C <> 0 THEN GOSUB 500
140 IF B <> 0 THEN GOSUB 600
150 REM UPDATE POSITIONS HERE
160 GOTO 100
\end{lstlisting}

Lines~110--120 read both registers once and store them. Lines~130--140 branch
to handler routines only if a collision has occurred. All position updates
happen after the collision check so that the same frame's register values are
used consistently.

To test whether sprite~\cmd{n} specifically collided with sprite~2, check bit
2 of the \cmd{COLLISION} result:

\begin{lstlisting}[style=basiclisting]
200 C = COLLISION(0)
210 IF (C AND 4) <> 0 THEN PRINT "HIT SPRITE 2"
\end{lstlisting}

% -----------------------------------------------------------------------------
\section{Compatibility Notes}
\label{sec:sprite-compat}
% -----------------------------------------------------------------------------

\begin{warningbox}
The following commands and functions are parsed by NovaBASIC for source
compatibility but currently have no effect at runtime:

\begin{itemize}
  \item \cmd{SPRITESHAPE} --- accepted without error, silently ignored.
  \item \cmd{SPRITECOLOR} --- accepted without error, silently ignored.
  \item \cmd{SPRITEX(n)} --- always returns 0; does not reflect actual
        sprite X position.
  \item \cmd{SPRITEY(n)} --- always returns 0; does not reflect actual
        sprite Y position.
\end{itemize}

Programs that read sprite position back via \cmd{SPRITEX}/\cmd{SPRITEY} must
instead track coordinates in their own variables.
\end{warningbox}

% -----------------------------------------------------------------------------
\section{Try It Now}
\label{sec:graphics-tryit}
% -----------------------------------------------------------------------------

\begin{tryitbox}
Type and run the following program to see \cmd{MODE}, \cmd{GCLS},
\cmd{GCOLOR}, \cmd{RECT}, \cmd{CIRCLE}, and \cmd{PAINT} working together:

\begin{lstlisting}[style=basiclisting]
10 MODE 1 : GCLS : GCOLOR 10
20 RECT 10, 10, 309, 189
30 GCOLOR 14 : CIRCLE 160, 100, 50
40 GCOLOR 12 : PAINT 160, 100
\end{lstlisting}

Expected result: a green rectangle border frames the screen; inside it a
yellow circle outline encloses a solid red filled region.

\medskip
Try modifying \cmd{GCOLOR} values (1--15) and the \cmd{CIRCLE} radius to
explore the coordinate system. Then add a second \cmd{CIRCLE} call on a new
line and re-run to see both circles on the same canvas.
\end{tryitbox}
